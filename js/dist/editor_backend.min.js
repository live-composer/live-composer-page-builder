/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/src/editor/backend/codegeneration.js":
/*!*************************************************!*\
  !*** ./js/src/editor/backend/codegeneration.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codeGenerationInitJS: () => (/* binding */ codeGenerationInitJS),
/* harmony export */   dslc_save_composer: () => (/* binding */ dslc_save_composer),
/* harmony export */   dslc_save_draft_composer: () => (/* binding */ dslc_save_draft_composer),
/* harmony export */   editableContentCodeGeneration: () => (/* binding */ editableContentCodeGeneration),
/* harmony export */   generateSectionCode: () => (/* binding */ generateSectionCode)
/* harmony export */ });
/*********************************
 *
 * = CODE GENERATION =
 *
 * - dslc_save_composer ( Save the Page Changes )
 * - dslc_save_draft_composer ( Save the changes as draft, not publish )
 * - dslc_generate_code ( Generates Page's LC data )
 * - generateSectionCode ( Generate LC data for a specific row/section )
 * - dslca_gen_content_for_search ( Generate Readable Content For Search )
 *
 ***********************************/



/**
 * CODE GENERATION - Save Page Changes
 */
function dslc_save_composer() {
	if ( window.dslcDebug ) console.log( 'dslc_save_composer' );
	/**
	 * Before saving code via ajax
	 * refresh the page source in a hidden #dslca-code
	 */
	window.dslc_generate_code();

	// Generate content for search
	dslca_gen_content_for_search();

	// Vars
	var composerCode = jQuery('#dslca-code').val(),
	contentForSearch = jQuery('#dslca-content-for-search').val(),
	postID = jQuery('.dslca-container').data('post-id');

	// Apply class to body to know saving is in progress
	jQuery('body').addClass('dslca-saving-in-progress');

	// Replace the check in publish button with a loading animation
	jQuery('.dslca-save-composer .dslca-icon').removeClass('dslc-icon-ok').addClass('dslc-icon-spin dslc-icon-spinner');

	// Ajax call to save the new content
	jQuery.ajax({
		method: 'POST',
		type: 'POST',
		url: DSLCAjax.ajaxurl,
		data: {
			action : 'dslc-ajax-save-composer',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_post_id : postID,
			dslc_code : composerCode,
			dslc_content_for_search : contentForSearch
		},
		timeout: 30000
	}).done(function( response ) {

		// On success hide the publish button
		if ( response.status == 'success' ) {
			jQuery('.dslca-save-composer').fadeOut(250);
			jQuery('.dslca-save-draft-composer').fadeOut(250);

			// Create new cache version after it's saved.
			jQuery('body').append( '<iframe class="lbmn-cache-iframe" id="lbmn-cache-iframe-' + postID + '" src="'+ DSLCSiteData.siteurl + '/?p=' + postID +'" ></iframe>' );

			jQuery('.lbmn-cache-iframe').each(function(index, el) {
				jQuery(el).load(function() {
					jQuery(el).remove();
					// Cache built at this point. Remove iframe.
				});
			});

		// On fail show an alert message
		} else {
			alert( 'Something went wrong, please try to save again. Are you sure to make any changes? Error Code: ' + response.status);
		}
	}).fail(function( response ) {

		if ( response.statusText == 'timeout' ) {
			alert( 'The request timed out after 30 seconds. Server do not respond in time. Please try again.' );
		} else {
			alert( 'Something went wrong. Please try again. Error Code: ' + response.statusText  );
		}
	}).always(function( reseponse ) {

		// Replace the loading animation with a check icon
		jQuery('.dslca-save-composer .dslca-icon').removeClass('dslc-icon-spin dslc-icon-spinner').addClass('dslc-icon-ok')

		// Remove the class previously added so we know saving is finished
		jQuery('body').removeClass('dslca-saving-in-progress');
	});
}

/**
 * CODE GENERATION - Save Draft
 */
function dslc_save_draft_composer() {

	if ( window.dslcDebug ) console.log( 'dslc_save_draft_composer' );

	// Vars
	var composerCode = jQuery('#dslca-code').val(),
	postID = jQuery('.dslca-container').data('post-id');

	// Apply class to body to know saving is in progress
	jQuery('body').addClass('dslca-saving-in-progress');

	// Replace the check in publish button with a loading animation
	jQuery('.dslca-save-draft-composer .dslca-icon').removeClass('dslc-icon-ok').addClass('dslc-icon-spin dslc-icon-spinner');

	// Ajax call to save the new content
	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-save-draft-composer',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_post_id : postID,
			dslc_code : composerCode,
		},
		function( response ) {

			// Replace the loading animation with a check icon
			jQuery('.dslca-save-draft-composer .dslca-icon').removeClass('dslc-icon-spin dslc-icon-spinner').addClass('dslc-icon-save')

			// On success hide the publish button
			if ( response.status == 'success' ) {
				jQuery('.dslca-save-draft-composer').fadeOut(250);

			// On fail show an alert message
			} else {

				alert( 'Something went wrong, please try to save again.' );
			}

			// Remove the class previously added so we know saving is finished
			jQuery('body').removeClass('dslca-saving-in-progress');
		}
	);
}

/**
 * CODE GENERATION - Generate LC Data
 * @param section is not required. If no parameter provided function generates
 */
window.dslc_generate_code = function() {
	if ( window.dslcDebug ) console.log( 'dslc_generate_code' );

	// Vars
	var moduleCode = '',
	module_size,
	composerCode = '',
	pageCodeInJson = '',
	maxPerRow = 12,
	maxPerRowA = 12,
	currPerRow = 0,
	currPerRowA = 0,
	modulesAreaSize,
	modulesArea,
	modulesAreaLastState,
	modulesAreaFirstState,
	modulesSection,
	modulesSectionAtts = '',
	modulesSectionJson;

	/**
	 * Go through module areas (empty or not empty)
	 * TODO: Optimize code to go though the section/area needed only,
	 * not the whole page.
	 */

	jQuery('#dslc-main .dslc-modules-area', LiveComposer.Builder.PreviewAreaDocument).each(function(){

		if ( jQuery('.dslc-module-front', this).length ) {

			jQuery(this).removeClass('dslc-modules-area-empty').addClass('dslc-modules-area-not-empty');
			jQuery('.dslca-no-content', this).hide();

		} else {

			jQuery(this).removeClass('dslc-modules-area-not-empty').addClass('dslc-modules-area-empty');

			jQuery('.dslca-no-content:not(:visible)', this).show().css({
				'-webkit-animation-name' : 'dslcBounceIn',
				'-moz-animation-name' : 'dslcBounceIn',
				'animation-name' : 'dslcBounceIn',
				'animation-duration' : '0.6s',
				'-webkit-animation-duration' : '0.6s',
				padding : 0
			}).animate({ padding : '35px 0' }, 300);
		}
	});

	/**
	 * Go through each row (empty or not empty)
	 */

	jQuery('#dslc-main .dslc-modules-section', LiveComposer.Builder.PreviewAreaDocument).each(function(){

		modulesSection = jQuery(this);

		modulesSectionJson = generateSectionCode( modulesSection );

		// Update JSON in hidden text area with updated code.
		modulesSection.find('.dslca-section-code').val( modulesSectionJson );

		// Add row code into the the whole page code.
		pageCodeInJson = pageCodeInJson + modulesSectionJson + ',';

		// Close row ( section ) shortcode
		// composerCode = composerCode + '[/dslc_modules_section] ';
	});


	// Remove the last comma in the code.
	pageCodeInJson = pageCodeInJson.slice(0, -1);

	// pageCodeInJson = pageCodeInJson;
	pageCodeInJson = '[' + pageCodeInJson + ']';

	// Apply the new code values to the setting containers
	jQuery('#dslca-code').val(pageCodeInJson);

	jQuery('#dslca-export-code').val(pageCodeInJson);

	// Create a new "Code Updated" event
	// I'm not sure if we really need to pass source code as event details.
	// Seems like overkill.
	const pageCodeUpdated = new CustomEvent('pageCodeUpdated', /* { detail: pageCodeInJson } */);
	document.dispatchEvent( pageCodeUpdated );
}


/**
 * CODE GENERATION - Generate LC Data for Section
 *
 * @param  {jQuery Object} theModulesSection jQuery element for the section to process
 * @return {String}                   			JSON code for the section
 */
// ex. dslc_generate_section_code
const generateSectionCode = ( theModulesSection ) => {

	if ( window.dslcDebug ) console.log( 'generateSectionCode' );

	// Vars
	var moduleCode = '',
	module_size,
	composerCode = '',
	pageCodeInJson = '',
	maxPerRow = 12,
	maxPerRowA = 12,
	currPerRow = 0,
	currPerRowA = 0,
	modulesAreaSize,
	modulesArea,
	modulesAreaLastState,
	modulesAreaFirstState,
	modulesSection,
	modulesSectionAtts = '',
	modulesSectionJsonString = '',
	modulesSectionJson;

	modulesSection = theModulesSection;

	// Update dslc-modules-section-(not)empty classes
	if ( jQuery('.dslc-modules-area', modulesSection).length ) {
		modulesSection.removeClass('dslc-modules-section-empty').addClass('dslc-modules-section-not-empty');
	} else {
		modulesSection.removeClass('dslc-modules-section-not-empty').addClass('dslc-modules-section-empty');
	}

	// Remove last and first classes from module areas and modules
	jQuery('.dslc-modules-area.dslc-last-col, .dslc-modules-area.dslc-first-col', undefined).removeClass('dslc-last-col dslc-first-col');
	jQuery('.dslc-module-front.dslc-last-col, .dslc-module-front.dslc-first-col', undefined).removeClass('dslc-last-col dslc-first-col');

	// Vars
	currPerRowA = 0;

	// Get current JSON.
	modulesSectionJsonString = modulesSection.find('.dslca-section-code').val();
	modulesSectionJson = JSON.parse(modulesSectionJsonString);

	// Generate attributes for the row shortcode
	modulesSectionAtts = '';

	jQuery('.dslca-modules-section-settings input', modulesSection).each(function(){

		var currentInput = jQuery(this);
		var currentAttrKey = currentInput.data('id');
		var currentAttrVal = currentInput.val();

		// Update hidden text fields with row attributes.
		modulesSectionAtts = modulesSectionAtts + currentAttrKey + '="' + currentAttrVal + '" ';

		// Update JSON object.
		modulesSectionJson[currentAttrKey] = currentAttrVal;
	});

	// Delete attribute 'give_new_id'.
	// It supposed to be used only once and by this time it was already applied.
	if (  undefined !== modulesSectionJson['give_new_id'] ) {
		delete modulesSectionJson['give_new_id'];
	}

	// Prepare place for module areas.
	modulesSectionJson['content'] = [];

	// Open the module section ( row ) shortcode
	// composerCode = composerCode + '[dslc_modules_section ' + modulesSectionAtts + '] ';

	/**
	 * Go through each column of current row
	 */
	jQuery('.dslc-modules-area', modulesSection).each(function(){

		// Reset width counter for modules
		var currPerRow = 0,
		// Other Vars
		modulesArea = jQuery(this),
		modulesAreaSize = parseInt( modulesArea.data('size') ),
		modulesAreaVAlign = modulesArea.data('valign'),
		modulesAreaLastState = 'no',
		modulesAreaFirstState = 'no';
		// Increment area column counter
		currPerRowA += modulesAreaSize;

		jQuery(this).removeClass('dslc-first-col');
		jQuery(this).removeClass('dslc-last-col');

		// If area column counter same as maximum
		if ( currPerRowA == maxPerRowA ) {

			// Apply classes to current and next column
			jQuery(this).addClass('dslc-last-col').next('.dslc-modules-area').addClass('dslc-first-col');

			// Reset area column counter
			currPerRowA = 0;

			// Set shortcode's "last" attribute to "yes"
			modulesAreaLastState = 'yes';

		// If area column counter bigger than maximum
		} else if ( currPerRowA > maxPerRowA ) {

			// Apply classes to current and previous column
			jQuery(this).removeClass('dslc-last-col').addClass('dslc-first-col');

			// Set area column counter to the size of the current area
			currPerRowA = modulesAreaSize;

			// Set shortcode's "first" attribute to yes
			modulesAreaFirstState = 'yes';
		}

		// If area column counter same as current area size
		if ( currPerRowA == modulesAreaSize ) {

			// Set shortcode's "first" attribute to yes
			modulesAreaFirstState = 'yes';

			// Apply classes to current and previous column
			jQuery(this).removeClass('dslc-last-col').addClass('dslc-first-col');

		}

		// Open the modules area ( area ) shortcode
		// composerCode = composerCode + '[dslc_modules_area last="' + modulesAreaLastState + '" first="' + modulesAreaFirstState + '" size="' + modulesAreaSize + '"] ';

		var moduleAreaJSON = '{"element_type":"module_area","last":"' + modulesAreaLastState + '","first":"' + modulesAreaFirstState + '","size":"' + modulesAreaSize + '","valign":"' + modulesAreaVAlign + '"}';
		moduleAreaJSON = JSON.parse( moduleAreaJSON );

		// Delete attribute 'give_new_id'.
		// It supposed to be used only once and by this time it was already applied.
		if (  undefined !== moduleAreaJSON['give_new_id'] ) {
			delete moduleAreaJSON['give_new_id'];
		}

		moduleAreaJSON.content = [];

		/**
		 * Go through each module of current area
		 */

		jQuery('.dslc-module-front', modulesArea).each(function(){

			var dslc_module = jQuery(this);

			// Vars
			module_size = parseInt( dslc_module[0].getAttribute('data-dslc-module-size') );
			var moduleLastState = 'no';
			var moduleFirstState = 'no';

			jQuery(this).removeClass('dslc-first-col');
			jQuery(this).removeClass('dslc-last-col');

			// Increment modules column counter
			currPerRow += module_size;

			// If modules column counter same as maximum
			if ( currPerRow == maxPerRow ) {

				// Add classes to current and next module
				jQuery(this).addClass('dslc-last-col');
				jQuery(this).next('.dslc-module-front').addClass('dslc-first-col');

				// Reset modules column counter
				currPerRow = 0;

				// Set shortcode's "last" state to "yes"
				moduleLastState = 'yes';

				// Set shorcode's "first" state to "yes"
				moduleFirstState = 'yes';


			// If modules column counter bigger than maximum
			} else if ( currPerRow > maxPerRow ) {

				// Add classes to current and previous module
				jQuery(this).removeClass('dslc-last-col').addClass('dslc-first-col');

				// Set modules column counter to the size of current module
				currPerRow = module_size;

				// Set shortcode's "first" state to "yes"
				moduleFirstState = 'yes';
			}

			// If modules column counter same as current module size
			if ( currPerRow == module_size ) {

				// Set shortcode's "first" attribute to yes
				moduleFirstState = 'yes';

				// Apply classes to current and previous column
				jQuery(this).removeClass('dslc-last-col').addClass('dslc-first-col');

			}

			try {
				// Get module's LC data
				// moduleCode = dslc_module[0].querySelector('.dslca-module-code').value; – Don't use. Creating bugs!
				// moduleCode = dslc_module[0].querySelector('.dslca-module-code').innerHTML;
				moduleCode = dslc_module[0].querySelector('.dslca-module-code').innerText;
			} catch(err) {
				console.info( 'No DSLC code found in module: ' + dslc_module[0].getAttribute('id') );
			}

			if ( '' !== moduleCode ) {
				// Add the module shortcode containing the data
				// composerCode = composerCode + '[dslc_module last="' + moduleLastState + '"]' + moduleCode + '[/dslc_module] ';

				var moduleCodeJSON = JSON.parse(moduleCode);
				// Add idicator for the last module in the row.
				moduleCodeJSON.last = moduleLastState;

				// RAW CODE CLEANUP: Clean the module code from keys with empty values.
				jQuery.each(moduleCodeJSON, function(index, el) {
					if ( false === el || '' === el ) {
						delete moduleCodeJSON[index];
					}

					if ( 'content' === index ) {
						moduleCodeJSON[index] = el.replace(/\\'/g, "'");
					}

					if ( 'give_new_id' === index ) {
						delete moduleCodeJSON[index];
					}
				});

				// Put optimized code back into the hidden textarea.
				// dslc_module[0].querySelector('.dslca-module-code').value = JSON.stringify(moduleCodeJSON); - Don't use. Creating bugs!
				dslc_module[0].querySelector('.dslca-module-code').innerText = JSON.stringify(moduleCodeJSON);

				// Add the module JSON as array item
				moduleAreaJSON['content'].push( moduleCodeJSON );
			}

			// Fix bug with modules duplication if broken module saved.
			moduleCode = '';

		});

		modulesSectionJson['content'].push(moduleAreaJSON);

		// Close area shortcode
		// composerCode = composerCode + '[/dslc_modules_area] ';
	});

	var generatedCode = JSON.stringify( modulesSectionJson );

	return generatedCode;
}

/**
 * CODE GENERATION - Document Ready
 */
const setEventListeners = () => {

	/**
	 * Hook - Save Page
	 */
	jQuery(document).on( 'click', '.dslca-save-composer-hook', function(e){
		e.preventDefault();
		// If some saving action not already in progress
		if ( ! jQuery('body').hasClass('dslca-module-saving-in-progress') && ! jQuery('body').hasClass('dslca-saving-in-progress') ) {
			// Call the function to save
			dslc_save_composer();
		}
	});

	/**
	 * Hook - Save Draft
	 */
	jQuery(document).on( 'click', '.dslca-save-draft-composer-hook', function(e){
		e.preventDefault();

		// If some saving action not already in progress
		if ( ! jQuery('body').hasClass('dslca-module-saving-in-progress') && ! jQuery('body').hasClass('dslca-saving-in-progress') ) {
			// Call the function to save
			dslc_save_draft_composer();
		}
	});
}

/**
* Other - Generate Readable Content For Search
*/

function dslca_gen_content_for_search() {

	if ( window.dslcDebug ) console.log( 'dslca_gen_content_for_search' );

	// Vars
	var holder = document.getElementById('dslca-content-for-search');

	if (null === holder) {
		return;
	}

	var prevContent = holder.value;
	var content = '';

	// Go through each content element

	var elements = LiveComposer.Builder.PreviewAreaWindow.document.querySelectorAll('#dslc-main .dslc-module-front [data-exportable-content]');

	if ( undefined !== elements ) {
		Array.prototype.forEach.call(elements, function(el, i){
			// el - current DOM element, i – counter
			var extracted_html_code;

			if ( el.getAttribute('data-exportable-content') !== '' ) {

				var wrapper_tag = el.getAttribute('data-exportable-content');
				extracted_html_code = '<' + wrapper_tag + '>' + el.innerHTML + '</' + wrapper_tag + '>';
			} else {

				extracted_html_code = el.innerHTML;
			}

			if ( extracted_html_code !== null ) {

				content += extracted_html_code.replace(/\s+/g, ' ').trim() + '\n';
			}
		});
	}

	// Set the value of the content field
	holder.value = content;

	// Used to show the publish button for pages made before this feature
	if ( prevContent !== content ) {

		window.dslc_show_publish_button();
	}
}

/**
 * Other - Generate code of editable content
 */
const editableContentCodeGeneration = ( dslcField ) => {
	if ( window.dslcDebug ) console.log( 'editableContentCodeGeneration' );

	// In some rare cases we have the next error:
	// TypeError: undefined is not an object (evaluating 'dslcField.html().trim()...')
	if ( undefined === dslcField ) {
		return false;
	}

	const dslcModule = dslcField.closest('.dslc-module-front');
	const moduleEl = dslcModule[0];
	const dslcContent = dslcField.html().trim().replace(/<textarea/g, '<lctextarea').replace(/<\/textarea/g, '</lctextarea');
	const dslcFieldID = dslcField.data('id');

	// Update module ID in raw base64 code (dslc_code) of the module
	LiveComposer.Utils.update_module_property_raw( moduleEl, dslcFieldID, dslcContent );
	// dslcFieldID = 'content'
	// jQuery('.dslca-module-option-front[data-id="' + dslcFieldID + '"]', dslcModule).val( dslcContent );
}

const codeGenerationInitJS = () => {
	setEventListeners();
}


/***/ }),

/***/ "./js/src/editor/backend/dragndrop.js":
/*!********************************************!*\
  !*** ./js/src/editor/backend/dragndrop.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dragAndDropInit: () => (/* binding */ dragAndDropInit)
/* harmony export */ });
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.js */ "./js/src/editor/backend/module.js");
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");
/**
 * UI - General - Initiate Drag and Drop Functonality
 */




const dragAndDropInit = () => {

	if ( window.dslcDebug ) console.log( 'dslc_drag_and_drop' );
	
	var modulesSection, modulesArea, moduleID, moduleOutput;

	// Drag and Drop for module icons from the list of modules
	var modules_list = jQuery('.dslca-modules .dslca-section-scroller-content'); // Groups that can hold modules
	// jQuery(modules_list).each(function (i,e) {

	if( modules_list.length == 0 ) {

		modules_list = [ document.createElement( 'div' ) ];
	}

	var modules_list_sortable = sortablejs__WEBPACK_IMPORTED_MODULE_1__["default"].create(modules_list[0], {
		sort: false, // do not allow sorting inside the list of modules
		group: { name: 'modules', pull: 'clone', put: false },
		animation: 150,
		handle: '.dslca-module',
		draggable: '.dslca-module',
		// ghostClass: 'dslca-module-placeholder',
		chosenClass: 'dslca-module-dragging',
		scroll: true, // or HTMLElement
		scrollSensitivity: 150, // px, how near the mouse must be to an edge to start scrolling.
		scrollSpeed: 15, // px


		setData: function (dataTransfer, dragEl) {
		//dragEl – contains html of the draggable element like:
		//<div class="dslca-module dslca-scroller-item dslca-origin dslca-origin-General" data-id="DSLC_Button" data-origin="General" draggable="false" style="">

			  // dataTransfer.setData('Text', dragEl.textContent);
			dataTransfer.setData(LiveComposer.Utils.msieversion() !== false ? 'Text' : 'text/html', dragEl.innerHTML);
		},

		// dragging started
		onStart: function (/**Event*/evt) {
			evt.oldIndex;  // element index within parent

			// jQuery( '.dslc-modules-area' ).sortable( "refreshPositions" );
			jQuery('body').removeClass('dslca-new-module-drag-not-in-progress').addClass('dslca-new-module-drag-in-progress');
			jQuery('body', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-new-module-drag-not-in-progress').addClass('dslca-new-module-drag-in-progress');
			jQuery('#dslc-header').addClass('dslca-header-low-z-index');
		},

		// dragging ended
		onEnd: function (/**Event*/evt) {
			evt.oldIndex;  // element's old index within parent
			evt.newIndex;  // element's new index within parent

			var itemEl = evt.item;  // dragged HTML
			evt.preventDefault();
			// evt.stopPropagation();
			//return false;

			// Prevent drop into modules listing
			if(jQuery(itemEl).closest('.dslca-section-scroller-content').length > 0) return false;

			jQuery( '.dslca-options-hovered', LiveComposer.Builder.PreviewAreaDocument ).removeClass('dslca-options-hovered');

			// Vars
			modulesArea = jQuery(itemEl.parentNode); //jQuery(this);
			moduleID = itemEl.dataset.id; // get value of data-id attr.

			window.dslc_generate_code();

			if ( moduleID == 'DSLC_M_A' || jQuery('body').hasClass('dslca-module-drop-in-progress') ||
				modulesArea.closest('#dslc-header').length || modulesArea.closest('#dslc-footer').length ) {

				// nothing

			} else {

				jQuery('body').addClass('dslca-module-drop-in-progress');

				// Add padding to modules area
				/*
				if ( modulesArea.hasClass('dslc-modules-area-not-empty') )
					modulesArea.animate({ paddingBottom : 50 }, 150);
				*/

				// TODO: Optimize expensive ajax call in this function!
				// Load Output
				(0,_module_js__WEBPACK_IMPORTED_MODULE_0__.moduleOutputDefault)( moduleID, function( response ){

					// Append Content
					moduleOutput = response.output;

					// Remove extra padding from area
					// modulesArea.css({ paddingBottom : 0 });

					// Add output
					// TODO: optimize jQuery in the string below

					var dslcJustAdded = LiveComposer.
										Builder.
										Helpers.
										insertModule( moduleOutput, jQuery('.dslca-module', modulesArea) );


					setTimeout( function(){
						LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();
						jQuery('body').removeClass('dslca-module-drop-in-progress');
					}, 700 );

					// "Show" no content text // Not used anymore?
					// jQuery('.dslca-no-content-primary', modulesArea ).css({ opacity : 1 });

					// "Show" modules area management
					jQuery('.dslca-modules-area-manage', modulesArea).css ({ visibility : 'visible' });

					// Generete
					LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();
					LiveComposer.Builder.PreviewAreaWindow.dslc_tabs();
					LiveComposer.Builder.PreviewAreaWindow.dslc_init_accordion();

					window.dslc_generate_code();
					// Show publish
					window.dslc_show_publish_button();
					parent.LiveComposer.Builder.Actions.saveState();

					// LiveComposer.Builder.UI.initInlineEditors();
				});

				// Loading animation

				// Show loader – Not used anymore.
				// jQuery('.dslca-module-loading', modulesArea).show();

				// Change module icon to the spinning loader.
				jQuery(itemEl).find('.dslca-icon').attr('class', '').attr('class', 'dslca-icon dslc-icon-refresh dslc-icon-spin');


				// Hide no content text // Not used anymore?
				// jQuery('.dslca-no-content-primary', modulesArea).css({ opacity : 0 });

				// Hide modules area management
				jQuery('.dslca-modules-area-manage', modulesArea).css ({ visibility : 'hidden' });
				// parent.LiveComposer.Builder.Actions.saveState();

				// Animate loading
				/*
				var randomLoadingTime = Math.floor(Math.random() * (100 - 50 + 1) + 50) * 100;
				jQuery('.dslca-module-loading-inner', modulesArea).css({ width : 0 }).animate({
					width : '100%'
				}, randomLoadingTime, 'linear' );
				*/
			}

			LiveComposer.Builder.UI.stopScroller();
			jQuery('body').removeClass('dslca-new-module-drag-in-progress').addClass('dslca-new-module-drag-not-in-progress');
			jQuery('body', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-new-module-drag-in-progress').addClass('dslca-new-module-drag-not-in-progress');
			jQuery('#dslc-header').removeClass('dslca-header-low-z-index');
		},

		// Element is dropped into the list from another list
		onAdd: function (/**Event*/evt) {
			var itemEl = evt.item;  // dragged HTMLElement
			evt.from;  // previous list
			// + indexes from onEnd
			// evt.preventDefault();
		},

		// Changed sorting within list
		onUpdate: function (/**Event*/evt) {
			var itemEl = evt.item;  // dragged HTMLElement
			// + indexes from onEnd
			window.dslc_show_publish_button();
			parent.LiveComposer.Builder.Actions.saveState();
			// evt.preventDefault();
		},

		// Called by any change to the list (add / update / remove)
		onSort: function (/**Event*/evt) {
			// same properties as onUpdate
			evt.preventDefault();
			// evt.stopPropagation(); return false;
		},

		// Element is removed from the list into another list
		onRemove: function (/**Event*/evt) {
			  // same properties as onUpdate
		},

		// Attempt to drag a filtered element
		onFilter: function (/**Event*/evt) {
			var itemEl = evt.item;  // HTMLElement receiving the `mousedown|tapstart` event.
		},

		// Event when you move an item in the list or between lists
		onMove: function (/**Event*/evt) {
			// Example: http://jsbin.com/tuyafe/1/edit?js,output
			evt.dragged; // dragged HTMLElement
			evt.draggedRect; // TextRectangle {left, top, right и bottom}
			evt.related; // HTMLElement on which have guided
			evt.relatedRect; // TextRectangle
			// return false; — for cancel
			jQuery( evt.to ).addClass('dslca-options-hovered');
		}
	});
}


/***/ }),

/***/ "./js/src/editor/backend/events.js":
/*!*****************************************!*\
  !*** ./js/src/editor/backend/events.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eventsInit: () => (/* binding */ eventsInit)
/* harmony export */ });
/**
 * The place to do all the events bindings.
 */

const eventsInit = () =>{
	// Parent page events.
	document.addEventListener('click', function (event) {
		if ( event.target.matches( '[data-event="modal-wysiwyg-cancel"]' ) ) {
			// Create a new "Modal Cancel" event
			const modalWysiwygCancel = new CustomEvent('modalWysiwygCancel', { detail: event.target });
			document.dispatchEvent( modalWysiwygCancel );
		}

		if ( event.target.matches( '[data-event="modal-wysiwyg-confirm"]' ) ) {
			// Create a new "Modal Cancel" event
			const modalWysiwygConfirm = new CustomEvent('modalWysiwygConfirm', { detail: event.target });
			document.dispatchEvent( modalWysiwygConfirm );
		}

		if ( event.target.matches( '[data-event="module-confirm"]' ) ) {
			// Create "Module Confirm" event
			const moduleConfirm = new CustomEvent('moduleConfirm', { detail: event.target });
			document.dispatchEvent( moduleConfirm );
		}

		if ( event.target.matches( '[data-event="module-cancel"]' ) ) {
			// Create "Module Cancel" event
			const moduleCancel = new CustomEvent('moduleCancel', { detail: event.target });
			document.dispatchEvent( moduleCancel );
		}
	}, false);

	// Preview iframe events: click.
	LiveComposer.Builder.PreviewAreaWindow.document.addEventListener('click', function (event) {
		// Disable default action/event,
		// but only if the link clicked doesn't have '.dslca-link' class.
		if ( ! event.target.matches('.dslca-link') ) {
			// By default all the default click events disabled on LC editing mode.
			// .dslca-link class used to enable default browser behaviour.
			// (ex. open header/footer for editing in new tab).
			event.preventDefault();
		}

		if ( event.target.matches( '[data-event="module-edit"]' ) ) {
			// Create a new "Open Module Editing" event
			const moduleEdit = new CustomEvent('moduleEdit', { detail: event.target });
			document.dispatchEvent( moduleEdit );
		}

		if ( event.target.matches( '[data-event="module-duplicate"]' ) ) {
			// Create a new "Duplicate Module" event
			const moduleDuplicate = new CustomEvent('moduleDuplicate', { detail: event.target });
			document.dispatchEvent( moduleDuplicate );
		}

		if ( event.target.matches( '[data-event="module-delete"]' ) ) {
			// Create a new "Delete Module" event
			const moduleDelete = new CustomEvent('moduleDelete', { detail: event.target });
			document.dispatchEvent( moduleDelete );
		}

		const sizeEl = event.target.closest('.dslca-change-width-module-options [data-size]');
		if ( sizeEl ) {
			const moduleChangeWidth = new CustomEvent('moduleChangeWidth', { detail: sizeEl });
			document.dispatchEvent(moduleChangeWidth);
		}

		if ( event.target.matches( '[data-event="wysiwyg-edit"]' ) ) {
			// Create a new "Module WYSIWYG Editing" event
			const wysiwygEdit = new CustomEvent('wysiwygEdit', { detail: event.target });
			document.dispatchEvent( wysiwygEdit );
		}

		if ( event.target.matches( '[data-event="module-style-copy"]' ) ) {
			// Create a new "Copy Module Style" event
			const copyStyles = new CustomEvent('copyModuleStyles', { detail: event.target });
			document.dispatchEvent( copyStyles );
		}

		if ( event.target.matches( '[data-event="module-style-paste"]' ) ) {
			// Create a new "Paste Module Style" event
			const pasteStyles = new CustomEvent('pasteModuleStyles', { detail: event.target });
			document.dispatchEvent( pasteStyles );
		}

	}, false);

	// Preview iframe events: focusout.
	LiveComposer.Builder.PreviewAreaWindow.document.addEventListener('focusout', function (event) {
		// This event gets dispatched when the contenteditable element loses focus.
		// Useful when you need to save data when element text edited.
		if ( event.target.matches( '[contenteditable="true"]' ) ) {
			const contentEditableFocusOut = new CustomEvent('contentEditableFocusOut', { detail: event.target });
			document.dispatchEvent( contentEditableFocusOut );
		}
	}, false);
	
	// Row and Modules Input Validation Logic
	document.addEventListener("input", function (e) {
		// Check if the input that triggered the event matches our selector
		if (e.target.matches('.dslca-modules-section-edit-field-slider-numeric, .dslca-module-edit-field-numeric')) {
			const input = e.target;
			let value = parseFloat(input.value);

			// Priority: attribute min/max → data-min/data-max
			let min = input.getAttribute("min");
			let max = input.getAttribute("max");

			// fallback to data-min/max if min/max not present
			if (min === null) min = input.dataset.min;
			if (max === null) max = input.dataset.max;

			min = parseFloat(min);
			max = parseFloat(max);

			// Validation logic
			if (!isNaN(min) && value < min) {
				input.value = min;
			} 
			else if (!isNaN(max) && value > max) {
				input.value = max;
			}
			input.dispatchEvent('change');

		}
	});
}

/***/ }),

/***/ "./js/src/editor/backend/modalwindow.class.js":
/*!****************************************************!*\
  !*** ./js/src/editor/backend/modalwindow.class.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CModalWindow: () => (/* binding */ CModalWindow)
/* harmony export */ });
/**
 * Modal Window Class file
 */

/**
 * Shows modal window
 *
 * @param {object} params
 * @params.title         {string} - modal window title
 * @params.content       {string}- modal window description
 * @params.confirm       {function} - modal window confirm action
 * @params.cancel        {function} - modal window cancel action
 * @params.cancel_title  {string} - modal window cancel title
 * @params.confirm_title {string} - modal window confirm title
 * @params.ok_title {string} - modal window OK title
 */
const CModalWindow = function(params) {

    if( typeof params != 'object' || LiveComposer.Builder.Flags.modalOpen === true ) return false;

    var self = this;

    // Show Modal Window
    var modalWindowWrap = '<div class="dslca-prompt-modal dslca-prompt-modal-active">' +
    '<div class="dslca-prompt-modal-content"><div class="dslca-prompt-modal-msg">' +
     '<span class="dslca-prompt-modal-title">' + params.title + '</span>' +
      '<span class="dslca-prompt-modal-descr">' + params.content + '</span></div>';

      var modalWindowActions = '';

    if (params.confirm || params.cancel) {

        modalWindowActions = '<div class="dslca-prompt-modal-actions">' +
        '<a href="#" class="dslca-prompt-modal-confirm-hook"><span class="dslc-icon dslc-icon-ok">' +
        '</span>' + (params.confirm_title ? params.confirm_title : 'Confirm') + '</a><span class="dslca-prompt-modal-cancel-hook"><span class="dslc-icon dslc-icon-remove">' +
        '</span>' + (params.cancel_title ? params.cancel_title : 'Cancel') +'</span></div>';
    } else {

        modalWindowActions = '<div class="dslca-prompt-modal-actions">' +
        '<a href="#" class="dslca-prompt-modal-confirm-hook"><span class="dslc-icon dslc-icon-ok">' +
        '</span>' + (params.ok_title ? params.ok_title : 'OK') + '</a></div>';
    }

    modalWindowWrap += modalWindowActions + '</div>';
    modalWindowWrap = jQuery(modalWindowWrap);

    if (typeof params.confirm != 'function') params.confirm = function(){};
    if (typeof params.cancel != 'function') params.cancel = function(){};

    // Confirm handler (function)

    modalWindowWrap.find('.dslca-prompt-modal-confirm-hook')
    .click(function(e)
    {
        e.stopPropagation();

        modalWindowWrap.find('.dslca-prompt-modal-content').animate({
            top: '55%'
        }, 400);

        modalWindowWrap.animate(
            {opacity: 0},
            400,
            function()
            {
                params.confirm();
                LiveComposer.Builder.Flags.modalOpen = false;
                jQuery(this).remove();
                // – moved here as it prevent some JS to get value on time
            }
        );

        return false;
    });

    // Cancel handler (function)

    modalWindowWrap.find('.dslca-prompt-modal-cancel-hook')
    .click(function(e){

        e.stopPropagation();

        modalWindowWrap.find('.dslca-prompt-modal-content').animate({
            top: '55%'
        }, 400);

        modalWindowWrap.animate(
            {opacity: 0},
            400,
            function()
            {
                jQuery(this).remove();
                LiveComposer.Builder.Flags.modalOpen = false;
                params.cancel();
            }
        );

        return false;
    });

    modalWindowWrap.hide();
    jQuery("body").append(modalWindowWrap);

    modalWindowWrap.css({opacity: 0}).show().animate({
        opacity: 1,
    }, 400);

    // Animate modal
    modalWindowWrap.find('.dslca-prompt-modal-content').css({top: '55%'}).animate({
        top: '50%'
    }, 400);

    LiveComposer.Builder.Flags.modalOpen = true;
}

/***/ }),

/***/ "./js/src/editor/backend/modalwindow.js":
/*!**********************************************!*\
  !*** ./js/src/editor/backend/modalwindow.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   confirmClose: () => (/* binding */ confirmClose),
/* harmony export */   hideModal: () => (/* binding */ hideModal),
/* harmony export */   modalwindowInitJS: () => (/* binding */ modalwindowInitJS)
/* harmony export */ });
/* harmony import */ var _codegeneration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./codegeneration.js */ "./js/src/editor/backend/codegeneration.js");
/*********************************
 *
 * = UI - MODAL =
 * Note: Used for the templates save/export/import and icons
 *
 * - dslc_show_modal ( Show Modal )
 * - dslc_hide_modal ( Hide Modal )
 *
 ***********************************/


/**
 * MODAL - Show
 *
 * @param {Object} hook - Button that was clicked to open modal
 * @param {string} modal - CSS address of the modal, like '.modal-icons'
 */

function dslc_show_modal( hook, modal ) {

	if ( typeof dslcDebug !== 'undefined' && dslcDebug ) console.log( 'dslc_show_modal' );

	if ( jQuery('.dslca-modal:visible').length ) {
		// If a modal already visibile hide it
		hideModal( '', jQuery('.dslca-modal:visible') );
	}

	// Vars
	var modal = jQuery(modal);

	// Calc popup height
	var containerHeight = jQuery('.dslca-container').height();
	modal.outerHide({
		clbk: function(){

			hideModal( '', jQuery('.dslca-modal:visible') );
		}
	});

	// Vars ( Calc Offset )
	var position = jQuery(hook).position(),
	diff = modal.outerWidth() / 2 - hook.outerWidth() / 2,
	offset = position.left - diff;

	// Show Modal
	modal.css({ left : offset });
	jQuery(".dslca-prompt-modal-custom").insertAfter( modal );
	if ( jQuery(".dslca-prompt-modal-custom").length > 0 ) {
		jQuery(".dslca-prompt-modal-custom").fadeIn();
	}
	modal.addClass('dslca-modal-open').show();

	// Animate Modal
	// modal.css({
		// '-webkit-animation-name' : 'dslcBounceIn',
		// '-moz-animation-name' : 'dslcBounceIn',
		// 'animation-name' : 'dslcBounceIn',
		// 'animation-duration' : '0.6s',
		// '-webkit-animation-duration' : '0.6s'
	// }).fadeIn(600);
}

/**
 * MODAL - Hide
 */

 // ex. dslc_hide_modal
const hideModal = ( hook, modal ) => {

	if ( typeof dslcDebug !== 'undefined' && dslcDebug ) console.log( 'hideModal' );

	// Vars
	var modal = jQuery(modal);

	// Hide ( with animation )
	modal.outerHide( 'destroy' );
	modal.hide();
	if ( jQuery(".dslca-prompt-modal-custom").length > 0 ) {
		jQuery(".dslca-prompt-modal-custom").fadeOut();
	}
	modal.removeClass('dslca-modal-open');
	/*
	modal.css({
		'-webkit-animation-name' : 'dslcBounceOut',
		'-moz-animation-name' : 'dslcBounceOut',
		'animation-name' : 'dslcBounceOut',
		'animation-duration' : '0.6s',
		'-webkit-animation-duration' : '0.6s'
	}).fadeOut(600);
	*/

}

// Hide if clicked outside of modal
/*jQuery(document).mouseup(function (e) {
		var container = jQuery(".dslca-modal-open");

		if (!container.is(e.target) // if the target of the click isn't the container...
		&& container.has(e.target).length === 0) // ... nor a descendant of the container
		{
		container.hide();
		}
});*/

/**
 * MODAL - Document Ready
 */

jQuery(document).ready(function($){

	/**
	 * Hook - Show Modal
	 */

	jQuery(document).on( 'click', '.dslca-open-modal-hook', function(e){
		e.preventDefault();
		var modal = jQuery(this).data('modal');
		dslc_show_modal( jQuery(this), modal );
	});

	/**
	 * Hook - Hide Modal
	 */

	jQuery(document).on( 'click', '.dslca-close-modal-hook', function(e){

		e.preventDefault();

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			var modal = jQuery(this).data('modal');
			hideModal( jQuery(this), modal );
		}
	});

});


/*********************************
 *
 * 5) = UI - PROMPT MODAL =
 *
 * - dslc_js_confirm
 * - dslc_js_confirm_close
 *
 ***********************************/
function dslc_js_confirm( dslcID, dslcContent, dslcTarget ) {

	if ( typeof dslcDebug !== 'undefined' && dslcDebug ) console.log( 'dslc_js_confirm' );

	// Add "active" class
	jQuery('.dslca-prompt-modal').addClass('dslca-prompt-modal-active');

	// Add the ID of current event
	jQuery('.dslca-prompt-modal').data( 'id', dslcID );
	jQuery('.dslca-prompt-modal').data( 'target', dslcTarget );

	// Add modal content
	jQuery('.dslca-prompt-modal-msg').html( dslcContent );

	// Show modal
	jQuery('.dslca-prompt-modal').css({ opacity : 0 }).show().animate({
		opacity : 1,
	}, 400);

	// Animate modal
	jQuery('.dslca-prompt-modal-content').css({ top : '55%' }).animate({
		top : '50%'
	}, 400);
}

// ex. dslc_js_confirm_close
const confirmClose = () => {

	if ( typeof dslcDebug !== 'undefined' && dslcDebug ) console.log( 'dslc_js_confirm_close' );

	// Remove "active" class
	jQuery('.dslca-prompt-modal').removeClass('dslca-prompt-modal-active');

	// Hide modal
	jQuery('.dslca-prompt-modal').animate({
		opacity : 0,
	}, 400, function(){
		jQuery(this).hide();
		jQuery('.dslca-prompt-modal-cancel-hook').show();
		jQuery('.dslca-prompt-modal-confirm-hook').html('<span class="dslc-icon dslc-icon-ok"></span>' + DSLCString.str_confirm);
	});

	jQuery('.dslca-prompt-modal-content').animate({
		top : '55%'
	}, 400);

}

/**
 * Hook - Confirm on Enter, Cancel on Esc
 */

window.dslc_modal_keypress_events = function dslc_modal_keypress_events(e) {

	// Enter ( confirm )
	if( e.which == 13 ) {
		if ( jQuery('.dslca-prompt-modal-active').length ) {
			jQuery('.dslca-prompt-modal-confirm-hook').trigger('click');
		}

	// Escape ( cancel )
	} else if ( e.which == 27 ) {
		if ( jQuery('.dslca-prompt-modal-active').length ) {
			jQuery('.dslca-prompt-modal-cancel-hook').trigger('click');
		}
	}

}

/**
 * UI - PROMPT MODAL - Document Ready
 */

jQuery(document).ready(function($){

	jQuery(document).on( 'click', '.dslca-prompt-modal-cancel-hook', function(e){

		e.preventDefault();

		var dslcAction = jQuery('.dslca-prompt-modal').data('id');
		var dslcTarget = jQuery('.dslca-prompt-modal').data('target');

		if ( dslcAction == 'edit_in_progress' ) {

			/// MOVED
			dslc_module_options_cancel_changes( function(){
				dslcTarget.trigger('click');
			});

		} else if ( dslcAction == 'delete_module' ) {

		}

		confirmClose();
		jQuery('.dslca-prompt-modal').data( 'id', '' );

	});

	jQuery(document).on( 'click', '.dslca-prompt-modal-confirm-hook', function(e){

		e.preventDefault();

		var dslcAction = jQuery('.dslca-prompt-modal').data('id');
		var dslcTarget = jQuery('.dslca-prompt-modal').data('target');
		var closeAtEnd = true;

		if (  dslcAction == 'edit_in_progress' ) {

			/// MOVED
			dslc_module_options_confirm_changes( function(){
				dslcTarget.trigger('click');
			});

		} else if ( dslcAction == 'disable_lc' ) {

			window.location = dslcTarget;

		} else if ( 'delete_module' === dslcAction ) {

			/// MOVED
			var module = dslcTarget.closest('.dslc-module-front');
			dslc_module_delete( module );

		} else if ( 'delete_modules_area' === dslcAction ) {

			var modulesArea = dslcTarget.closest('.dslc-modules-area');
			var parentSectionContainer = modulesArea.closest('.dslc-modules-section-inner');
			dslc_modules_area_delete( modulesArea );

		} else if ( dslcAction == 'delete_modules_section' ) {

			/// MOVED
			dslc_row_delete( dslcTarget.closest('.dslc-modules-section') );

		} else if ( dslcAction == 'export_modules_section' ) {

		} else if ( dslcAction == 'import_modules_section' ) {

			/// MOVED
			dslc_row_import( jQuery('.dslca-prompt-modal textarea').val() );
			jQuery('.dslca-prompt-modal-confirm-hook span').css({ opacity : 0 });
			jQuery('.dslca-prompt-modal-confirm-hook .dslca-loading').show();
			closeAtEnd = false;
		}

		if ( closeAtEnd ) {
			confirmClose();
		}

		jQuery('.dslca-prompt-modal').data( 'id', '' );
	});

});

/**
 * DON'T MOVE THE FUNCTION BELLOW OUT OF THIS FILE!
 * Hide element when click on another element on the page
 */
jQuery.fn.outerHide = function(params) {
	var $ = jQuery;
	params = params ? params : {};

	var self = this;

	if ( 'destroy' == params ) {

		jQuery(document).unbind('click.outer_hide');
		return false;
	}

	jQuery(document).bind('click.outer_hide', function(e) {

		if (jQuery(e.target).closest(self).length == 0 &&
			e.target != self &&
			$.inArray(jQuery(e.target)[0], jQuery(params.clickObj)) == -1 &&
			jQuery(self).css('display') != 'none'
		)
		{
			if(params.clbk)
			{
				params.clbk();
			}else{
				jQuery(self).hide();
			}
		}
	});
}

/**
 * Cancel changes in standard WP Editor (TinyMCE) WYSIWYG
 */
document.addEventListener( 'modalWysiwygCancel', function ( customEvent ) {
	jQuery('.dslca-wp-editor').hide();
	jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).removeClass('dslca-wysiwyg-active');
});

/**
 * Confirm changes in standard WP Editor (TinyMCE) WYSIWYG
 */
document.addEventListener( 'modalWysiwygConfirm', function ( customEvent ) {
	var module = jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).closest('.dslc-module-front');

	if( typeof tinymce != "undefined" ) {
		if ( jQuery('#wp-dslcawpeditor-wrap').hasClass('tmce-active') ) {
			var editor = tinymce.get( 'dslcawpeditor' );
			var content = editor.getContent();
		} else {
			var content = jQuery('#dslcawpeditor').val();
		}

		content = content.trim();
		jQuery('.dslca-wp-editor').hide();
		jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).html( content );

		if ( module.hasClass('dslc-module-handle-like-accordion') ) {
			jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).siblings('.dslca-editable-content').html( content );
			jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).siblings('.dslca-accordion-plain-content').val( content );
			var dslcAccordion = module.find('.dslc-accordion');
			LiveComposer.Builder.PreviewAreaWindow.dslc_accordion_generate_code( dslcAccordion );
		} else if ( module.hasClass('dslc-module-handle-like-tabs') ) {
			jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).siblings('.dslca-editable-content').html( content );
			jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).siblings('.dslca-tab-plain-content').val( content );
			var dslcTabs = module.find('.dslc-tabs');
			LiveComposer.Builder.PreviewAreaWindow.dslc_tabs_generate_code( dslcTabs );
		} else {
			// The next function is not compatible for Tab and Accordions.
			(0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_0__.editableContentCodeGeneration)( jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ) );
		}

		jQuery('.dslca-wysiwyg-active', LiveComposer.Builder.PreviewAreaDocument ).removeClass('dslca-wysiwyg-active');
	} else {
		console.info( 'Live Composer: TinyMCE is undefined.' );
	}
});

const modalwindowInitJS = () => {

}


/***/ }),

/***/ "./js/src/editor/backend/module.js":
/*!*****************************************!*\
  !*** ./js/src/editor/backend/module.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNewModuleId: () => (/* binding */ getNewModuleId),
/* harmony export */   moduleInitJS: () => (/* binding */ moduleInitJS),
/* harmony export */   moduleOutputAltered: () => (/* binding */ moduleOutputAltered),
/* harmony export */   moduleOutputDefault: () => (/* binding */ moduleOutputDefault)
/* harmony export */ });
/* harmony import */ var _modalwindow_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modalwindow.class.js */ "./js/src/editor/backend/modalwindow.class.js");
/* harmony import */ var _uigeneral_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uigeneral.js */ "./js/src/editor/backend/uigeneral.js");
/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! animejs */ "./node_modules/animejs/dist/modules/animation/animation.js");
/* harmony import */ var _codegeneration_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./codegeneration.js */ "./js/src/editor/backend/codegeneration.js");
/**
 *  Builder module functions & hooks
 *
 *   = MODULES =
 *
 * - dslc_module_delete ( Deletes a module )
 * - moduleDuplicate ( Copies a module )
 * - dslc_module_width_set ( Sets a width to module )
 * - dslc_module_options_show ( Show module options )
 * - dslc_module_options_section_filter ( Filter options section )
 * - dslc_module_options_hideshow_tabs ( Hide show tabs based on option choices )
 * - dslc_module_options_confirm_changes ( Confirm changes )
 * - dslc_module_options_cancel_changes ( Cancel changes )
 * - dslc_module_options_tooltip ( Helper tooltips for options )
 * - dslc_module_options_font ( Actions for font option type )
 * - dslc_module_options_icon ( Actions for icon font option type )
 * - dslc_module_options_icon_returnid (Fill icon option type with selected icon ID/name)
 * - dslc_module_options_text_align ( Actions for text align option type )
 * - dslc_module_options_checkbox ( Actions for checkbox option type )
 * - dslc_module_options_box_shadow ( Actions for box shadow option type )
 * - dslc_modules_options_box_shadow_color ( Initiate colorpicker for box shadow)
 * - dslc_module_options_text_shadow ( Actions for text shadow option type )
 * - dslc_modules_options_text_shadow_color ( Initiate colorpicker for text shadow)
 * - dslc_module_options_color ( Actions for color option type )
 * - dslc_module_output_default ( Get module output with default settings )
 * - dslc_module_output_altered ( Get module output when settings altered )
 *
 */






var actionAvail = function() {

	if ( LiveComposer.Builder.Flags.panelOpened ) {
		LiveComposer.Builder.UI.shakePanelConfirmButton();
		return false;
	}

	return true;
}

/**
 * Hook - Duplicate Module
 */
document.addEventListener('moduleDuplicate', function (customEvent) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.

	// Check if action can be fired
	if ( ! actionAvail() ) return false;

	if ( ! elClicked.classList.contains('dslca-action-disabled') ) {
		moduleDuplicate( elClicked.closest('.dslc-module-front') );
	}
});

/**
 * Hook - Module Delete
 */

document.addEventListener( 'moduleDelete', function (customEvent) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.

	// Check if action can be fired
	if ( ! actionAvail() ) return false;

	var self = this;

	if ( ! elClicked.classList.contains('dslca-action-disabled') ) {

		(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_0__.CModalWindow)({
			title: DSLCString.str_del_module_title,
			content: DSLCString.str_del_module_descr,
			confirm: function() {

				var module = elClicked.closest('.dslc-module-front');
				dslc_module_delete( module );
			}
		});
	}
});

/**
 * Hook - Edit Module On Click ( Display Options Panel )
 */
document.addEventListener('moduleEdit', function (customEvent) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.
	const currentModuleEl = elClicked.closest('.dslc-module-front');
	const currentModuleId = currentModuleEl.dataset.module;

	const elEditing = LiveComposer.Builder.PreviewAreaWindow.document.querySelector('.dslca-module-being-edited');
	const row_edited = jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).length;

	// If settings panel opened - do not proceed.
	if ( LiveComposer.Builder.Flags.uiHidden || ( null !== elEditing && elEditing.length > 0 ) || row_edited > 0 ) {
		if ( elEditing != currentModuleEl ) {
			LiveComposer.Builder.UI.shakePanelConfirmButton();
		}
		return false;
	}
	unmarkModulesBeingEdited();

	// Add the "being edited" class to current module
	currentModuleEl.classList.add('dslca-module-being-edited');
	// Call the function to display options
	window.dslc_module_options_show( currentModuleId );
	// Cover up other modules with semi transp cover
	LiveComposer.Builder.PreviewAreaWindow.document.body.classList.add('module-editing-in-progress');
});

/**
 * Hook - Copy Module Styles On Click
 */
document.addEventListener('copyModuleStyles', function (customEvent) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.
	const currentModuleEl = elClicked.closest('.dslc-module-front');

	// Get module code.
	let currentModuleCode = currentModuleEl.querySelector( '.dslca-module-code').innerText;
	// Save coppied styles in local storage (real buffer isn't supported by all the browsers).
	localStorage.setItem( 'lcCopyPasteStorage', currentModuleCode );
});

/**
 * Hook - Paste Module Styles On Click
 */
document.addEventListener('pasteModuleStyles', function (customEvent) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.
	const currentModuleEl = elClicked.closest('.dslc-module-front');
	const dslcModule = jQuery( currentModuleEl );
	// Extract paste value from the local storage.
	const pasteModuleCode = localStorage.getItem( 'lcCopyPasteStorage' );
	let pasteModuleProperies = false;
	if ( pasteModuleCode ) {
		try {
			pasteModuleProperies = JSON.parse( pasteModuleCode );
		} catch(e) {
			console.log( "Can't parse copy/paste string into JSON:" );
			console.log( e );
		}
	}

	if ( pasteModuleProperies ) {
		// Does module id from paste data match with current block?
		if ( pasteModuleProperies.module_id === currentModuleEl.dataset.module ) {
			const currentModuleCodeContainer = currentModuleEl.querySelector('.dslca-module-code');
			const currentModuleCode = currentModuleCodeContainer.innerText;
			let currentModuleProperties = false;
			try {
				currentModuleProperties = JSON.parse( currentModuleCode );
			} catch(e) {
				console.log( "Can't parse current module code into JSON:" );
				console.log( e );
			}

			if ( currentModuleProperties ) {
				let modulePropertiesChanged = false;
				for (let propertyId in pasteModuleProperies) {
					// Override all styling properties with the ones from pasted styles.
					if ( propertyId.includes( 'css_' ) ) {
						currentModuleProperties[ propertyId ] = pasteModuleProperies[ propertyId ];
						modulePropertiesChanged = true;
					}
				}

				for (let propertyId in currentModuleProperties) {
					// If property is missing in pasted data make it empty.
					if ( propertyId.includes( 'css_' ) ) {
						if ( currentModuleProperties[ propertyId ] !== pasteModuleProperies[ propertyId ] ) {
							currentModuleProperties[ propertyId ] = '';
						}
						modulePropertiesChanged = true;
					}
				}

				if ( modulePropertiesChanged ) {
					// Prepare and call AJAX module redraw request.
					currentModuleProperties['action'] = 'dslc-ajax-add-module';
					currentModuleProperties['_wpnonce'] = DSLCAjax._wpnonce;
					currentModuleProperties['dslc'] = 'active';
					currentModuleProperties['dslc_module_id'] = currentModuleProperties.module_id;
					currentModuleProperties['dslc_module_instance_id'] = currentModuleProperties.module_instance_id;
					currentModuleProperties['dslc_post_id'] = currentModuleProperties.post_id;

					if ( dslcModule.hasClass('dslca-preload-preset') )
						currentModuleProperties['dslc_preload_preset'] = 'enabled';
					else
						currentModuleProperties['dslc_preload_preset'] = 'disabled';

					dslcModule.removeClass('dslca-preload-preset');
					currentModuleProperties.dslc_url_vars = LiveComposer.Utils.get_page_params();

					/**
					 * Call AJAX for module redraw
					 */
					jQuery.post(
						DSLCAjax.ajaxurl, currentModuleProperties,
						function( response ) {
							if ( response ) {
								dslcModule.after(response.output).next().addClass('dslca-module-being-edited');
								dslcModule.remove();
								window.dslc_generate_code();
								window.dslc_show_publish_button();
								
								LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();
								LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();
								
								LiveComposer.Builder.PreviewAreaWindow.dslc_tabs();
								LiveComposer.Builder.PreviewAreaWindow.dslc_init_accordion();
								
								jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');
								parent.LiveComposer.Builder.Actions.saveState();
							}
						}
					);
				}
			}
		}
	}
});

/**
 * Hook - Edit Module On Click ( Display Options Panel ) - Fixed: https://github.com/live-composer/live-composer-page-builder/issues/895
 */

const adjustZindex = () => {
	LiveComposer.Builder.PreviewAreaDocument.on( {
		mouseenter: function(e) {
			// Adjust z-index.
			jQuery('.dslca-modules-section-manage', LiveComposer.Builder.PreviewAreaDocument).css("z-index", "99998");

			// Adjust module editing controls for too small elements.
			const moduleEl = e.target.closest("[data-module-id]");
			const elementHeight = moduleEl.offsetHeight;
			const elementWidth = moduleEl.offsetWidth;

			if ( elementHeight < 60 && elementWidth < 300 ) {
				moduleEl.classList.add('dslc-small-height-module');
			} else {
				moduleEl.classList.remove('dslc-small-height-module');
			}

		},
		mouseleave: function(e) {
			jQuery('.dslca-modules-section-manage', LiveComposer.Builder.PreviewAreaDocument).css("z-index", "999999");
		},
	}, '.dslca-change-width-module-hook, .dslc-module-front .dslca-module-manage');
}

/**
 * Hook - Set Module Width
 */

document.addEventListener('moduleChangeWidth', function ( customEvent ) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.
	const currentModuleEl = elClicked.closest('.dslc-module-front');

	if ( ! elClicked.classList.contains('dslca-action-disabled') ) {
		var oldSize = currentModuleEl.dataset.dslcModuleSize;
		var newSize = elClicked.dataset.size;

		// Start expensive function only if the value changed.
		if (  Number(oldSize) !== Number(newSize) ) {
			dslc_module_width_set( currentModuleEl, newSize );
		}
	}

});

/**
 * Hook - Show code for altering module's defaults
 */
/*
FIXIT
LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-module-get-defaults-hook', function(){

	// Vars
	var module = jQuery(this).closest('.dslc-module-front');
	var code = dslc_dm_get_defaults( module );

	// Generate modal's text
	var message = '<span class="dslca-prompt-modal-title">Module Defaults</span>'
		+ '<span class="dslca-prompt-modal-descr">The code bellow is used to alter the defaults.</span>'
		+ '<textarea></textarea><br><br>';

	// Hide modal's cancel button
	jQuery('.dslca-prompt-modal-cancel-hook').hide();

	// Show confirm button and change it to "OK"
	jQuery('.dslca-prompt-modal-confirm-hook').html('<span class="dslc-icon dslc-icon-ok"></span>OK');

	// Show the modal prompt
	dslc_js_confirm( 'dev_mode_get_default', message, module );
}); */

/**
 * Hook - Refresh Module
 * We have 'refresh' icon on blog posts grid and other post-based modules.
 * It's visible only when there are no posts to render.
 */
/*
FIXIT
LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-refresh-module-hook', function(e){

	jQuery(this).css({
		'-webkit-animation-name' : 'dslcRotate',
		'-moz-animation-name' : 'dslcRotate',
		'animation-name' : 'dslcRotate',
		'animation-duration' : '0.6s',
		'-webkit-animation-duration' : '0.6s',
		'animation-iteration-count' : 'infinite',
		'-webkit-animation-iteration-count' : 'infinite'
	});
	jQuery(this).closest('.dslc-module-front').addClass('dslca-module-being-edited');
	moduleOutputAltered( function() {

		jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');
	});
}); */

/**
 * Show WYSIWYG
 */

document.addEventListener('wysiwygEdit', function ( customEvent ) {
	const elClicked = customEvent.detail;  // customEvent.detail - is element being clicked passed as additional data in the event.
	const currentModuleEl = elClicked.closest('.dslc-module-front');

	// const editableEl = elClicked.querySelector('.dslca-editable-content');
	const idToEdit = elClicked.dataset.idToEdit;

	const editableEl = currentModuleEl.querySelector('[data-edit-id="' + idToEdit + '"]');
	let content = '';

	if ( 'TEXTAREA'=== editableEl.tagName || 'INPUT'=== editableEl.tagName ) {
		content = editableEl.value;
	} else {
		content = editableEl.innerHTML;
	}

	if ( undefined === content ) {
		content = '';
	}

	if ( content.trim().length ) {
		// Extract Content for current tab/accordion:
		/* if ( currentModuleEl.classList.contains('dslc-module-handle-like-accordion') || currentModuleEl.classList.contains('dslc-module-handle-like-tabs') ) {
			const full_content_arr = content.split('(dslc_sep)');
			if ( full_content_arr.length ) {
				content = full_content_arr[idToEdit].trim();
			}
		} */

		content = content.replace(/<lctextarea/g, '<textarea').replace(/<\/lctextarea/g, '</textarea');
	}

	// Restore shortcodes presentation.
	if ( content.includes( '%' ) ) {
		content = content.replace(/%\(\(%/g, '[');
		content = content.replace(/%\)\)%/g, ']');
		content = content.replace(/%\(%/g, '[');
		content = content.replace(/%\)%/g, ']');
		content = content.replace(/%\{%/g, '[');
		content = content.replace(/%\}%/g, ']');
	}

	content = content.trim();

	// Fill TinyMCE editor with extracted above content.
	if ( typeof tinymce != 'undefined' ) {
		var editor = tinymce.get( 'dslcawpeditor' );

		if ( document.getElementById('wp-dslcawpeditor-wrap').classList.contains('tmce-active') ) {
			editor.setContent( content, {format : 'html'} );
		} else {
			document.getElementById('dslcawpeditor').value = content;
		}

		if ( ! currentModuleEl.classList.contains('dslca-module-being-edited') ) {
			currentModuleEl.querySelector('.dslca-module-edit-hook').click();
		}

		jQuery('.dslca-wp-editor').show();
		editableEl.classList.add('dslca-wysiwyg-active');
		jQuery('#dslcawpeditor_ifr, #dslcawpeditor').css({ height : jQuery('.dslca-wp-editor').height() - 300 });
	} else {
		console.info( 'Live Composer: TinyMCE is undefined.' );
	}
});

// Editable Contents.
const editableContentTextEvents = () => {

	// Preview iframe events.
	/* LiveComposer.Builder.PreviewAreaWindow.document.addEventListener('blur', function (event) {
		// event.preventDefault();
		if ( event.target.matches( '[data-event="module-edit"]' ) ) {

		}
	});
 */
/* 	LiveComposer.Builder.PreviewAreaWindow.document.addEventListener('keyup', function (event) {
		// event.preventDefault();
		if ( event.target.matches( '[data-event="module-edit"]' ) ) {

		}
	});
 */
	LiveComposer.Builder.PreviewAreaDocument.on('blur', '.dslca-editable-content', function() {
		if ( ! LiveComposer.Builder.Flags.uiHidden && jQuery(this).data('type') == 'simple' ) {
			(0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_3__.editableContentCodeGeneration)( jQuery(this) );
		}
	}).on( 'paste', '.dslca-editable-content:not(.inline-editor)', function(){
		if ( ! LiveComposer.Builder.Flags.uiHidden  && jQuery(this).data('type') == 'simple' ) {
			var dslcRealInput = jQuery(this);

			setTimeout(function(){
				if ( dslcRealInput.data('type') == 'simple' ) {
					dslcRealInput.html( dslcRealInput.text() );
				}
				(0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_3__.editableContentCodeGeneration)( dslcRealInput );
			}, 100);
		}
	}).on('focus', '.dslca-editable-content', function() {
		if ( jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).length > 0 && ! jQuery(this).closest('.dslc-module-front').hasClass('dslca-module-being-edited') ) {
			jQuery(this).trigger('blur');
		}
	}).on('keyup', '.dslca-editable-content', function(){
		if ( jQuery(this).data('type') == 'simple' ){
			jQuery(this).closest('.dslc-module-front').addClass('dslca-module-change-made');
		}
	});
}

/**
 * Hook - On contenteditable focusout.
 */
document.addEventListener('contentEditableFocusOut', function (customEvent) {
	window.dslc_show_publish_button();
});



/**
 * MODULES - Delete a Module
 */
function dslc_module_delete( module ) {

	if ( window.dslcDebug ) console.log( 'dslc_delete_module' );
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.showSection)( '.dslca-modules' );

	(0,animejs__WEBPACK_IMPORTED_MODULE_2__.animate)(module,{
		ease: 'easeOutExpo',
		scale: 0,
		opacity: 0,
		duration: 350,
		delay: 0,
		endDelay: 0,
		complete: function(anim) {
			// Remove module, regenerate code, show publish button
			module.parentNode.removeChild( module );
			window.dslc_generate_code();
			window.dslc_show_publish_button();
			parent.LiveComposer.Builder.Actions.saveState();
		}
	  });
}

const unmarkModulesBeingEdited = () => {
	// Remove being edited class if some module is being edited.
	const elEditing = LiveComposer.Builder.PreviewAreaWindow.document.querySelector('.dslca-module-being-edited');
	if ( null !== elEditing ) {
		elEditing.classList.remove('dslca-module-being-edited');
	}
}

/**
 * Modules - Copy a Module
 */
function moduleDuplicate( module ) {
	if ( window.dslcDebug ) console.log( 'dslc_copy_module' );
	unmarkModulesBeingEdited();

	// Duplicate the module and append it to the same area
	var module_new = module.cloneNode(true);

	jQuery( module_new ).insertAfter( module ).css({
        '-webkit-animation-name' : 'none',
        '-moz-animation-name' : 'none',
        'animation-name' : 'none',
        'animation-duration' : '0',
        '-webkit-animation-duration' : '0',
        opacity : 0,
        top: -50
    }).addClass('dslca-module-being-edited');

	// Generate new ID for the new module and change it in HTML/CSS of the module.
	getNewModuleId( module_new );

	// Module fully cloned. Finish the process.
	// Need to call this function to update last column class for the modules.
	window.dslc_generate_code();

	// Fade in the module
	(0,animejs__WEBPACK_IMPORTED_MODULE_2__.animate)(module_new,{
		ease: 'easeOutExpo',
		// scale: 0,
		top: 0,
		opacity: 1,
		duration: 400,
		delay: 0,
		endDelay: 0,
		complete: function(anim) {
			module_new.classList.remove( 'dslca-module-being-edited' );
		}
	});

	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();
}

/**
 * Generate new ID for the module provided
 *
 * Search/Replace old module ID with new one in HTML/CSS of the module.
 *
 * @param DOM module Module that needs ID updated (new ID).
 * @return void
 */
const getNewModuleId = ( moduleEl ) => {

	// Vars
	var dslc_module_id = LiveComposer.Utils.get_unique_id(); // Generate new module ID.
	var dslc_module_id_original = moduleEl.getAttribute( 'id' ); // Original Module ID.

	// Update module ID in data attribute
	moduleEl.setAttribute( 'data-module-id', dslc_module_id );
	// Update module ID in id attribute of element
	moduleEl.setAttribute( 'id', 'dslc-module-' + dslc_module_id );

	/**
	 * Search/Replace module id in the inline CSS
	 */
	var inline_css_el = moduleEl.getElementsByTagName( 'style' )[0];
	var inline_css_code = inline_css_el.textContent;
	// Update id attribute for <style> element with new value
	inline_css_el.setAttribute( 'id', '#css-for-dslc-module-' + dslc_module_id );
	// Search/Replace all occurrences of module ID in inline CSS
	inline_css_code = inline_css_code.split( dslc_module_id_original ).join( 'dslc-module-' + dslc_module_id );
	// Put CSS code back into <style> element
	inline_css_el.textContent = inline_css_code;

	// Update module ID in raw base64 code (dslc_code) of the module
	LiveComposer.Utils.update_module_property_raw( moduleEl, 'module_instance_id', dslc_module_id );
}

/**
 * MODULES - Set Width
 */
function dslc_module_width_set( moduleEl, new_width ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_width_set' );

	// Generate new column class
	var newClass = 'dslc-' + new_width + '-col';

	// Add new column class and change size "data"
	jQuery( moduleEl )
		.removeClass('dslc-1-col dslc-2-col dslc-3-col dslc-4-col dslc-5-col dslc-6-col dslc-7-col dslc-8-col dslc-9-col dslc-10-col dslc-11-col dslc-12-col')
		.addClass(newClass)
		.data('dslc-module-size', new_width);
		//.addClass('dslca-module-being-edited'); – Deprecated

	// Change module size in element attribute
	moduleEl.setAttribute('data-dslc-module-size',new_width);

	// Update module size in raw base64 code (dslc_code) of the module
	LiveComposer.Utils.update_module_property_raw( moduleEl, 'dslc_m_size', new_width );

	LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

	window.dslc_generate_code();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();
}

/**
 * MODULES - Show module options
 */
window.dslc_module_options_show = function( moduleID ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_show' );

	if ( undefined === moduleID ) {
		console.warn( 'No module ID defined in dslc_module_options_show function.' )
	}

	// Vars
	var dslcModule = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument),
	dslcModuleOptions = jQuery( '.dslca-module-options-front textarea', dslcModule ),
	dslcDefaultSection = jQuery('.dslca-header').data('default-section'),
	pseudoPanel = jQuery(jQuery('#pseudo-panel').html());

	jQuery(".dslca-module-edit-options-inner").html("");
	jQuery(".dslca-module-edit-options-tabs").html("");
	jQuery(".dslca-header .dslca-options-filter-hook").show();
	jQuery(".lc_popupContent .dslca-header").after(pseudoPanel.html());


	jQuery("#wpwrap").append(pseudoPanel);

	// Settings array for the Ajax call
	var dslcSettings = {};
	dslcSettings['action'] = 'dslc-ajax-display-module-options';
	dslcSettings['_wpnonce'] = DSLCAjax._wpnonce;
	dslcSettings['dslc'] = 'active';
	dslcSettings['dslc_module_id'] = moduleID;
	dslcSettings['dslc_post_id'] = jQuery('.dslca-container').data('data-post-id');
	dslcSettings.dslc_url_vars = LiveComposer.Utils.get_page_params();

	// Go through each option to fill dslcSettings array
	// with current module setting values
	dslcModuleOptions.each(function(){

		// Vars
		var dslcOption = jQuery(this),
		dslcOptionID = dslcOption.data('id'),
		dslcOptionValue = dslcOption.val();

		if ( dslcOptionValue.includes( '%' ) ) {
			// Restore shortcodes.
			dslcOptionValue = dslcOptionValue.replace(/%\(\(%/g, '[');
			dslcOptionValue = dslcOptionValue.replace(/%\)\)%/g, ']');
			dslcOptionValue = dslcOptionValue.replace(/%\(%/g, '[');
			dslcOptionValue = dslcOptionValue.replace(/%\)%/g, ']');
			dslcOptionValue = dslcOptionValue.replace(/%\{%/g, '[');
			dslcOptionValue = dslcOptionValue.replace(/%\}%/g, ']');
		}

		// Add option ID and value to the settings array
		dslcSettings[dslcOptionID] = dslcOptionValue;
	});

	// Hide the save/cancel actions for text editor and show notification
	jQuery('.dslca-wp-editor-actions').hide();
	jQuery('.dslca-wp-editor-notification').show();

	// Hide the publish button
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.hidePublishButton)();

	// LiveComposer.Builder.UI.initInlineEditors();

	// Set up backup
	var moduleBackup = jQuery('.dslca-module-options-front', dslcModule).children().clone();
	LiveComposer.Builder.moduleBackup = moduleBackup;

	LiveComposer.Builder.Flags.panelOpened = true;

	// Show pseudo settings panel
	jQuery("#lc_popup").show();
	pseudoPanel.show();
	pseudoPanel.addClass('show');

	// AJAX call to get options HTML
	jQuery.post(
		DSLCAjax.ajaxurl,
		dslcSettings,
		function( response ) {

			// Hide pseudo panel
			jQuery(".lc_popupContent .dslca-header").next('.dslca-pseudo-popup-body').remove();
			pseudoPanel.remove();

			// Show edit section
			(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.showSection)('.dslca-module-edit');

			// Add the options
			if ( ! jQuery('body').hasClass('rtl') ) {

				jQuery('.dslca-module-edit-options-inner').html( response.output );
			} else {

				jQuery('.dslca-module-edit-options-inner').html( response.output );
			}

			jQuery('.dslca-module-edit-options-tabs').html( response.output_tabs );


			var sectionsUsed = []; // – Array with tab ids to show for current module.

			/**
			 * Go through each option and check its tab property.
			 * Fill sectionsUsed array with ids of the tabs to display.
			 * We don't want to display tabs with no options inside.
			 */
			jQuery('.dslca-module-edit-options-inner .dslca-module-edit-option').each(function(){
				var currentOptionSection = jQuery(this).data('section');

				// Check if this section is in the list of tabs to show.
				if ( sectionsUsed.indexOf(currentOptionSection) == -1 ) {
					sectionsUsed.push(currentOptionSection);
				}
			});

			var tabs_total = sectionsUsed.length;

			for (var i = 0; i < tabs_total; i++) {
				// Show the tabs used by the current module.
				jQuery('.dslca-header .dslca-options-filter-hook[data-section="' + sectionsUsed[i] + '"]').show();
			}

			// Show the filter hooks
			// jQuery('.dslca-header .dslca-options-filter-hook').show();

			// Trigger click on first filter hook
			if ( jQuery('.dslca-module-edit-option[data-section="' + dslcDefaultSection + '"]').length ) {
				jQuery('.dslca-header .dslca-options-filter-hook[data-section="' + dslcDefaultSection + '"]').show();
				jQuery('.dslca-header .dslca-options-filter-hook[data-section="' + dslcDefaultSection + '"]').trigger('click');
			} else {
				jQuery('.dslca-header .dslca-options-filter-hook:first').hide();
				jQuery('.dslca-header .dslca-options-filter-hook:first').next('.dslca-options-filter-hook').trigger('click');
			}

			// Show the save/cancel actions
			jQuery('.dslca-module-edit-actions').show();

			// Show the save/cancel actions for text editor and hide notification
			jQuery('.dslca-wp-editor-notification').hide();
			jQuery('.dslca-wp-editor-actions').show();

			// Hide the section hooks
			// jQuery('.dslca-header .dslca-go-to-section-hook').hide();

			// Hide the row save/cancel actions
			jQuery('.dslca-row-edit-actions').hide();

			LiveComposer.Builder.UI.loadOptionsDeps();
		}
	).done(function() {
		// Attach evenets to the Font family selection fields.
		window.dslc_module_options_font();
	});
}

/**
 * MODULES - Module output default settings
 */
const moduleOutputDefault = ( dslc_module_id, callback ) => {

	if ( window.dslcDebug ) console.log( 'moduleOutputDefault' );

	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-add-module',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_module_id : dslc_module_id, // ex. DSLC_Button
			dslc_post_id : jQuery('.dslca-container').data('post-id'),
			dslc_url_vars: LiveComposer.Utils.get_page_params(),
			dslc_new_module: true
		},
		function( response ) {
			callback(response);
		}
	);
}

/**
 * MODULES - Redraw module output when settings altered
 */
const moduleOutputAltered = ( callback ) => {

	if ( window.dslcDebug ) console.log( 'moduleOutputAltered' );
	callback = typeof callback !== 'undefined' ? callback : false;

	var dslcModule = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument),
	dslc_module_id = dslcModule.data('module'),
	dslcModuleOptions = jQuery( '.dslca-module-options-front textarea', dslcModule ),
	dslcModuleInstanceID = dslcModule.data('module-id');

	/**
	 * Generate code
	 */

	var dslcSettings = {};

	dslcSettings['action'] = 'dslc-ajax-add-module';
	dslcSettings['_wpnonce'] = DSLCAjax._wpnonce;
	dslcSettings['dslc'] = 'active';
	dslcSettings['dslc_module_id'] = dslc_module_id;
	dslcSettings['dslc_module_instance_id'] = dslcModuleInstanceID;
	dslcSettings['dslc_post_id'] = jQuery('.dslca-container').data('post-id');

	if ( dslcModule.hasClass('dslca-preload-preset') )
		dslcSettings['dslc_preload_preset'] = 'enabled';
	else
		dslcSettings['dslc_preload_preset'] = 'disabled';

	dslcModule.removeClass('dslca-preload-preset');

	dslcModuleOptions.each(function(){

		var dslcOption = jQuery(this);
		var dslcOptionID = dslcOption.data('id');
		var dslcOptionValue = dslcOption.val();

		dslcSettings[dslcOptionID] = dslcOptionValue;

	});

	dslcSettings.dslc_url_vars = LiveComposer.Utils.get_page_params();

	/**
	 * Call AJAX for preview
	 */
	jQuery.post(

		DSLCAjax.ajaxurl, dslcSettings,
		function( response ) {

			var newModule = LiveComposer.
								Builder.
								Helpers.
								insertModule( response.output, dslcModule );

			newModule.addClass('dslca-module-being-edited');

			response = null;
			newModule = null;

			// TODO: Add new postponed action to run after all done

			// window.dslc_show_publish_button();
			LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();

			LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

			LiveComposer.Builder.PreviewAreaWindow.dslc_tabs();
			LiveComposer.Builder.PreviewAreaWindow.dslc_init_accordion();


			/**
			 * Create Custom Event/Hook
			 *
			 * Third-party developers should use it like this:
			 * window.addEventListener('moduleOutputAltered', function (e) {
			 * 	....
			 * }, false);
			 */
			var event = new Event('moduleOutputAltered');
			// Dispatch the event.
			LiveComposer.Builder.PreviewAreaWindow.dispatchEvent(event);

			if ( callback ) {
				callback( response );
			}
		}
	);
}

/**
 * MODULES - Reload a specific module
 */
window.dslc_module_output_reload = function ( dslcModule, callback ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_output_reload' );
	callback = typeof callback !== 'undefined' ? callback : false;

	var dslc_module_id = dslcModule.data('module'),
	dslcModuleOptions = jQuery( '.dslca-module-options-front textarea', dslcModule ),
	dslcModuleInstanceID = dslcModule.data('module-id');

	/**
	 * Generate code
	 */

	var dslcSettings = {};

	dslcSettings['action'] = 'dslc-ajax-add-module';
	dslcSettings['_wpnonce'] = DSLCAjax._wpnonce;
	dslcSettings['dslc'] = 'active';
	dslcSettings['dslc_module_id'] = dslc_module_id;
	dslcSettings['dslc_module_instance_id'] = dslcModuleInstanceID;
	dslcSettings['dslc_post_id'] = jQuery('.dslca-container').data('post-id');
	dslcSettings['dslc_preload_preset'] = 'enabled';
	dslcModule.removeClass('dslca-preload-preset');

	dslcModuleOptions.each(function(){

		var dslcOption = jQuery(this);
		var dslcOptionID = dslcOption.data('id');
		var dslcOptionValue = dslcOption.val();

		dslcSettings[dslcOptionID] = dslcOptionValue;

	});

	/**
	 * Loader
	 */

	dslcModule.append('<div class="dslca-module-reloading"><span class="dslca-icon dslc-icon-spin dslc-icon-refresh"></span></div>');

	/**
	 * Call AJAX for preview
	 */
	jQuery.post(

		DSLCAjax.ajaxurl, dslcSettings,
		function( response ) {

			dslcModule.after(response.output).next().addClass('dslca-module-being-edited');
			dslcModule.remove();
			window.dslc_generate_code();
			window.dslc_show_publish_button();

			LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();
			LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

			LiveComposer.Builder.PreviewAreaWindow.dslc_tabs();
			LiveComposer.Builder.PreviewAreaWindow.dslc_init_accordion();

			if ( callback ) {

				callback( response );
			}

			jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');
		}
	);
}

/**
 * Other - Get Alter Module Defaults Code
 */
function dslc_dm_get_defaults( module ) {

	if ( window.dslcDebug ) console.log( 'dslc_dm_get_defaults' );

	// The module code value
	// var optionsCode = module.find('.dslca-module-code').val(); – Don't use. Causes bugs!
	var optionsCode = module.find('.dslca-module-code').innerText;

	// Ajax call to get the plain PHP code
	jQuery.post(
		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-dm-module-defaults',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_modules_options : optionsCode
		},
		function( response ) {

			// Apply the plain PHP code to the textarea
			jQuery('.dslca-prompt-modal textarea').val( response.output );
		}
	);
}

/**
 * Deprecated Functions and Fallbacks
 */
function dslc_copy_module( module ) { moduleDuplicate( module ); }
function dslc_display_module_options( moduleID ) { window.dslc_module_options_show( moduleID ); }
function dslc_preview_change( callback ) { moduleOutputAltered( callback ); }
function dslc_reload_module( moduleID, callback ) { window.dslc_module_output_reload( moduleID, callback ); }

const moduleInitJS = () => {
	adjustZindex();
	editableContentTextEvents();
}


/***/ }),

/***/ "./js/src/editor/backend/modulearea.class.js":
/*!***************************************************!*\
  !*** ./js/src/editor/backend/modulearea.class.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModuleArea: () => (/* binding */ ModuleArea)
/* harmony export */ });
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");
/* harmony import */ var _modulearea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modulearea.js */ "./js/src/editor/backend/modulearea.js");
/**
 * DSLC_ModuleArea class
 */



const ModuleArea = function(elem) {

	var self = this;
	this.section = jQuery(elem).closest('.dslc-modules-section');
	this.elem = elem;

	/** Set observer to change elems class */
	// this.observer = new mqMutationObserver(elem, function(){

	// 	var classList = self.elem.classList;

	// 	if (elem.querySelectorAll('.dslc-module-front').length == 0) {

	// 		classList.add('dslc-modules-area-empty');
	// 		classList.remove('dslc-modules-area-not-empty');
	// 	} else {

	// 		classList.remove('dslc-modules-area-empty');
	// 		classList.add('dslc-modules-area-not-empty');
	// 	}
	// }, {childList: true});

	/**
	 * Make MODULES inside the Modules Area draggable/sortable
	 */
	this.sortable = sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(elem, {
		group: 'modules',
		animation: 350,
		handle: '.dslca-move-module-hook',
		draggable: '.dslc-module-front',
		ghostClass: 'dslca-module-ghost',
		chosenClass: 'dslca-module-dragging',
		scroll: true, // or HTMLElement
		scrollSensitivity: 150, // px, how near the mouse must be to an edge to start scrolling.
		scrollSpeed: 15, // px

		setData: function (dataTransfer, dragEl) {

		  dataTransfer.setData( LiveComposer.Utils.msieversion() !== false ? 'Text' : 'text/html', dragEl.innerHTML);
		},

		// dragging started
		onStart: function (evt) {

			evt.oldIndex;  // element index within parent

			jQuery('body').removeClass('dslca-drag-not-in-progress').addClass('dslca-drag-in-progress');
			jQuery('body', LiveComposer.Builder.PreviewAreaWindow.document).removeClass('dslca-drag-not-in-progress').addClass('dslca-drag-in-progress');
		},
		// dragging ended

		onEnd: function (evt) {

			evt.oldIndex;  // element's old index within parent
			evt.newIndex;  // element's new index within parent

			evt.preventDefault();

			window.dslc_generate_code();
			LiveComposer.Builder.UI.stopScroller();
			jQuery('body').removeClass('dslca-drag-in-progress').addClass('dslca-drag-not-in-progress');
			jQuery('body', LiveComposer.Builder.PreviewAreaWindow.document).removeClass('dslca-drag-in-progress').addClass('dslca-drag-not-in-progress');
			parent.LiveComposer.Builder.Actions.saveState();
		},

		// Element is dropped into the list from another list
		onAdd: function (evt) {

			var itemEl = evt.item;  // dragged HTMLElement
			evt.from;  // previous list

			// If container/column/modules area droped.
			if ( jQuery(itemEl).data('id') == 'DSLC_M_A' ) {

				(0,_modulearea_js__WEBPACK_IMPORTED_MODULE_1__.modulesAreaAdd)( jQuery(self.section).find('.dslc-modules-section-wrapper .dslc-modules-section-inner') );
				itemEl.remove();
			}

			// + indexes from onEnd
			// evt.preventDefault();
			// evt.stopPropagation(); return false;
		},

		// Changed sorting within list
		onUpdate: function (evt) {
			var itemEl = evt.item;  // dragged HTMLElement
			// + indexes from onEnd
			// evt.preventDefault();
			// evt.stopPropagation(); return false;

			window.dslc_show_publish_button();
			parent.LiveComposer.Builder.Actions.saveState();
		},

		// Called by any change to the list (add / update / remove)
		onSort: function (evt) {
			// same properties as onUpdate
			// evt.preventDefault();
			// evt.stopPropagation(); return false;

		},

		// Element is removed from the list into another list
		onRemove: function (evt) {
		  // same properties as onUpdate
		},

		// Attempt to drag a filtered element
		onFilter: function (evt) {
			var itemEl = evt.item;  // HTMLElement receiving the `mousedown|tapstart` event.
		},

		// Event when you move an item in the list or between lists
		onMove: function (evt) {
			// Example: http://jsbin.com/tuyafe/1/edit?js,output
			evt.dragged; // dragged HTMLElement
			evt.draggedRect; // TextRectangle {left, top, right и bottom}
			evt.related; // HTMLElement on which have guided
			evt.relatedRect; // TextRectangle
			// return false; — for cancel


			// Add here the function to update underlying class
			if ( jQuery('.dslc-modules-area-empty').find('.dslc-module-front').length > 0 ) {

				jQuery(this).removeClass('dslc-modules-area-empty').addClass('dslc-modules-area-not-empty');

				jQuery('.dslca-no-content:not(:visible)', this).show().css({
					'-webkit-animation-name' : 'dslcBounceIn',
					'-moz-animation-name' : 'dslcBounceIn',
					'animation-name' : 'dslcBounceIn',
					'animation-duration' : '0.6s',
					'-webkit-animation-duration' : '0.6s',
					padding : 0
				}).animate({ padding : '35px 0' }, 300, function(){

				});
			}
		}
	});

	// Mark module area as initialized
	jQuery( elem ).attr('data-jsinit', 'initialized');

	/** Sort option setter */
	jQuery(document).on('LC.sortableOff', function(){

		self.sortable && self.sortable.option && self.sortable.option('disabled', true);
	});

	jQuery(document).on('LC.sortableOn', function(){

		self.sortable && self.sortable.option && self.sortable.option('disabled', false);
	});
}


/***/ }),

/***/ "./js/src/editor/backend/modulearea.js":
/*!*********************************************!*\
  !*** ./js/src/editor/backend/modulearea.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   moduleareasInitJS: () => (/* binding */ moduleareasInitJS),
/* harmony export */   modulesAreaAdd: () => (/* binding */ modulesAreaAdd)
/* harmony export */ });
/* harmony import */ var _dragndrop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragndrop.js */ "./js/src/editor/backend/dragndrop.js");
/* harmony import */ var _sections_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sections.js */ "./js/src/editor/backend/sections.js");
/* harmony import */ var _modulearea_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modulearea.class.js */ "./js/src/editor/backend/modulearea.class.js");
/* harmony import */ var _modalwindow_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modalwindow.class.js */ "./js/src/editor/backend/modalwindow.class.js");
/* harmony import */ var _uigeneral_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uigeneral.js */ "./js/src/editor/backend/uigeneral.js");
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./module.js */ "./js/src/editor/backend/module.js");
/**
 * Functions powering Module Areas functionality
 *
 * = AREAS ( MODULE AREAS ) =
 *
 * - Actions/Events (Duplicate, Change Width, Delete, ...)
 * - dslc_modules_area_add ( Adds a new modules area )
 * - dslc_modules_area_delete ( Deletes modules area )
 * - dslc_modules_area_width_set ( Sets specific width to the modules area )
 * - dslc_copy_modules_area ( Copies modules area )
 *
 */









/**
 * Module Area Actions (Duplicate, Change Width, Delete, ...)
 *
 * Attach these actions once the editing iFrame loaded.
 */

jQuery(document).on('editorFrameLoaded', function(){

	function init_sortables() {

		var el = jQuery('.dslc-modules-area', LiveComposer.Builder.PreviewAreaDocument); // Groups that can hold modules

		jQuery(el).each(function (i,e) {

			new _modulearea_class_js__WEBPACK_IMPORTED_MODULE_2__.ModuleArea(e);
		});
	}


	var actionAvail = function() {

		if ( LiveComposer.Builder.Flags.panelOpened ) {

			LiveComposer.Builder.UI.shakePanelConfirmButton();
			return false;
		}

		return true;
	}

	/**
	 * Action - Automatically Add a Row if Empty
	 */
	if ( ! jQuery( '#dslc-main .dslc-modules-section', LiveComposer.Builder.PreviewAreaDocument).length && ! jQuery( '#dslca-tut-page', LiveComposer.Builder.PreviewAreaDocument).length ) {

		(0,_sections_js__WEBPACK_IMPORTED_MODULE_1__.addSection)( init_sortables() );
		parent.LiveComposer.Builder.Actions.saveState();
	} else {

		init_sortables();
	}

	/**
	 * Hook - Copy Module Area
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-copy-modules-area-hook', function(e){

		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			var modulesArea = jQuery(this).closest('.dslc-modules-area');
			dslc_copy_modules_area( modulesArea );
		}
	});

	/**
	 * Hook - Delete Module Area
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-delete-modules-area-hook', function(e){

		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			// Check if current modules area is empty.
			var modulesAreaEmpty = jQuery(this).closest('.dslc-modules-area').hasClass('dslc-modules-area-empty');

			if ( ! modulesAreaEmpty ) {

				var self = jQuery(this);

				(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_3__.CModalWindow)({

					title: DSLCString.str_del_area_title,
					content: DSLCString.str_del_area_descr,
					confirm: function() {

						var modulesArea = self.closest('.dslc-modules-area');
						dslc_modules_area_delete( modulesArea );
					}
				});

				// Show confirmation modal only if the module area isn't empty.
				/*dslc_js_confirm( 'delete_modules_area', '<span class="dslca-prompt-modal-title">' + DSLCString.str_del_area_title +
					'</span><span class="dslca-prompt-modal-descr">' + DSLCString.str_del_area_descr + '</span>', jQuery(this) );*/
			} else {

				var modulesArea = jQuery(this).closest('.dslc-modules-area');
				// Delete module area without asking anything.
				dslc_delete_modules_area( modulesArea );
			}
		}
	});

	/**
	 * Hook - Set Width of the Module Area
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-change-width-modules-area-options span', function(){
		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {
			var moduleAreaJQ = jQuery(this).closest('.dslc-modules-area');
			var oldSize = moduleAreaJQ.data('size');
			var newSize = jQuery(this).data('size');

			// Start expensive function only if the value changed.
			if (  Number(oldSize) !== Number(newSize) ) {
				dslc_modules_area_width_set( moduleAreaJQ, newSize );
			}
		}
	});

	/**
	 * Hook - Set Vertical Align of the Module Area
	 */
	 LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-change-vertial-align-module-area-hook span', function(){
		var moduleAreaJQ = jQuery(this).closest('.dslc-modules-area');
		var newSetting = jQuery(this).data('valign');
		dslc_modules_area_vertical_align_set( moduleAreaJQ, newSetting );
	});

	/**
	* AREAS - Set Width
	*/
	function dslc_modules_area_vertical_align_set( areaJQ, newSetting ) {
		if ( window.dslcDebug ) console.log( 'dslc_modules_area_vertical_align_set' );

		// Generate new class based on align option.
		var newClass = 'dslc-valign-' + newSetting;

		// Remove previously set align classes,
		// add new class and set the data-valign attr for storing data.
		areaJQ
			.removeClass('dslc-valign-top dslc-valign-middle dslc-valign-bottom')
			.addClass(newClass)
			.data('valign', newSetting);

		// Call other functions
		LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

		if ( LiveComposer.Builder.Flags.panelOpened ) {
			return false;
		}

		window.dslc_generate_code();
		window.dslc_show_publish_button();
		parent.LiveComposer.Builder.Actions.saveState();
	}

	/**
	 * Action - Show/Hide Width Options Popup for the Module Area
	 */
	/* LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-change-width-modules-area-hook', function(e){

		e.preventDefault();

		// Check if action can be fired
		if ( ! actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			// Is visible
			if ( jQuery('.dslca-change-width-modules-area-options:visible', this).length ) {

				// Hide
				jQuery('.dslca-change-width-modules-area-options', this).hide();

			// Is hidden
			} else {

				// Show
				jQuery('.dslca-change-width-modules-area-options', this).show();
			}
		}
	}); */
/* 
	LiveComposer.Builder.PreviewAreaDocument.on( 'mouseleave', '.dslca-change-width-modules-area-options', function(e){

		// Hide width seleciton panel.
		jQuery(this).hide();
	});
 */
	/**
	 * Hook - Add Modules Area
	 * TODO: Where we use it? Delete maybe?
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-add-modules-area-hook', function(e){
		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		modulesAreaAdd( jQuery(this).closest('.dslc-modules-section').find('.dslc-modules-section-inner') );
	});

});

/**
 * AREAS - Add New
 */

// ex. dslc_modules_area_add
const modulesAreaAdd = ( row ) => {

	if ( window.dslcDebug ) console.log( 'modulesAreaAdd' );

	// Add class to body so we know it's in progress
	// jQuery('body', LiveComposer.Builder.PreviewAreaDocument).addClass('dslca-anim-in-progress');

	const uiIconsUrl = window.DSLCSiteData.editorUrl + 'css/icons';
	var output = `<div class="dslc-modules-area dslc-col dslc-12-col dslc-modules-area-dnd dslc-modules-area-empty dslc-last-col" data-size="12">
		<div class="dslca-modules-area-manage">
			<span class="dslca-modules-area-manage-line"></span>
			<div class="dslca-modules-area-manage-inner">
				<span class="dslca-manage-action dslca-copy-modules-area-hook" title="Duplicate">
					<svg class="feather">
						<use xlink:href="` + uiIconsUrl +`/feather-sprite.svg#copy"></use>
					</svg>
				</span>
				<span class="dslca-manage-action dslca-move-modules-area-hook" title="Drag to move">
					<svg class="feather">
						<use xlink:href="` + uiIconsUrl +`/feather-sprite.svg#move"></use>
					</svg>
				</span>
				<span class="dslca-manage-action dslca-change-width-modules-area-hook" title="Change width">
					<svg class="feather">
						<use xlink:href="` + uiIconsUrl +`/feather-sprite.svg#columns"></use>
					</svg>
					<div class="dslca-change-width-modules-area-options">
                        <span>Container Width</span>
                        <span data-size="1"><small class="lc_content_width_ratio">1/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/first-column.webp" alt="Preview" /></span>
                        <span data-size="2"><small class="lc_content_width_ratio">2/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/second-column.webp" alt="Preview" /></span>
                        <span data-size="3"><small class="lc_content_width_ratio">3/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/third-column.webp" alt="Preview" /></span>
                        <span data-size="4"><small class="lc_content_width_ratio">4/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/fourth-column.webp" alt="Preview" /></span>
                        <span data-size="5"><small class="lc_content_width_ratio">5/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/fifth-column.webp" alt="Preview" /></span>
                        <span data-size="6"><small class="lc_content_width_ratio">6/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/sixth-column.webp" alt="Preview" /></span>
                        <span data-size="7"><small class="lc_content_width_ratio">7/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/seventh-column.webp" alt="Preview" /></span>
                        <span data-size="8"><small class="lc_content_width_ratio">8/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/eighth-column.webp" alt="Preview" /></span>
                        <span data-size="9"><small class="lc_content_width_ratio">9/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/ninth-column.webp" alt="Preview" /></span>
                        <span data-size="10"><small class="lc_content_width_ratio">10/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/tenth-column.webp" alt="Preview" /></span>
                        <span data-size="11"><small class="lc_content_width_ratio">11/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/eleventh-column.webp" alt="Preview" /></span>
                        <span data-size="12"><small class="lc_content_width_ratio">12/12</small><img class="previewimg" src="`+ window.DSLCSiteData.editorUrl +`/images/icons/twelfth-column.webp" alt="Preview" /></span>
                    </div>
				</span>
				<span class="dslca-manage-action dslca-change-vertial-align-module-area-hook" title="Change vertical align" >
					<svg class="feather">
						<use xlink:href="` + uiIconsUrl +`/feather-sprite.svg#git-commit"/>
					</svg>
					<div class="dslca-change-vertial-align-module-area-options">
						<span>Vertical Align</span>
						<span data-valign="top" class="dslc-popup-option">⬆️ Top</span>
						<span data-valign="middle" class="dslc-popup-option">↕️ Middle</span>
						<span data-valign="bottom" class="dslc-popup-option">⬇️ Bottom</span>
					</div>
				</span>
				<span class="dslca-manage-action dslca-delete-modules-area-hook" title="Delete">
					<svg class="feather">
						<use xlink:href="` + uiIconsUrl +`/feather-sprite.svg#x"></use>
					</svg>
				</span>
			</div>
		</div>
		<!-- .dslc-module -->
	</div>`;

	// Append new area and animate
	jQuery( output ).appendTo( row ).css({ height : 0 }).animate({
		height : 99
	}, 300, function(){
		jQuery(this).css({ height : 'auto' });
	}).addClass('dslca-init-animation');


	// Re-initialize all the empty areas on the page
	var emptyModuleAreas = jQuery('.dslc-modules-area-empty', LiveComposer.Builder.PreviewAreaDocument);

	jQuery(emptyModuleAreas).each(function (i,e) {
		new _modulearea_class_js__WEBPACK_IMPORTED_MODULE_2__.ModuleArea(e);
	});

	// Call other functions
	(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_0__.dragAndDropInit)();
	window.dslc_generate_code();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();
	// Remove class from body so we know it's done
	// jQuery('body', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-anim-in-progress');
}

/**
 * AREAS - Delete
 */

function dslc_modules_area_delete( area ) {

	if ( window.dslcDebug ) console.log( 'dslc_delete_modules_area' );

	// Vars
	var modulesSection = area.closest('.dslc-modules-section').find('.dslc-modules-section-inner'),
	dslcDeleteSectionToo = false;

	// Add a class to the area so we know it's being deleted
	area.addClass('dslca-modules-area-being-deleted');

	// If it's the last area in the row delete section as well
	if ( modulesSection.find('.dslc-modules-area').length < 2 ) {
		dslcDeleteSectionToo = true;
	}

	// If a module in the area is being edited
	if ( area.find('.dslca-module-being-edited').length ) {

		// Hide the filter hooks
		jQuery('.dslca-header .dslca-options-filter-hook', LiveComposer.Builder.PreviewAreaDocument).hide();

		// Hide the save/cancel actions
		jQuery('.dslca-module-edit-actions', LiveComposer.Builder.PreviewAreaDocument).hide();

		// Show the section hooks
		jQuery('.dslca-header .dslca-go-to-section-hook', LiveComposer.Builder.PreviewAreaDocument).show();

		// Show the modules listing
		(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_4__.showSection)('.dslca-modules');

	}

	// Set a timeout so we handle deletion after animation ends
	setTimeout( function(){

		// Delete section if no more module areas inside.
		if ( dslcDeleteSectionToo ) {

			var parentSectionContainer = area.closest('.dslc-modules-section-inner');
			// modulesAreaAdd( modulesSection );

			// Don't delete latest module area in the latest section on the page
			if (2 <= area.closest('#dslc-main').find('.dslc-modules-section').length ) {

				dslc_row_delete( area.closest('.dslc-modules-section') );
			} else {

				// Remove the area
				area.remove();
				// Create new empty area in current module section
				modulesAreaAdd( modulesSection );
			}
		}

		// Remove the area
		area.remove();

		// Call other functions
		window.dslc_generate_code();
		window.dslc_show_publish_button();
		parent.LiveComposer.Builder.Actions.saveState();
	}, 900 );

	// Animation
	area.css({
		'-webkit-animation-name' : 'dslcBounceOut',
		'-moz-animation-name' : 'dslcBounceOut',
		'animation-name' : 'dslcBounceOut',
		'animation-duration' : '0.6s',
		'-webkit-animation-duration' : '0.6s',
		'overflow' : 'hidden'
	}).animate({
		opacity : 0
	}, 600).animate({
		height : 0,
		marginBottom : 0
	}, 300, function(){
		area.remove();
		window.dslc_generate_code();
		window.dslc_show_publish_button();
		parent.LiveComposer.Builder.Actions.saveState();
	});
}

/**
 * AREAS - Copy
 */

function dslc_modules_area_copy( area ) {

	if ( window.dslcDebug ) console.log( 'dslc_copy_modules_area' );

	// Vars
	var dslc_moduleID,
	modulesSection = area.closest('.dslc-modules-section').find('.dslc-modules-section-inner');

	// Copy the area and append to the row
	var dslc_modulesAreaCloned = area.clone().appendTo(modulesSection);

	new _modulearea_class_js__WEBPACK_IMPORTED_MODULE_2__.ModuleArea(dslc_modulesAreaCloned[0]);

	// Trigger mouseleave ( so the actions that show on hover go away )
	dslc_modulesAreaCloned.find('.dslca-modules-area-manage').trigger('mouseleave');

	// Apply correct data size and get rid of animations
	dslc_modulesAreaCloned.data('size', area.data('size') ).find('.dslc-module-front').css({
		'-webkit-animation-name' : 'none',
		'-moz-animation-name' : 'none',
		'animation-name' : 'none',
		'animation-duration' : '0',
		'-webkit-animation-duration' : '0',
		opacity : 0

	// Go through each module in the area
	}).each(function(){

		var dslc_module = jQuery(this);

		//Generate new ID for the new module and change it in HTML/CSS of the module.
		(0,_module_js__WEBPACK_IMPORTED_MODULE_5__.getNewModuleId)( dslc_module[0] );

		// Remove "dslca-module-being-edited" class form any element
		jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');

		// Need to call this function to update last column class for the modules.
		window.dslc_generate_code();

		// Show back new created module
		dslc_module.animate({
			opacity : 1
		}, 300);

	});

	// Call other functions
	(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_0__.dragAndDropInit)();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();

	// Need to call this function to update last column class for the module areas.
	window.dslc_generate_code();

}

/**
 * AREAS - Set Width
 */
function dslc_modules_area_width_set( area, newWidth ) {

	if ( window.dslcDebug ) console.log( 'dslc_modules_area_width_set' );

	// Generate new class based on width
	var newClass = 'dslc-' + newWidth + '-col';

	// Remove width classes, add new width class and set the data-size attr
	area
		.removeClass('dslc-1-col dslc-2-col dslc-3-col dslc-4-col dslc-5-col dslc-6-col dslc-7-col dslc-8-col dslc-9-col dslc-10-col dslc-11-col dslc-12-col')
		.addClass(newClass)
		.data('size', newWidth);

	// Call other functions
	LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

	if ( LiveComposer.Builder.Flags.panelOpened ) {
		return false;
	}

	window.dslc_generate_code();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();

}

/**
 * Check Module Areas initialization
 *
 * @return void
 */
const moduleareasInitJS = () => {

	// Select all the module areas form the main section of the page
	jQuery( '#dslc-main .dslc-modules-area', LiveComposer.Builder.PreviewAreaDocument ).each( function() {

		// Check if all the module areas have data attribute 'jsinit' set to 'initialized'?
		if ( jQuery( this ).data('jsinit') !== 'initialized' ) {

			// Initialize all the module areas without 'jsinit' attribute!
			new _modulearea_class_js__WEBPACK_IMPORTED_MODULE_2__.ModuleArea( this );
		}
	} );

}

/**
 * Deprecated Functions and Fallbacks
 */
function dslc_delete_modules_area( area ) { dslc_modules_area_delete( area ); }
function dslc_copy_modules_area( area ) { dslc_modules_area_copy( area ); }


/***/ }),

/***/ "./js/src/editor/backend/popup-drag-resize.js":
/*!****************************************************!*\
  !*** ./js/src/editor/backend/popup-drag-resize.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makePopupDraggableAndResizable: () => (/* binding */ makePopupDraggableAndResizable)
/* harmony export */ });
/*********************************
 *
 * = UI - POPUP MANIPULATION =
 *
 * - makePopupDraggableAndResizable ( Applies boundary-constrained drag and eight-way resize functionality to popups: #lc_popup and #lc_popup2 )
 *
 ***********************************/

// --- CONSTANTS ---
const VISIBLE_HEADER_WIDTH = 50; 
const MIN_WIDTH = 300;
const MIN_HEIGHT = 200;
// const dragOverlay = document.getElementById("dslc-drag-overlay");

/**
 * Applies drag and resize functionality to a given popup element.
 * * @param {string} popupId - The ID of the popup element (e.g., 'lc_popup').
 * @param {string} headerId - The ID of the header element (e.g., 'lc_popupHeader').
 * @param {HTMLElement} [closeBtn=null] - Optional reference to the close button (for drag exclusion).
 */
function makePopupDraggableAndResizable(popupId, headerId, dragOverlay, closeBtn = null) {
    const popup = document.getElementById(popupId);
    const header = document.getElementById(headerId);

    if (!popup || !header) {
        console.warn(`Live Composer Popup: Could not find elements for ID: ${popupId}`);
        return;
    }

    // --- STATE VARIABLES ---
    let offsetX = 0,
        offsetY = 0,
        isDown = false;
    let isResizing = false;
    let resizeDirection = null;

    // --- DRAG INITIATION ---
    header.addEventListener("mousedown", (e) => {
        if (closeBtn && (e.target === closeBtn || closeBtn.contains(e.target))) {
            return; 
        }
        e.preventDefault();
        isDown = true;
        dragOverlay.style.display = 'block';

        offsetX = e.clientX - popup.offsetLeft;
        offsetY = e.clientY - popup.offsetTop;

        document.body.style.userSelect = 'none';
        popup.style.position = 'absolute';
    });

    // --- RESIZE INITIATION (Scoped to this specific popup) ---
    popup.querySelectorAll('.resize-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation(); 
            
            isResizing = true;
            resizeDirection = e.target.getAttribute('data-direction');
            dragOverlay.style.display = 'block'; 
            document.body.style.userSelect = 'none';
            
            // Store initial state
            offsetX = e.clientX;
            offsetY = e.clientY;
            
            popup.initialWidth = popup.offsetWidth;
            popup.initialHeight = popup.offsetHeight;
            popup.initialLeft = popup.offsetLeft;
            popup.initialTop = popup.offsetTop;
        });
    });

    // --- GLOBAL MOUSE UP & MOUSE MOVE Handlers ---
    // Note: To avoid issues with multiple instances, these global listeners
    // should ideally be managed by a controller, but keeping them here
    // means they handle the state for whichever popup initiated the action.

    document.addEventListener("mouseup", () => {
        if (isDown || isResizing) {
            dragOverlay.style.display = 'none'; 
        }
        isDown = false;
        isResizing = false;
        resizeDirection = null;
        document.body.style.userSelect = 'auto';
    });

    document.addEventListener("mousemove", (e) => {
        // Only run if this specific instance is currently active (isDown or isResizing)
        if (isDown && !isResizing) { 
            // --- DRAG LOGIC ---
            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;

            // ... (Drag constraint logic remains the same) ...
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const popupWidth = popup.offsetWidth;
            
            const minX = -(popupWidth - VISIBLE_HEADER_WIDTH);
            const maxX = viewportWidth - VISIBLE_HEADER_WIDTH; 
            const minY = 0;
            const maxY = viewportHeight - header.offsetHeight; 

            newX = Math.max(minX, Math.min(maxX, newX));
            newY = Math.max(minY, Math.min(maxY, newY));
            
            popup.style.left = newX + "px";
            popup.style.top = newY + "px";

        } else if (isResizing && resizeDirection) {
            // --- RESIZE LOGIC ---
            // ... (Resize calculation logic remains the same) ...
            const dx = e.clientX - offsetX;
            const dy = e.clientY - offsetY;
            
            let newWidth = popup.initialWidth;
            let newHeight = popup.initialHeight;
            let newLeft = popup.initialLeft;
            let newTop = popup.initialTop;

            const direction = resizeDirection;

            // Vertical Resizing
            if (direction.includes('t')) { 
                newHeight = popup.initialHeight - dy;
                newTop = popup.initialTop + dy;
                if (newHeight < MIN_HEIGHT) {
                    newHeight = MIN_HEIGHT;
                    newTop = popup.initialTop + popup.initialHeight - MIN_HEIGHT; 
                }
            } else if (direction.includes('b')) { 
                newHeight = Math.max(MIN_HEIGHT, popup.initialHeight + dy);
            }

            // Horizontal Resizing
            if (direction.includes('l')) { 
                newWidth = popup.initialWidth - dx;
                newLeft = popup.initialLeft + dx;
                if (newWidth < MIN_WIDTH) {
                    newWidth = MIN_WIDTH;
                    newLeft = popup.initialLeft + popup.initialWidth - MIN_WIDTH;
                }
            } else if (direction.includes('r')) { 
                newWidth = Math.max(MIN_WIDTH, popup.initialWidth + dx);
            }

            // Apply Changes
            popup.style.width = newWidth + 'px';
            popup.style.height = newHeight + 'px';
            popup.style.left = newLeft + 'px';
            popup.style.top = newTop + 'px';
        }
    });
}

/***/ }),

/***/ "./js/src/editor/backend/presets.js":
/*!******************************************!*\
  !*** ./js/src/editor/backend/presets.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   presetsInit: () => (/* binding */ presetsInit),
/* harmony export */   updatePreset: () => (/* binding */ updatePreset)
/* harmony export */ });
/*********************************
*
* = MODULE PRESETS =
*
* - dslc_update_preset ( Update Styling Preset )
*
***********************************/



/**
 * Module Presets - Update
 */
const updatePreset = () => {
	if ( window.dslcDebug ) console.log( 'updatePreset' );
	// Vars
	var module = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument),
	presetName = module.find('.dslca-module-option-front[data-id="css_load_preset"]').val(),
	// presetCode = module.find('.dslca-module-code').val(), - don't use. Creating bugs.
	presetCode = module.find('.dslca-module-code').innerText,
	moduleID = module.data('module');

	// If preset value not "none"
	if ( 'none' !== presetName && '' !== presetName ) {

		// AJAX Call to Save Preset
		jQuery.post(

			DSLCAjax.ajaxurl,
			{
				action : 'dslc-ajax-save-preset',
				_wpnonce : DSLCAjax._wpnonce,
				dslc_preset_name : presetName,
				dslc_preset_code : presetCode,
				dslc_module_id : moduleID
			},
			function( response ) {

				if ( response.preset_setting == 'enabled' ) {

					// Reload all modules with the same preset
					jQuery('.dslc-module-front:not(#' + module.attr('id') + ')[data-module="' + module.data('module') +
						'"][data-dslc-preset="' + module.data('dslc-preset') + '"]', LiveComposer.Builder.PreviewAreaDocument ).each(function(){
						window.dslc_module_output_reload( jQuery(this) );
					});
				}
			}
		);
	}
}

/**
 * Module Presets - Document Ready
 */
jQuery(document).ready(function($){

	/**
	 * Action - Save preset
	 */

	jQuery(document).on( 'keypress', '.dslca-module-edit-field[name="css_save_preset"]', function(e){

		// Enter Key Pressed
		if ( e.which == 13 ) {

			// Vars
			var presetName = jQuery(this).val(),
			presetID = presetName.toLowerCase().replace(/\s/g, '-');

			// Add class to body that a new preset is added
			jQuery('body').addClass('dslca-new-preset-added');

			// Append the new preset to the "Load Preset" option and trigger change
			jQuery('.dslca-module-edit-field[name="css_load_preset"]').append('<option value="' + presetID + '">' + presetID + '</option>').val( presetID ).trigger('change');

			// Erase value from the "Save Preset" option
			jQuery(this).val('');

			jQuery('.dslc-delete-preset').removeClass('dslc-delete-preset-hide');
		}
	});

	/**
	 * Action - Preset value changed
	 */

	jQuery(document).on( 'change', '.dslca-module-edit-field[name="css_load_preset"]', function(e){
		jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).addClass('dslca-preload-preset');
	});

	/**
	 * Action - Delete Preset
	 */

	jQuery(document).on( 'click', '.dslc-delete-preset', function(e){

		// Vars
		var module = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument),
		presetName = module.find('.dslca-module-option-front[data-id="css_load_preset"]').val(),
		moduleID = module.data('module');

		// If preset value not "none"
		if ( 'none' !== presetName && '' !== presetName ) {

			// AJAX Call to Save Preset
			jQuery.post(

				DSLCAjax.ajaxurl,
				{
					action : 'dslc-ajax-delete-preset',
					_wpnonce : DSLCAjax._wpnonce,
					dslc_preset_name : presetName,
					dslc_module_id : moduleID
				},
				function( response ) {

					window.dslc_module_options_show(moduleID);
					parent.LiveComposer.Builder.Actions.saveState();
				}
			);
		}
	});
});


const presetsInit = () => {

}


/***/ }),

/***/ "./js/src/editor/backend/scroller.js":
/*!*******************************************!*\
  !*** ./js/src/editor/backend/scroller.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initPreviewAreaScroller: () => (/* binding */ initPreviewAreaScroller)
/* harmony export */ });
 
/*********************************
 *
 * = UI - SCROLLER =
 *
 ***********************************/

/** Scroll preview area when mouse are on some distant of edge */
const initPreviewAreaScroller = () => {

	var pxInTik = 5;
	var timerTik = 6;
	LiveComposer.Builder.Flags.windowScroller = false;

	/** Stop scroll if within areas */
	jQuery(LiveComposer.Builder.PreviewAreaDocument).on('dragleave','.lc-scroll-top-area, .lc-scroll-bottom-area', function(e) {

		LiveComposer.Builder.UI.stopScroller();
	});

	/** Scroll bottom */
	jQuery(LiveComposer.Builder.PreviewAreaDocument).on('dragenter dragover','.lc-scroll-bottom-area', function(e) {

		if( LiveComposer.Builder.Flags.windowScroller !== false ) return false;

		LiveComposer.Utils.publish('LC.sortableOff', {});

		LiveComposer.Builder.Flags.windowScroller = setInterval(function(){

			LiveComposer.Builder.PreviewAreaWindow.scrollBy(0 , pxInTik);
		}, timerTik);
	});

	/** Scroll top */
	jQuery(LiveComposer.Builder.PreviewAreaDocument).on('dragenter','.lc-scroll-top-area', function(e) {

		if( LiveComposer.Builder.Flags.windowScroller !== false ) return false;

		LiveComposer.Utils.publish('LC.sortableOff', {});

		LiveComposer.Builder.Flags.windowScroller = setInterval(function(){

			LiveComposer.Builder.PreviewAreaWindow.scrollBy(0 , -pxInTik);
		}, timerTik);
	});

	/** Stop scroll if click or drag ended */
	jQuery(LiveComposer.Builder.PreviewAreaDocument).on('dragend mouseup', 'body', function(e) {

		LiveComposer.Builder.Flags.windowScroller && LiveComposer.Builder.UI.stopScroller();
	});
};

/** Window Y-scroller */
jQuery(document).ready(function($){

	initPreviewAreaScroller();
	/**
	 * Stops scroller function
	 */
	LiveComposer.Builder.UI.stopScroller = function() {

		LiveComposer.Utils.publish('LC.sortableOn', {});

		clearInterval(LiveComposer.Builder.Flags.windowScroller);
		LiveComposer.Builder.Flags.windowScroller = false;
	}

	jQuery("#scroller-stopper").on('dragover', function(){

		LiveComposer.Builder.UI.stopScroller();
	});
});

/***/ }),

/***/ "./js/src/editor/backend/section.class.js":
/*!************************************************!*\
  !*** ./js/src/editor/backend/section.class.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Section: () => (/* binding */ Section)
/* harmony export */ });
/* harmony import */ var _modulearea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modulearea.js */ "./js/src/editor/backend/modulearea.js");
/**
 * Builder section class
 */


const Section = class{

	constructor (elem) {
		this.sortable;
		this.sortableContainer = jQuery( elem ).find('.dslc-modules-section-wrapper .dslc-modules-section-inner').eq(0)[0];

		this.initSortable(elem);
		this.initDropable(elem);
		this.reactToSortableOnOff();

		// Mark section as initialized
		jQuery( elem ).attr('data-jsinit', 'initialized');
	}



	initDropable(elem) {
		jQuery( elem ).droppable({
			drop: function( event, ui ) {
				var modulesSection = jQuery(this).find('.dslc-modules-section-inner');
				var moduleID = ui.draggable.data( 'id' );
				if ( moduleID == 'DSLC_M_A' ) {
					(0,_modulearea_js__WEBPACK_IMPORTED_MODULE_0__.modulesAreaAdd)( modulesSection );
				}
			}
		});
	}

	initSortable(elem) {

		this.sortable = jQuery( this.sortableContainer ).sortable({
			connectWith: '.dslc-modules-section-inner',
			items: ".dslc-modules-area-dnd",
			handle: '.dslca-move-modules-area-hook:not(".dslca-action-disabled")',
			placeholder: 'dslca-modules-area-placeholder',
			cursorAt: { top: 0, left: 0 },
			tolerance : 'intersect',
			scroll: true,
			scrollSensitivity: 100,
			scrollSpeed : 15,
			sort: function() {
				jQuery( this ).removeClass( "ui-state-default" );
			},
			over: function (e, ui) {
				var dslcSection = ui.placeholder.closest('.dslc-modules-section');

				jQuery(dslcSection).removeClass('dslc-modules-section-empty').addClass('dslc-modules-section-not-empty');

				dslcSection.siblings('.dslc-modules-section').each( function(){
					if ( jQuery('.dslc-modules-area:not(.ui-sortable-helper)', jQuery(this)).length ) {
						jQuery(this).removeClass('dslc-modules-section-empty').addClass('dslc-modules-section-not-empty');
					} else {
						jQuery(this).removeClass('dslc-modules-section-not-empty').addClass('dslc-modules-section-empty');
					}
				});
			},
			remove: function() {
				( jQuery( self.elem ).find('.dslc-modules-area').length == 0 ) && (0,_modulearea_js__WEBPACK_IMPORTED_MODULE_0__.modulesAreaAdd)( jQuery( this.sortableContainer ) );
			},
			update: function (e, ui) {
				window.dslc_generate_code();
				window.dslc_show_publish_button();
				parent.LiveComposer.Builder.Actions.saveState();
			},
			start: function(e, ui){

				// Placeholder
				ui.placeholder.html('<span class="dslca-placeholder-help-text"><span class="dslca-placeholder-help-text-inner">' + DSLCString.str_area_helper_text + '</span></span>');
				if ( ! jQuery(ui.item).hasClass('dslc-12-col') ) {
					ui.placeholder.width(ui.item.width() - 10)
				} else {
					ui.placeholder.width(ui.item.width()).css({ margin : 0 });
				}

				// Add drag in progress class
				jQuery('body').removeClass('dslca-drag-not-in-progress').addClass('dslca-drag-in-progress dslca-modules-area-drag-in-progress');

				// Refresh positions
				jQuery( '.dslc-modules-section-inner' ).sortable( "refreshPositions" );

			},
			stop: function(e, ui){

				LiveComposer.Builder.UI.stopScroller();
				jQuery('body').removeClass('dslca-drag-in-progress dslca-modules-area-drag-in-progress').addClass('dslca-drag-not-in-progress');
				jQuery('.dslca-anim-opacity-drop').removeClass('dslca-anim-opacity-drop');
			},
			change: function( e, ui ) {

			}
		});

	}

	reactToSortableOnOff() {
		self = this.sortable;

		/** Sort option setter */
		jQuery(document).on('LC.sortableOff', function(){
			/* if ( undefined !== self.sortable( "instance" ) ) {
				self.sortable('option','disabled', true);
			} */
		});

		jQuery(document).on('LC.sortableOn', function(){
			/* if ( undefined !== self.sortable( "instance" ) ) {
				self.sortable('option','disabled', false);
			} */
		});
	}
}


/***/ }),

/***/ "./js/src/editor/backend/sections.js":
/*!*******************************************!*\
  !*** ./js/src/editor/backend/sections.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addSection: () => (/* binding */ addSection),
/* harmony export */   sectionsInit: () => (/* binding */ sectionsInit),
/* harmony export */   sectionsInitJS: () => (/* binding */ sectionsInitJS)
/* harmony export */ });
/* harmony import */ var _section_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./section.class.js */ "./js/src/editor/backend/section.class.js");
/* harmony import */ var _dragndrop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dragndrop.js */ "./js/src/editor/backend/dragndrop.js");
/* harmony import */ var _modulearea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modulearea.js */ "./js/src/editor/backend/modulearea.js");
/* harmony import */ var _modulearea_class_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modulearea.class.js */ "./js/src/editor/backend/modulearea.class.js");
/* harmony import */ var _modalwindow_class_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modalwindow.class.js */ "./js/src/editor/backend/modalwindow.class.js");
/* harmony import */ var _uigeneral_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./uigeneral.js */ "./js/src/editor/backend/uigeneral.js");
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./module.js */ "./js/src/editor/backend/module.js");
/* harmony import */ var _codegeneration_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./codegeneration.js */ "./js/src/editor/backend/codegeneration.js");
/* harmony import */ var _modalwindow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modalwindow.js */ "./js/src/editor/backend/modalwindow.js");
/*********************************
 *
 * = ROWS =
 *
 * - dslc_row_add ( Add New )
 * - dslc_row_delete ( Delete )
 * - dslc_row_edit ( Edit )
 * - dslc_row_edit_slider_init ( Edit - Initiate Slider )
 * - dslc_row_edit_cancel ( Edit - Cancel Changes )
 * - dslc_row_edit_confirm ( Edit - Confirm Changes )
 * - dslc_row_copy ( Copy )
 * - dslc_row_import ( Import )
 *
 ***********************************/













const sectionsEventsInit = () => {
	var $ = jQuery;

	var actionAvail = function() {

		if ( LiveComposer.Builder.Flags.panelOpened ) {

			LiveComposer.Builder.UI.shakePanelConfirmButton();
			return false;
		}

		return true;
	}

	jQuery(".dslc-modules-section", LiveComposer.Builder.PreviewAreaDocument).each(function(){
		new _section_class_js__WEBPACK_IMPORTED_MODULE_0__.Section(this);
	});

	/**
	 * Hook - Delete Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-delete-modules-section-hook', function(e){

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		e.preventDefault();
		var self = this;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_4__.CModalWindow)({
				title: DSLCString.str_del_row_title,
				content: DSLCString.str_del_row_descr,
				confirm: function() {

					dslc_row_delete( jQuery(self).closest('.dslc-modules-section') );
				}
			})

		/*	dslc_js_confirm( 'delete_modules_section', '<span class="dslca-prompt-modal-title">' + DSLCString.str_del_row_title +
				'</span><span class="dslca-prompt-modal-descr">' + DSLCString.str_del_row_descr + '</span>', jQuery(this) );*/
		}
	});

	/**
	 * Hook - Import Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-import-modules-section-hook', function(e) {

		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_4__.CModalWindow)({
				title: DSLCString.str_import_row_title,
				content: DSLCString.str_import_row_descr + '<br><br><textarea></textarea>',
				confirm: function(){
					dslc_row_import( jQuery('.dslca-prompt-modal textarea').val() );
					jQuery('.dslca-prompt-modal-confirm-hook span').css({ opacity : 0 });
					jQuery('.dslca-prompt-modal-confirm-hook .dslca-loading').show();
				},
				confirm_title: DSLCString.str_import
			});

			/*jQuery('.dslca-prompt-modal-confirm-hook').html('<span class="dslc-icon dslc-icon-ok"></span><span>' + DSLCString.str_import +
				'</span><div class="dslca-loading followingBallsGWrap"><div class="followingBallsG_1 followingBallsG"></div>'+
				'<div class="followingBallsG_2 followingBallsG"></div><div class="followingBallsG_3 followingBallsG"></div><div class="followingBallsG_4 followingBallsG"></div></div>');

			dslc_js_confirm( 'import_modules_section', '<span class="dslca-prompt-modal-title">' + DSLCString.str_import_row_title +
				'</span><span class="dslca-prompt-modal-descr">' + DSLCString.str_import_row_descr + ' <br><br><textarea></textarea></span>', jQuery(this) );*/
		}
	});

	/**
	 * Hook - Export Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-export-modules-section-hook', function(e) {
		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {
			jQuery('.dslca-prompt-modal-cancel-hook').hide();
			jQuery('.dslca-prompt-modal-confirm-hook').html('<span class="dslc-icon dslc-icon-ok"></span>' + DSLCString.str_ok);

			(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_4__.CModalWindow)({
				title: DSLCString.str_export_row_title,
				content: DSLCString.str_export_row_descr + '<br><br><textarea>' + '[' + (0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_7__.generateSectionCode)( jQuery(this).closest('.dslc-modules-section') ) + ']' + '</textarea></span>'
			});

			// dslc_js_confirm( 'export_modules_section', '<span class="dslca-prompt-modal-title">' + DSLCString.str_export_row_title +
			// 	'</span><span class="dslca-prompt-modal-descr">' + DSLCString.str_export_row_descr + ' <br><br><textarea></textarea></span>', jQuery(this) );
			// jQuery('.dslca-prompt-modal textarea').val( dslc_generate_section_code( jQuery(this).closest('.dslc-modules-section') ) );
		}
	});

	/**
	 * Hook - Copy Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-copy-modules-section-hook', function() {

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			dslc_row_copy( jQuery(this).closest('.dslc-modules-section') );
		}
	});

	/**
	 * Hook - Add Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-add-modules-section-hook', function(e){

		e.preventDefault();

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		var button = jQuery(this);

		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			// Add a loading animation
			button.find('.dslca-icon').removeClass('dslc-icon-align-justify').addClass('dslc-icon-spinner dslc-icon-spin');

			// Add a row
			addSection( function(){
				button.find('.dslca-icon').removeClass('dslc-icon-spinner dslc-icon-spin').addClass('dslc-icon-align-justify');
			});
		}
	});

	/**
	 * Hook - Edit Row
	 */
	LiveComposer.Builder.PreviewAreaDocument.on( 'click', '.dslca-edit-modules-section-hook', function(){

		// Check if action can be fired
		if ( !actionAvail() ) return false;

		var self = this;

		var module_edited = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).length;
		var row_edited = jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).length;

		/// If settings panel opened - finish func
		if ( LiveComposer.Builder.Flags.uiHidden || module_edited > 0 || row_edited > 0 ) return false;

		// If not disabled ( disabling used for tutorial )
		if ( ! jQuery(this).hasClass('dslca-action-disabled') ) {

			// Trigger the function to edit
			dslc_row_edit( jQuery(this).closest('.dslc-modules-section') );
		}

		jQuery('body', LiveComposer.Builder.PreviewAreaDocument).addClass('section-editing-in-progress');
	});
}

/**
 * Row - Add New
 */
const addSection = ( callback ) => {

	if ( window.dslcDebug ) console.log( 'dslc_row_add' );

	callback = typeof callback !== 'undefined' ? callback : false;

	var defer = jQuery.Deferred();
	var browserCacheTmp = sessionStorage;

	var newRow = jQuery();
	var cachedAjaxRequest = browserCacheTmp.getItem( 'cache-dslc-ajax-add-modules-section-v2' );

	// If option 'lc_section_padding_vertical' was update.
	if ( null !== cachedAjaxRequest ) {
		var current_value, cache_curent_value;

		current_value = DSLCMainOptions.section_padding_vertical;
		cache_curent_value = jQuery(cachedAjaxRequest).find('input[data-id="padding"]').val();

		if ( current_value !== cache_curent_value ) {
			browserCacheTmp.removeItem('cache-dslc-ajax-add-modules-section-v2');
			cachedAjaxRequest = null;
		}
	}

	// If no cache for current Ajax request.
	if ( null === cachedAjaxRequest ) {

		// AJAX Request
		jQuery.post(

			DSLCAjax.ajaxurl,
			{
				action : 'dslc-ajax-add-modules-section',
				_wpnonce : DSLCAjax._wpnonce,
				dslc : 'active'
			},
			function( response ) {

				// newRow = jQuery(response.output);
				browserCacheTmp.setItem( 'cache-dslc-ajax-add-modules-section-v2', response.output );

				newRow = dslc_row_after_add( response.output );

				if ( callback ) { callback(); }
				return defer;
			}
		);

	} else {
		// There is cached version of AJAX request.
		// newRow = jQuery(cachedAjaxRequest);

		newRow = dslc_row_after_add( cachedAjaxRequest );

		if ( callback ) { callback(); }
		return defer;
	}
}

/**
 * Finish new row creation process.
 *
 * @param  {String} newRowHTML HTML code of the new row.
 * @return {jQuery}            New ROW jQuery object.
 */
function dslc_row_after_add( newRowHTML ) {

	var newRow = jQuery(newRowHTML);

	// Append new row
	newRow.appendTo(LiveComposer.Builder.PreviewAreaDocument.find("#dslc-main"));

	// Call other functions
	(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_1__.dragAndDropInit)();
	window.dslc_generate_code();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();

	new _section_class_js__WEBPACK_IMPORTED_MODULE_0__.Section(newRow);
	new _modulearea_class_js__WEBPACK_IMPORTED_MODULE_3__.ModuleArea( newRow.find('.dslc-modules-area').eq(0)[0] );

	newRow.find('.dslc-modules-area').addClass('dslc-modules-area-empty dslc-last-col');

	return newRow;
}

/**
 * Row - Delete
 */
function dslc_row_delete( row ) {

	if ( window.dslcDebug ) console.log( 'dslc_row_delete' );

	// If the row is being edited
	if ( row.find('.dslca-module-being-edited') ) {

		// Hide the filter hooks
		jQuery('.dslca-header .dslca-options-filter-hook').hide();

		// Hide the save/cancel actions
		jQuery('.dslca-module-edit-actions').hide();

		// Show the section hooks
		jQuery('.dslca-header .dslca-go-to-section-hook').show();

		(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_5__.showSection)('.dslca-modules');

	}

	// Remove row
	row.trigger('mouseleave').remove();

	// Call other functions
	window.dslc_generate_code();
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState(); 
}

/**
 * Row - Edit
 */
function dslc_row_edit( row ) {

	if ( window.dslcDebug ) console.log( 'dslc_row_edit' );

	// Vars we will use
	var dslcModulesSectionOpts, dslcVal;

	// Set editing class
	jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');
	jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-modules-section-being-edited').removeClass('dslca-modules-section-change-made');
	row.addClass('dslca-modules-section-being-edited');

	// Hide the section hooks
	jQuery('.dslca-header .dslca-go-to-section-hook').hide();

	// Show the styling/responsive tabs
	jQuery('.dslca-row-options-filter-hook[data-section="styling"], .dslca-row-options-filter-hook[data-section="responsive"]').show();
	jQuery('.dslca-row-options-filter-hook[data-section="styling"]').trigger('click');

	// Hide the filter hooks
	jQuery('.dslca-header .dslca-options-filter-hook').hide();

	// Hide the save/cancel actions
	jQuery('.dslca-module-edit-actions').hide();

	// Show the save/cancel actions
	jQuery('.dslca-row-edit-actions').show();

	// Set current values
	jQuery('.dslca-modules-section-edit-field').each(function(){


		/**
		 * Temporary migration from 'wrapped' value to 'wrapper' in ROW type selector
		 * TODO: delete this block in a few versions as problem do not exists on new installs
		 *
		 * @since ver 1.1
		 */
		if ( 'type' === jQuery(this).data('id') ) {

			if ( '' === jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="type"]', LiveComposer.Builder.PreviewAreaDocument).val() ||
				  'wrapper' === jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="type"]', LiveComposer.Builder.PreviewAreaDocument).val() ||
				  'wrapped' === jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="type"]', LiveComposer.Builder.PreviewAreaDocument).val() ) {
				jQuery('select[data-id="type"]').val('wrapper').change();
				jQuery(this).parent().siblings('div[data-id="css_module_section_width_unit"]').show();
				jQuery(this).parent().siblings('div[data-id="css_module_section_width"]').show();
				jQuery(this).parent().siblings('div[data-id="css_module_section_width"]').children('input[data-id="css_module_section_width"]').val(jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="css_module_section_width"]', LiveComposer.Builder.PreviewAreaDocument).data('def')).trigger('change');
			}
			else{
				jQuery(this).parent().siblings('div[data-id="css_module_section_width_unit"]').hide();
				jQuery(this).parent().siblings('div[data-id="css_module_section_width"]').hide();
			}
		}
		if (jQuery(this).data('id') == 'css_module_section_width_unit') {
			let width_unit = jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="css_module_section_width_unit"]', LiveComposer.Builder.PreviewAreaDocument).val();
			let targetEle = jQuery('.dslca-modules-section-edit-option[data-id="css_module_section_width"] input[data-id="css_module_section_width"]');
			
			let html_min = '';
			let html_max = '';
			
			if (width_unit == '%') {
				html_min = -100;
				html_max = 100;
			} else {
				html_min = targetEle.data('min');
				html_max = targetEle.data('max');
			}
			targetEle.attr('data-ext', width_unit).attr('min', html_min).attr('max', html_max);			
		}
		if (jQuery(this).data('id') == 'css_margin_unit') {
			let width_unit = jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="css_margin_unit"]', LiveComposer.Builder.PreviewAreaDocument).val();
			let targetEle = jQuery('.dslca-modules-section-edit-option[data-id^="css_margin_"] input[data-id^="css_margin_"]');
			
			let html_min = '';
			let html_max = '';
			
			if (width_unit == '%') {
				html_min = -100;
				html_max = 100;
			} else {
				html_min = targetEle.data('min');
				html_max = targetEle.data('max');
			}
			targetEle.attr('data-ext', width_unit).attr('min', html_min).attr('max', html_max);			
		}
		if (jQuery(this).data('id') == 'css_padding_unit') {
			let width_unit = jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="css_padding_unit"]', LiveComposer.Builder.PreviewAreaDocument).val();
			let targetEle = jQuery('.dslca-modules-section-edit-option[data-id^="css_padding_"] input[data-id^="css_padding_"]');
			
			let html_min = '';
			let html_max = '';
			
			if (width_unit == '%') {
				html_min = -100;
				html_max = 100;
			} else {
				html_min = targetEle.data('min');
				html_max = targetEle.data('max');
			}
			targetEle.attr('data-ext', width_unit).attr('min', html_min).attr('max', html_max);			
		}

		if ( jQuery(this).data('id') == 'border-top' ) {

			if ( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="border"]', LiveComposer.Builder.PreviewAreaDocument).val().indexOf('top') >= 0 ) {
				jQuery(this).prop('checked', true);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
			} else {
				jQuery(this).prop('checked', false);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
			}

		} else if ( jQuery(this).data('id') == 'border-right' ) {

			if ( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="border"]', LiveComposer.Builder.PreviewAreaDocument).val().indexOf('right') >= 0 ) {
				jQuery(this).prop('checked', true);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
			} else {
				jQuery(this).prop('checked', false);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
			}

		} else if ( jQuery(this).data('id') == 'border-bottom' ) {

			if ( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="border"]', LiveComposer.Builder.PreviewAreaDocument).val().indexOf('bottom') >= 0 ) {
				jQuery(this).prop('checked', true);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
			} else {
				jQuery(this).prop('checked', false);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
			}

		} else if ( jQuery(this).data('id') == 'border-left' ) {

			if ( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="border"]', LiveComposer.Builder.PreviewAreaDocument).val().indexOf('left') >= 0 ) {
				jQuery(this).prop('checked', true);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
			} else {
				jQuery(this).prop('checked', false);
				jQuery(this).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
			}
		} else if ( jQuery(this).hasClass('dslca-modules-section-edit-field-checkbox') ) {

			if ( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="' + jQuery(this).data('id') + '"]', LiveComposer.Builder.PreviewAreaDocument).val().indexOf( jQuery(this).data('val') ) >= 0 ) {
				jQuery( this ).prop('checked', true);
				jQuery( this ).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
			} else {
				jQuery( this ).prop('checked', false);
				jQuery( this ).siblings('.dslca-modules-section-edit-option-checkbox-hook').find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
			}
		} else {

			jQuery( this ).val( jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input[data-id="' + jQuery( this ).data('id') + '"]', LiveComposer.Builder.PreviewAreaDocument ).val().trim().replace('%(%', '[').replace('%)%', ']') );

			if ( jQuery( this ).hasClass( 'dslca-modules-section-edit-field-colorpicker' ) ) {

				var _this = jQuery( this );
				jQuery( this ).closest( '.dslca-modules-section-edit-option' )
						.find( '.sp-preview-inner' )
						.removeClass('sp-clear-display')
						.css({ 'background-color' : _this.val() });

				jQuery( this ).css({ 'background-color' : _this.val() });
			}
		}
	});

	jQuery('.dslca-modules-section-edit-field-upload').each(function(){

		var dslcParent = jQuery(this).closest('.dslca-modules-section-edit-option');

		if ( jQuery(this).val() && jQuery(this).val() !== 'disabled' ) {

			jQuery('.dslca-modules-section-edit-field-image-add-hook', dslcParent ).hide();
			jQuery('.dslca-modules-section-edit-field-image-remove-hook', dslcParent ).show();
		} else {

			jQuery('.dslca-modules-section-edit-field-image-remove-hook', dslcParent ).hide();
			jQuery('.dslca-modules-section-edit-field-image-add-hook', dslcParent ).show();
		}
	});

	// Initiate numeric option sliders
	// dslc_row_edit_slider_init();

	// Show options management
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_5__.showSection)('.dslca-modules-section-edit');

	LiveComposer.Builder.Flags.panelOpened = true;

	// Hide the publish button
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_5__.hidePublishButton)();
}

/**
 * Row - Edit - Cancel Changes
 */
function dslc_row_edit_cancel( callback ) {

	if ( window.dslcDebug ) console.log( 'dslc_row_cancel_changes' );

	callback = typeof callback !== 'undefined' ? callback : false;

	// Time to generate code optimized {HACK}
	LiveComposer.Builder.Flags.generate_code_after_row_changed = false;

	// Recover original data from data-def attribute for each control
	jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input', LiveComposer.Builder.PreviewAreaDocument).each(function(){

		jQuery(this).val( jQuery(this).data('def') );

		// Fire change for every ROW control, so it redraw linked CSS properties
		jQuery('.dslca-modules-section-edit-field[data-id="' + jQuery(this).data('id') + '"]').val( jQuery(this).data('def') ).trigger('change');
	});

	LiveComposer.Builder.Flags.generate_code_after_row_changed = true;
	window.dslc_generate_code();
	window.dslc_show_publish_button();

	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_5__.showSection)('.dslca-modules');

	// Hide the save/cancel actions
	jQuery('.dslca-row-edit-actions').hide();

	// Hide the styling/responsive tabs
	jQuery('.dslca-row-options-filter-hook').hide();

	// Show the section hooks
	jQuery('.dslca-header .dslca-go-to-section-hook').show();

	// Show the publish button
	dslc_show_publish_button;

	// Remove being edited class
	jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-modules-section-being-edited dslca-modules-section-change-made');

	if ( callback ) { callback(); }

	LiveComposer.Builder.Flags.panelOpened = false;
	jQuery("body", LiveComposer.Builder.PreviewAreaDocument).removeClass('section-editing-in-progress');

}

/**
 * Row - Edit - Confirm Changes
 */
function dslc_row_edit_confirm( callback ) {

	if ( window.dslcDebug ) console.log( 'dslc_confirm_row_changes' );

	callback = typeof callback !== 'undefined' ? callback : false;

	jQuery('.dslca-modules-section-being-edited .dslca-modules-section-settings input', LiveComposer.Builder.PreviewAreaDocument).each(function(){

		jQuery(this).data( 'def', jQuery(this).val() );
	});

	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_5__.showSection)('.dslca-modules');

	// Hide the save/cancel actions
	jQuery('.dslca-row-edit-actions').hide();

	// Hide the styling/responsive tabs
	jQuery('.dslca-row-options-filter-hook').hide();

	// Show the section hooks
	jQuery('.dslca-header .dslca-go-to-section-hook').show();

	// Remove being edited class
	jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-modules-section-being-edited dslca-modules-section-change-made');

	window.dslc_generate_code();

	// Show the publish button
	window.dslc_show_publish_button();
	parent.LiveComposer.Builder.Actions.saveState();

	if ( callback ) { callback(); }

	LiveComposer.Builder.Flags.panelOpened = false;
	jQuery("body", LiveComposer.Builder.PreviewAreaDocument).removeClass('section-editing-in-progress');
}

/**
 * Row - Copy
 */
function dslc_row_copy( row ) {

	if ( window.dslcDebug ) console.log( 'dslc_row_copy' );

	// Vars that will be used
	var dslc_module_id,
	dslcModulesSectionCloned,
	dslcModule;

	// Clone the row and insert it immediately AFTER the original 'row' element.
    dslcModulesSectionCloned = row.clone().insertAfter(row); 

	// Mark new ROW as NON initialized
	dslcModulesSectionCloned[0].removeAttribute('data-jsinit');

	// Go through each area of the new row and apply correct data-size
	// Mark each module area inside as NON initialized (2)
	dslcModulesSectionCloned.find('.dslc-modules-area').each(function(){
		var dslcIndex = jQuery(this).index();
		jQuery(this).data('size', row.find('.dslc-modules-area:eq( ' + dslcIndex + ' )').data('size') );

		this.removeAttribute('data-jsinit'); // (2)
	});

	new _section_class_js__WEBPACK_IMPORTED_MODULE_0__.Section(dslcModulesSectionCloned);

	/**
	 * Re-render modules inside of the new ROW
	 */

	// Remove animations and temporary hide modules inside
	dslcModulesSectionCloned.find('.dslc-module-front').css({
		'-webkit-animation-name' : 'none',
		'-moz-animation-name' : 'none',
		'animation-name' : 'none',
		'animation-duration' : '0',
		'-webkit-animation-duration' : '0',
		opacity : 0

	// Go through each module inside the new ROW
	}).each(function(){

		// Current module
		var dslc_module = jQuery(this);

		//Generate new ID for the new module and change it in HTML/CSS of the module.
		(0,_module_js__WEBPACK_IMPORTED_MODULE_6__.getNewModuleId)( dslc_module[0] );

		// Check init for rows and module areas
		sectionsInitJS();
		(0,_modulearea_js__WEBPACK_IMPORTED_MODULE_2__.moduleareasInitJS)();

		// TODO: the next function contains AJAX call. It needs optimization.
		window.dslc_generate_code();

		/**
		 * Re-init drag and drop from modules list into modules areas.
		 * Need this function, so we can drop new modules on the cloned areas.
		 */
		(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_1__.dragAndDropInit)();

		// Remove "dslca-module-being-edited" class form any element
		jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');

		// Show back new created module
		dslc_module.animate({
			opacity : 1
		}, 300);

		window.dslc_show_publish_button();
	});
	
	// Generate new ID for the new section.
	dslc_section_new_id( dslcModulesSectionCloned[0] );
	parent.LiveComposer.Builder.Actions.saveState();
}

/**
 * Generate new ID for the section provided
 *
 *
 * @param DOM section that needs ID updated (new ID).
 * @return void
 */
function dslc_section_new_id( section ) {

	if ( window.dslcDebug ) console.log( 'dslc_section_new_id' );

	var dslc_section_id = LiveComposer.Utils.get_unique_id(); // Generate new section ID.

	// Update section ID in data attribute
	section.setAttribute( 'data-section-id', dslc_section_id );

	// Update section ID in raw base64 code (dslc_code) of the section
	LiveComposer.Utils.update_section_property_raw( section, 'section_instance_id', dslc_section_id );
}


/**
 * Row - Import
 */
function dslc_row_import( rowCode ) {

	if ( window.dslcDebug ) console.log( 'dslc_row_import' );

	// AJAX Call
	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-import-modules-section',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_modules_section_code : rowCode
		},
		function( response ) {

			// Close the import popup/modal
			(0,_modalwindow_js__WEBPACK_IMPORTED_MODULE_8__.confirmClose)();

			// Add the new section
			jQuery('#dslc-main', LiveComposer.Builder.PreviewAreaDocument).append( response.output );

			// Call other functions
			LiveComposer.Builder.PreviewAreaWindow.dslc_bg_video();
			LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();
			LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();

			// Check init for rows and module areas
			sectionsInitJS();
			(0,_modulearea_js__WEBPACK_IMPORTED_MODULE_2__.moduleareasInitJS)();

			(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_1__.dragAndDropInit)();
			window.dslc_generate_code();

			window.dslc_show_publish_button();
			parent.LiveComposer.Builder.Actions.saveState();
		}
	);
}

/**
 * Deprecated Functions and Fallbacks
 */

function dslc_add_modules_section() { addSection(); }
function dslc_delete_modules_section( row  ) { dslc_row_delete( row ); }
function dslc_edit_modules_section( row ) { dslc_row_edit( row ); }
function dslc_copy_modules_section( row ) { dslc_row_copy( row ); }
function dslc_import_modules_section( rowCode ) { dslc_row_import( rowCode ); }

/**
 * Check ROWs initialization
 *
 * @return void
 */
const sectionsInitJS = () => {

	// Select all the ROWs form the main section of the page
	jQuery( '#dslc-main .dslc-modules-section', LiveComposer.Builder.PreviewAreaDocument ).each( function() {

		// Check if all the rows have data attribute 'jsinit' set to 'initialized'?
		if ( jQuery( this ).data('jsinit') !== 'initialized' ) {

			// Initialize all the rows without 'jsinit' attribute!
			new _section_class_js__WEBPACK_IMPORTED_MODULE_0__.Section( this );
		}
	} );

}

const sectionsInit = () => {
	sectionsInitJS();
	sectionsEventsInit();

	/**
	 * Hook - Confirm Row Changes
	 */
	jQuery(document).on( 'click', '.dslca-row-edit-save', function(){

		dslc_row_edit_confirm();

		jQuery(".dslca-currently-editing").removeAttr('style');
		jQuery('.dslca-row-options-filter-hook.dslca-active').removeClass('dslca-active');
		LiveComposer.Builder.PreviewAreaWindow.dslc_responsive_classes( true );
	});

	/**
	 * Hook - Cancel Row Changes
	 */
	jQuery(document).on( 'click', '.dslca-row-edit-cancel', function(){

		dslc_row_edit_cancel();

		jQuery(".dslca-currently-editing").removeAttr('style');
		jQuery('.dslca-row-options-filter-hook.dslca-active').removeClass('dslca-active');
		LiveComposer.Builder.PreviewAreaWindow.dslc_responsive_classes( true );
	});
}


/***/ }),

/***/ "./js/src/editor/backend/sectionscontainer.class.js":
/*!**********************************************************!*\
  !*** ./js/src/editor/backend/sectionscontainer.class.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSectionsContainer: () => (/* binding */ CSectionsContainer)
/* harmony export */ });
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");
/**
 * Sections container class
 */



const CSectionsContainer = class{

	constructor (elem) {
		this.sortable;

		this.initSortable(elem);
		this.reactToSortableOnOff();
	}


	initSortable(elem) {
		this.sortable = sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create( elem, {
			group: 'sections',
			animation: 350,
			handle: '.dslca-move-modules-section-hook',
			draggable: '.dslc-modules-section-dnd',
			ghostClass: 'dslca-sections-ghost',
			chosenClass: 'dslca-sections-dragging',
			scroll: true, // or HTMLElement
			scrollSensitivity: 150, // px, how near the mouse must be to an edge to start scrolling.
			scrollSpeed: 10, // px
			bubbleScroll: true, // apply autoscroll to all parent elements, allowing for easier movement
			direction: 'vertical',
			// forceFallback: true, // to make Drag + wheel scroll feature.

			setData: function (dataTransfer, dragEl) {
			  dataTransfer.setData( LiveComposer.Utils.msieversion() !== false ? 'Text' : 'text/html', dragEl.innerHTML);
			},
			// dragging started
			onStart: function (evt) {
				// evt.oldIndex;  // element index within parent
				jQuery('body').removeClass('dslca-drag-not-in-progress').addClass('dslca-drag-in-progress');
				jQuery('body', LiveComposer.Builder.PreviewAreaWindow.document).removeClass('dslca-drag-not-in-progress').addClass('dslca-drag-in-progress');
				// ui.placeholder.html('<span class="dslca-placeholder-help-text"><span class="dslca-placeholder-help-text-inner">' + DSLCString.str_row_helper_text + '</span></span>');
				// jQuery( '.dslc-content' ).sortable( "refreshPositions" );
			},
			// dragging ended
			onEnd: function (evt) {
				evt.oldIndex;  // element's old index within parent
				evt.newIndex;  // element's new index within parent

				evt.preventDefault();

				window.dslc_generate_code();
				LiveComposer.Builder.UI.stopScroller();
				jQuery('body').removeClass('dslca-drag-in-progress').addClass('dslca-drag-not-in-progress');
				jQuery('body', LiveComposer.Builder.PreviewAreaWindow.document).removeClass('dslca-drag-in-progress').addClass('dslca-drag-not-in-progress');

				jQuery('.dslca-anim-opacity-drop').removeClass('dslca-anim-opacity-drop');
			},

			// Element is dropped into the list from another list
			onAdd: function (evt) {

				/* var itemEl = evt.item;  // dragged HTMLElement
				evt.from;  // previous list

				// If container/column/modules area droped.
				if ( jQuery(itemEl).data('id') == 'DSLC_M_A' ) {

					modulesAreaAdd( jQuery(self.section).find('.dslc-modules-section-wrapper .dslc-modules-section-inner') );
					itemEl.remove();
				} */

				// + indexes from onEnd
				// evt.preventDefault();
				// evt.stopPropagation(); return false;
			},

			// Changed sorting within list
			onUpdate: function (evt) {
				var itemEl = evt.item;  // dragged HTMLElement
				// + indexes from onEnd
				// evt.preventDefault();
				// evt.stopPropagation(); return false;

				window.dslc_show_publish_button();
				parent.LiveComposer.Builder.Actions.saveState();
			},

			// Called by any change to the list (add / update / remove)
			onSort: function (evt) {

				jQuery( this ).removeClass( "ui-state-default" );
				// same properties as onUpdate
				// evt.preventDefault();
				// evt.stopPropagation(); return false;

			},

			// Element is removed from the list into another list
			onRemove: function (evt) {
			  // same properties as onUpdate
			},

			// Attempt to drag a filtered element
			onFilter: function (evt) {
				var itemEl = evt.item;  // HTMLElement receiving the `mousedown|tapstart` event.
			},

			// Event when you move an item in the list or between lists
			onMove: function (evt) {
				// Example: http://jsbin.com/tuyafe/1/edit?js,output
				evt.dragged; // dragged HTMLElement
				evt.draggedRect; // TextRectangle {left, top, right и bottom}
				evt.related; // HTMLElement on which have guided
				evt.relatedRect; // TextRectangle
				// return false; — for cancel


				// Add here the function to update underlying class
				/* if ( jQuery('.dslc-modules-area-empty').find('.dslc-module-front').length > 0 ) {

					jQuery(this).removeClass('dslc-modules-area-empty').addClass('dslc-modules-area-not-empty');

					jQuery('.dslca-no-content:not(:visible)', this).show().css({
						'-webkit-animation-name' : 'dslcBounceIn',
						'-moz-animation-name' : 'dslcBounceIn',
						'animation-name' : 'dslcBounceIn',
						'animation-duration' : '0.6s',
						'-webkit-animation-duration' : '0.6s',
						padding : 0
					}).animate({ padding : '35px 0' }, 300, function(){

					});
				} */
			}
		});
	}

	reactToSortableOnOff() {
		self = this.sortable;

		/** Sort option setter */
		/* jQuery(document).on('LC.sortableOff', function(){
			if ( undefined !== self.sortable( "instance" ) ) {
				self.sortable('option','disabled', true);
			}
		});

		jQuery(document).on('LC.sortableOn', function(){
			if ( undefined !== self.sortable( "instance" ) ) {
				self.sortable('option','disabled', false);
			}
		}); */
	}

}

/***/ }),

/***/ "./js/src/editor/backend/settings.panel.js":
/*!*************************************************!*\
  !*** ./js/src/editor/backend/settings.panel.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   elementOptionsTabs: () => (/* binding */ elementOptionsTabs),
/* harmony export */   resetResponsiveOptions: () => (/* binding */ resetResponsiveOptions),
/* harmony export */   settingsPanelInit: () => (/* binding */ settingsPanelInit)
/* harmony export */ });
/* harmony import */ var _uigeneral_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uigeneral.js */ "./js/src/editor/backend/uigeneral.js");
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./module.js */ "./js/src/editor/backend/module.js");
/* harmony import */ var _presets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./presets.js */ "./js/src/editor/backend/presets.js");
/* harmony import */ var _modalwindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modalwindow.js */ "./js/src/editor/backend/modalwindow.js");
/**
 * Builder settings panel functions providing work with modules
 */





var dslcRegularFontsArray = window.DSLCFonts.regular;
var dslcGoogleFontsArray = window.DSLCFonts.google;
var dslcAllFontsArray = dslcRegularFontsArray.concat( dslcGoogleFontsArray );

// Set current/default icons set
var dslcIconsCurrentSet = window.DSLCIcons.fontawesome;

/**
 * Modules - Document Ready
 */

jQuery(document).ready(function($){
	dslc_module_options_tooltip();
	window.dslc_module_options_font();
	dslc_module_options_icon();
	dslc_module_options_icon_returnid()
	dslc_module_options_text_align();
	dslc_module_options_checkbox();
	dslc_module_options_box_shadow();
	dslc_module_options_text_shadow();

	/* Initiate all the color picker controls on the module/section options panel. */
	var dslca_options_with_colorpicker = '';
	dslca_options_with_colorpicker += '.dslca-module-edit-field-colorpicker';
	dslca_options_with_colorpicker += ', .dslca-modules-section-edit-field-colorpicker';
	dslca_options_with_colorpicker += ', .dslca-module-edit-option-box-shadow-color';
	dslca_options_with_colorpicker += ', .dslca-module-edit-option-text-shadow-color';

	// Init color picker on click only to not polute DOM with unwanted elements.
	// It will fire only once (first time) as color picker then put it's own listeners.
	jQuery(document).on('click', dslca_options_with_colorpicker, function() {

		// Call the color picker init function.
		dslc_module_options_color( this );

		// Make sure the color picker popup appears in the right place.
		var wrapper = jQuery( this ).closest('.dslca-color-option');
		var optionsPanel = jQuery( '.dslca-module-edit-options-inner');
		var colorpicker = wrapper.find('.wp-picker-holder');
		var offset = wrapper.offset();
		var offsetPopup = offset.left + 15;
		var windoWidth = window.innerWidth;
		var popupWidth = 260;

		if ( windoWidth < offsetPopup + popupWidth ) {
			offsetPopup = windoWidth - popupWidth;
		}

		// Set the right position for the color picker popup on first click.
		colorpicker.css('left', offsetPopup + 'px' );

		// Update position left for the color picker on options scroll.
		jQuery(optionsPanel).on('scroll', function(event) {
			offset = wrapper.offset();
			var offsetPopup = offset.left + 15;
			var windoWidth = window.innerWidth;
			var popupWidth = 260;

			if ( windoWidth < offsetPopup + popupWidth ) {
				offsetPopup = windoWidth - popupWidth;
			}

			colorpicker.css('left', offsetPopup + 'px' );
		});
	});

	/**
	 * Hook - Submit
	 */
	jQuery('.dslca-module-edit-form').submit( function(e){
		e.preventDefault();
		(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)();
	});

	/**
	 * Hook - Tab Switch
	 */
	jQuery(document).on( 'click', '.dslca-module-edit-options-tab-hook', function(e){
		e.preventDefault();
		elementOptionsTabs( jQuery(this) );
	});

	/**
	 * Hook - Reset Responsive Settings
	 */
	 jQuery(document).on( 'click', '.dslca-clear-responsive-options', function(e){
		e.preventDefault();
		resetResponsiveOptions();
	});

	/**
	 * Hook - Option Section Switch
	 */
	jQuery(document).on( 'click', '.dslca-options-filter-hook', function(e){

		e.preventDefault();

		var dslcPrev = jQuery('.dslca-options-filter-hook.dslca-active').data('section');
		var currentSection = jQuery(this).data('section');

		jQuery('.dslca-options-filter-hook.dslca-active').removeClass('dslca-active');
		jQuery(this).addClass('dslca-active');

		jQuery('.dslca-container-loader')
		document.querySelector( '.dslca-container' ).dataset.currentSection = currentSection;

		dslc_module_options_section_filter( currentSection );

		// If previous was responsive reload module
		if ( dslcPrev == 'responsive' ) {
			// Show the loader
			jQuery('.dslca-container-loader').show();

			// Reset the responsive classes
			window.LiveComposer.Builder.PreviewAreaWindow.dslc_responsive_classes();

			// Reload Module
			(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)(function(){
				// Hide the loader
				jQuery('.dslca-container-loader').hide();
			});

			/**
			 * Destroy resizable preview functionality
			 * when leaving Responsive view.
			 */
			jQuery('#page-builder-preview-area').resizable('destroy').attr('style','');
		}

		/**
		 * Make the preview area resizable
		 * when entering Responsive view.
		 */
		if ( currentSection == 'responsive' ) {
			jQuery('#page-builder-preview-area').resizable();
		}
	});

	/**
	 * Hook - Confirm Changes
	 */
	jQuery(document).on( 'click', '.dslca-module-edit-save', function(e){
		e.preventDefault();

		dslc_module_options_confirm_changes(function(){

			// window.LiveComposer.Builder.UI.initInlineEditors({withRemove:true});
			window.LiveComposer.Builder.UI.unloadOptionsDeps();
			window.LiveComposer.Builder.Flags.panelOpened = false;

			jQuery("body", window.LiveComposer.Builder.PreviewAreaDocument).removeClass('module-editing-in-progress');
			parent.LiveComposer.Builder.Actions.saveState();
		});
		
		jQuery('.dslca-options-filter-hook.dslca-active').removeClass('dslca-active');
		
		dslc_disable_responsive_view();
		// parent.LiveComposer.Builder.Actions.saveState();

	});

	/**
	 * Hook - Cancel Changes
	 */
	jQuery(document).on( 'click', '.dslca-module-edit-cancel', function(e){

		e.preventDefault();

		dslc_module_options_cancel_changes(function(){

			// window.LiveComposer.Builder.UI.initInlineEditors({withRemove:true});
			window.LiveComposer.Builder.UI.unloadOptionsDeps();
			window.LiveComposer.Builder.Flags.panelOpened = false;

			jQuery("body", window.LiveComposer.Builder.PreviewAreaDocument).removeClass('module-editing-in-progress');

		});

		jQuery('.dslca-options-filter-hook.dslca-active').removeClass('dslca-active');

		dslc_disable_responsive_view();
	});
	/**
	 *  Hook - change unit ("px","%") 
	 */

	// Target the specific unit selector fields
	const unitSelectors = jQuery('select.dslca-modules-section-edit-field-select[data-id$="_unit"]');

    unitSelectors.on('change', function() {
        const changedSelector = jQuery(this);
        const dataId = changedSelector.data('id');
        const selectedUnit = changedSelector.val();
        
        // Step 1: Determine the target prefix for affected dimensional sliders.
        // This turns "css_header_padding_unit" into "css_header_padding".
        const targetInputsPrefix = dataId.replace('_unit', '');

        // Define the search scope: the nearest options form container.
        const $localContext = changedSelector.closest('.dslca-modules-section-edit-form'); 
        
        if (targetInputsPrefix && $localContext.length) {
            
            // Step 2: Find all affected numeric inputs within the context 
            // that use the specific numeric class AND start with the calculated prefix.
            const targetSelector = `input.dslca-modules-section-edit-field-slider-numeric[data-id^="${targetInputsPrefix}"]`;
            const numericInputs = $localContext.find(targetSelector);

            numericInputs.each(function() {
                const inputEl = jQuery(this);
                const defaultPxMin = parseFloat(inputEl.attr('data-min')) || -2000;
                const defaultPxMax = parseFloat(inputEl.attr('data-max')) || 2000;

                let newMin, newMax;

                if (selectedUnit === '%') {
                    newMin = -100;  
                    newMax = 100; 
                } else {
                    newMin = defaultPxMin;
                    newMax = defaultPxMax;
                }

                // 2. Update Data Attributes and UI Label
                inputEl.attr('data-ext', selectedUnit).data('ext', selectedUnit);
                inputEl.attr('min', newMin).attr('max', newMax);
                
                inputEl.closest('.dslca-module-area-edit-field-numeric-wrap')
                       .find('.dslca-module-area-edit-field-numeric-ext, .dslca-modules-section-edit-field-numeric-ext')
                       .text(selectedUnit);


                const rawVal = inputEl.val();
                
                if (rawVal === '' || rawVal === null) {
                    inputEl.trigger('change');
                    return true;
                }
                
                let currentVal = parseFloat(rawVal);
                
                if (currentVal < newMin) {
                    currentVal = newMin;
                } else if (currentVal > newMax) {
                    currentVal = newMax;
                }
                
                inputEl.val(currentVal).trigger('change');
                
                if (inputEl.hasClass('slider-initiated')) {
                     inputEl.trigger('slider_update'); 
                }
            });
        }
    });
});

/* Editor scripts */
const settingsPanelInit = () => {
	var self = window.LiveComposer.Builder;
	window.LiveComposer.Builder.Helpers.colorpickers = [];
/*
	window.LiveComposer.Builder.UI.initInlineEditors = function(params){
		params = params || {};

		if ( params.withRemove == true ) {
			try {
				window.LiveComposer.Builder.PreviewAreaWindow.tinyMCE.remove();
			} catch(err) {
				console.info( 'No tinyMCE code found. Error code: 10181116.' );
			}
		}

		window.LiveComposer.Builder.PreviewAreaWindow.tinyMCE.init({
			selector: '.inline-editor.dslca-editable-content',
			editor_deselector: 'mce-content-body',
			menubar: false,
			inline: true,
			plugins: 'wordpress wplink lists paste',
			paste_as_text: true, // Paste styled text as plain text only. Requires 'paste' in plugins.
			paste_block_drop: true, // Disabled drop action for inline editor to prevent js errors in the console. http://archive.tinymce.com/wiki.php/Plugin3x:paste
			style_formats: [
					{title: 'Paragraph', format: 'p'},
					{title: 'Header 1', format: 'h1'},
					{title: 'Header 2', format: 'h2'},
					{title: 'Header 3', format: 'h3'},
					{title: 'Header 4', format: 'h4'},
					{title: 'Header 5', format: 'h5'},
					{title: 'Header 6', format: 'h6'},
			  ],
			toolbar: 'styleselect | bold italic blockquote | removeformat | bullist numlist '
		});
	}
*/
	/* Destroy instanced of sliders, color pickers and other temporary elements */
	window.LiveComposer.Builder.UI.clearUtils = function() {

		if ( window.dslcDebug ) console.log( 'window.LiveComposer.Builder.UI.clearUtils' );

		// Destroy all Color Pickers
		window.LiveComposer.Builder.UI.clearColorPickers();

		// Delete module backups form memory.
		if ( undefined !== window.LiveComposer.Builder.moduleBackup ) {
			window.LiveComposer.Builder.moduleBackup.remove();
		}

		jQuery('.temp-styles-for-module', window.LiveComposer.Builder.PreviewAreaDocument).remove();

		// Hide inline editor panel if on [Confirm] or [Cancel] button click.
		jQuery('.mce-tinymce', window.LiveComposer.Builder.PreviewAreaDocument).hide();
	}

	window.LiveComposer.Builder.UI.clearColorPickers = function() {

		if ( Array.isArray(self.Helpers.colorpickers ) ) {

			self.Helpers.colorpickers.forEach(function(item){
				// Do not delete color picker instance from row settings panel,
				// as it stays on page and not get loaded via Ajax.
				if ( ! jQuery(item).hasClass('dslca-modules-section-edit-field') ) {
					// Destroy color picker instance.
					jQuery(item).remove();
				}
			});

			self.Helpers.colorpickers = [];
		}

		// Delete the color picker events.
		jQuery( 'body' ).off( 'click.wpcolorpicker' );
	}

	/** Options dependencies */
	window.LiveComposer.Builder.Helpers.depsHandlers = [];

	window.LiveComposer.Builder.UI.loadOptionsDeps = function() {
		var self = this;

		jQuery(".dslca-module-edit-option").each(function(){

			var elem = this;
			var parsed = true;

			try {
				var dep = JSON.parse( LiveComposer.Utils.b64_to_utf8( jQuery(this).data('dep') ) );
			} catch(e){
				parsed = false;
			}

			if ( parsed ) {
				var handler = function(){
					var optElem = this;
					var localDep = {};

					if ( ( optElem.type == 'radio' || optElem.type == 'checkbox' ) && dep[ optElem.value ] == undefined ) {
						return false;
					}

					if ( optElem.type == 'checkbox' && dep[ optElem.value ] != undefined ) {
						localDep[ optElem.value ] = dep[ optElem.value ];
					} else {
						localDep = dep;
					}

					Object.keys(localDep).forEach(function(opt_val){
						localDep[ opt_val ].split(',').forEach(function(item){
							var opt_wrap = jQuery(".dslca-module-edit-option-" + item.trim()).closest('.dslca-module-edit-option');
							var checkedCheckbox = true;

							if ( optElem.type == 'radio' || optElem.type == 'checkbox' ) {
								checkedCheckbox = jQuery(optElem).is(":checked");
							}

							var section_tab = jQuery('.dslca-module-edit-options-tab-hook.dslca-active').data('id');

							if ( optElem.value == opt_val && checkedCheckbox ) {
								if ( opt_wrap.not( ".dependent" ) ) {
									opt_wrap.addClass('dependent');
								}

								if ( opt_wrap.hasClass('dep-hide') ) {
									opt_wrap.removeClass('dep-hide');
									opt_wrap.addClass('dep-show');
								} else {
									opt_wrap.addClass('dep-show');
								}

								if ( section_tab == opt_wrap.data('tab') ) {
									opt_wrap.show();
								}
							} else {
								if ( opt_wrap.not( ".dependent" ) ) {
									opt_wrap.addClass('dependent');
								}

								if ( opt_wrap.hasClass('dep-show') ) {
									opt_wrap.removeClass('dep-show');
									opt_wrap.addClass('dep-hide');
								} else {
									opt_wrap.addClass('dep-hide');
								}

								opt_wrap.hide();
							}
						});
					});
				}

				jQuery(document).on('change dslc-init-deps', '.dslca-module-edit-option > *[data-id="' + jQuery(this).data('id') + '"]', handler);
				window.LiveComposer.Builder.Helpers.depsHandlers.push( handler );
			}
		});

		jQuery(".dslca-module-edit-option input, .dslca-module-edit-option select").trigger('dslc-init-deps');
	}

	window.LiveComposer.Builder.UI.unloadOptionsDeps = function() {

		window.LiveComposer.Builder.Helpers.depsHandlers.forEach(function(handler){

			jQuery(document).unbind( 'change', handler );
			jQuery(document).unbind( 'dslc-init-deps', handler );
		});

		window.LiveComposer.Builder.Helpers.depsHandlers = [];
	}

	/**
	 * Creates inline style tag when editing WYSWIG
	 *
	 * @param  {object} params
	 *    params.rule
	 *    params.elems
	 *    params.module_id
	 */
	window.LiveComposer.Builder.Helpers.processInlineStyleTag = function( params ) {

		if ( typeof params != 'object' ) return false;

		var resp_prefix = '', resp_postfix = '';

		if ( params.context.closest(".dslca-module-edit-option").data('tab') == 'tablet_responsive' ) {

			resp_prefix = '@media only screen and (max-width: 1024px) and (min-width: 768px) {';
			resp_postfix = '}';
		} else if ( params.context.closest(".dslca-module-edit-option").data('tab') == 'phone_responsive' ) {

			resp_prefix = '@media only screen and (max-width: 767px) {';
			resp_postfix = '}';
		}

		params.styleContent = resp_prefix + params.styleContent + resp_postfix;

		var id = resp_prefix + params.rule + params.elems;
		id = id.replace(/ /gi, '');

		if ( window.LiveComposer.Builder.PreviewAreaDocument[0].getElementById(id) == null ) {

			var styleTag = document.createElement('style');
			styleTag.innerHTML = params.styleContent;
			styleTag.id = id;
			styleTag.className = "temp-styles-for-module";

			window.LiveComposer.Builder.PreviewAreaDocument[0].body.appendChild(styleTag);
		} else {

			window.LiveComposer.Builder.PreviewAreaDocument[0].getElementById(id).innerHTML = params.styleContent;
		}
	}

	window.LiveComposer.Builder.UI.shakePanelConfirmButton = function() {

		jQuery('.dslca-module-edit-save').addClass('lc-shake-effect active');

		setTimeout(function(){

			jQuery('.dslca-module-edit-save').removeClass('lc-shake-effect active');
		}, 1000);
	};

	onModuleOptionsChange();
	onSectionOptionsChange();
	onFileUploadOptionsChange();
};

const onModuleOptionsChange = () => {
	// Live Preview for Module Settings Change
	jQuery(document).on( 'change', '.dslca-module-edit-field', function(){
		if ( window.dslcDebug ) console.log( 'on change event for .dslca-module-edit-field' );

		var dslcOptionValue = '',
			dslcOptionValueOrig = '',
			dslcOption = jQuery(this),
			dslcOptionID = dslcOption.data('id'),
			dslcOptionWrap = dslcOption.closest('.dslca-module-edit-option'),
			dslcModule = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument),
			dslcModuleID = dslcModule.data('module'),
			dslcModuleOptions = jQuery.find( '.dslca-module-options-front textarea', dslcModule );

		// Add changed class
		dslcModule.addClass('dslca-module-change-made');

		// Check if the changed option is a UNIT SELECTOR by checking for the '_unit' suffix.
		if (dslcOptionID.includes('_unit')) { 
			
			// Step 1: Determine the target prefix (e.g., 'css_header_padding').
			const targetInputsPrefix = dslcOptionID.replace('_unit', '');
			const selectedUnit = dslcOption.val();
			
			// --- NEW SCOPE LOGIC ---
			
			// A. Find the specific 'data-tab' ID of the option being changed.
			// We look up to the nearest parent that contains the 'data-tab' attribute.
			const tabId = dslcOption.closest('[data-tab]').attr('data-tab');
			
			// B. The search scope is the entire form/container.
			const $formContainer = dslcOption.closest('form'); 

			if (targetInputsPrefix && $formContainer.length && tabId) {
				
				// C. Construct a highly specific selector:
				// 1. Target the option wrapper for the current tab: .dslca-module-edit-option[data-tab="header_styling"]
				// 2. Filter inputs by the calculated prefix: input[data-id^="css_header_padding"]
				const selector = `.dslca-module-edit-option[data-tab="${tabId}"] input.dslca-module-edit-field-numeric[data-id^="${targetInputsPrefix}"]`;
				
				const numericInputs = $formContainer.find(selector);

				numericInputs.each(function() {
					const inputEl = jQuery(this);
					const rawVal = inputEl.val();

					// 2. Define Ranges and Current Value
					const defaultPxMin = parseFloat(inputEl.attr('data-min')) || -2000;
					const defaultPxMax = parseFloat(inputEl.attr('data-max')) || 2000;

					let newMin, newMax;

					// If switching to %, clamp the slider range to 0-100.
					if (selectedUnit === '%') {
						newMin = -100;  
						newMax = 100; 
					} else {
						// Otherwise (px, em, rem), use the slider's defined range.
						newMin = defaultPxMin;
						newMax = defaultPxMax;
					}

					// 3. Update Data and Attributes (UI and Data Model)
					inputEl.attr('data-ext', selectedUnit).data('ext', selectedUnit);
					inputEl.attr('min', newMin).attr('max', newMax);
					inputEl.siblings('.dslca-module-edit-field-numeric-ext').text(selectedUnit);

					// 4. Clamp and Update Value (Only if a value exists)
					if (rawVal === '' || rawVal === null) {
						inputEl.trigger('change');
						return true; // continue
					}
					
					let currentVal = parseFloat(rawVal);
					
					// Clamp the value to the new range
					if (currentVal < newMin) {
						currentVal = newMin;
					} else if (currentVal > newMax) {
						currentVal = newMax;
					}
					
					// 5. Trigger Live Update
					inputEl.val(currentVal).trigger('change');
					
					if (inputEl.hasClass('slider-initiated')) {
						inputEl.trigger('slider_update'); 
					}
				});
			}
		}

		// Hide/Show tabs in the module options panel.
		// Required to show/hide particular options tabs based on the current selection.
		// Active only for dropdowns and checkboxes.
		if ( dslcOptionWrap.hasClass('dslca-module-edit-option-select') ||
		dslcOptionWrap.hasClass('dslca-module-edit-option-checkbox') ) {
			dslc_module_options_hideshow_tabs();
		}

		/**
		 * Refresh on change = true
		 *
		 * Refresh module HTML from the server on every field value change
		 */
		if ( jQuery(this).closest('.dslca-module-edit-option').data('refresh-on-change') == 'active' ) {
			/**
			 * Get the new value
			 */
			if ( dslcOptionWrap.find('.dslca-module-edit-option-checkbox-wrapper').length ) {
				var dslcOptionChoices = jQuery('input[type="checkbox"]', dslcOptionWrap);
				dslcOptionChoices.each(function(){
					if ( jQuery(this).prop('checked') ) {
						dslcOptionValue = dslcOptionValue + jQuery(this).val() + ' ';
					}
				});
			} else if ( dslcOption.hasClass('dslca-module-edit-option-radio') ) {
				var dslcOptionValue = jQuery.find('.dslca-module-edit-field:checked', dslcOption).val();
			} else {
				var dslcOptionValue = dslcOption.val();
				// Post Grid > Thumbnail: Orientation change.
				// Need to change thumbnail width to get it work as expected
				if ( dslcOptionID == 'orientation' && dslcOptionValue == 'horizontal' ) {
					var dslcSliderEl = jQuery('.dslca-module-edit-option-thumb_width .dslca-module-edit-field');
					dslcSliderEl.val('40').trigger('change');
				} else if ( dslcOptionID == 'orientation' && dslcOptionValue == 'vertical' ) {
					var dslcSliderEl = jQuery('.dslca-module-edit-option-thumb_width .dslca-module-edit-field');
					dslcSliderEl.val('100').trigger('change');
				}
			}

			/**
			 * Change old value with new value
			 */

			if ( undefined !== dslcOptionValue && null !== dslcOptionValue ) {
				dslcOptionValue = dslcOptionValue.trim().replace(/<textarea/g, '<lctextarea').replace(/<\/textarea/g, '</lctextarea');
			}

			if ( null === dslcOptionValue ) {
				dslcOptionValue = '';
			}

			jQuery( '.dslca-module-options-front textarea[data-id="' + dslcOptionID + '"]', dslcModule ).val(dslcOptionValue);
			jQuery('.dslca-container-loader').show();

			(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)( function(){

				jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).addClass('dslca-module-change-made');

				if ( dslcOptionID == 'css_load_preset' && ! jQuery('body').hasClass('dslca-new-preset-added') ) {

					window.dslc_module_options_show( dslcModuleID );
					jQuery('.dslca-container-loader').hide();
				} else {

					jQuery('.dslca-container-loader').hide();
				}

				jQuery('body').removeClass('dslca-new-preset-added');


				// Trigger 'LC.moduleChange' event.
				// This event can be used by 3-rd party developers to re-init
				// some of the JavaScript code on modure re-rendering.
				LiveComposer.Utils.publish( 'LC.moduleChange', {
					moduleId: dslcModuleID,
					optionID: dslcOptionID,
					optionVal: dslcOption.val()
				});
			});

		/**
		 * Refresh on change = false
		 *
		 * Do not refresh from the server, but using JS
		 */
		} else {

			/**
			 * Live Preview
			 */

			if ( dslcOption.hasClass('dslca-module-edit-field-font') ) {

				var dslcFontsToLoad = dslcOption.val();
				dslcFontsToLoad = dslcFontsToLoad + ':400,100,200,300,500,600,700,800,900';

				var dslcAffectOnChangeEl = dslcOption.data('affect-on-change-el');
				var dslcAffectOnChangeRule = dslcOption.data('affect-on-change-rule');
				var dslcAffectOnChangeVal = dslcOption.val();
				var dslcAffectOnChangeValOrig = dslcAffectOnChangeVal;
				var module = jQuery(".dslca-module-being-edited", LiveComposer.Builder.PreviewAreaDocument);

				if ( dslcOption.val().length && dslcGoogleFontsArray.indexOf( dslcOption.val() ) !== -1  ) {

					// Call WebFont function from the iframe
					document.getElementById('page-builder-frame').contentWindow.WebFont.load({
							google: {
								families: [ dslcFontsToLoad ]
							},
							active : function(familyName, fvd) {

								if ( jQuery( '.dslca-font-loading' ).closest('.dslca-module-edit-field-font-next').length ) {

									jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-right');
								} else {

									jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-left');
								}

								var elems = dslcAffectOnChangeEl.split(',');
								var styleContent = "#" + module[0].id + " " + elems.join(", #" + module[0].id + " ") + " {" + dslcAffectOnChangeRule + ": " + dslcAffectOnChangeVal + "}";

								LiveComposer.Builder.Helpers.processInlineStyleTag({

									context: dslcOption,
									rule: dslcAffectOnChangeRule,
									elems: dslcAffectOnChangeEl,
									styleContent: styleContent
								});
							},
							inactive : function ( familyName, fvd ) {

								if ( jQuery( '.dslca-font-loading' ).closest('.dslca-module-edit-field-font-next').length ) {

									jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-right');
								} else {

									jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-left');
								}
							}
						}
					);

				} else {

					setTimeout( function(){

						if ( jQuery( '.dslca-font-loading.dslca-module-edit-field-font-next' ).length ) {

							jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-right');
						} else {

							jQuery('.dslca-font-loading').removeClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-spin').addClass('dslc-icon-chevron-left');
						}

						var elems = dslcAffectOnChangeEl.split(',');
						var styleContent = "#" + module[0].id + " " + elems.join(", #" + module[0].id + " ") + " {" + dslcAffectOnChangeRule + ": " + dslcAffectOnChangeVal + "}";

						LiveComposer.Builder.Helpers.processInlineStyleTag({

							context: dslcOption,
							rule: dslcAffectOnChangeRule,
							elems: dslcAffectOnChangeEl,
							styleContent: styleContent
						});
					}, 100);
				}

			/**
			 * Checkbox
			 */
			} else if ( dslcOption.hasClass('dslca-module-edit-field-checkbox') ) {

				var dslcOptionChoices = jQuery('input[type="checkbox"]', dslcOptionWrap);

				dslcOptionChoices.each(function(){

					/*
					@todo This function is specific to borders. Needs review.
					 */

					if ( jQuery(this).prop('checked') ) {

						dslcOptionValue = dslcOptionValue + 'solid ';
						dslcOptionValueOrig = dslcOptionValueOrig + jQuery(this).val() + ' ';
					} else {

						dslcOptionValue = dslcOptionValue + 'none ';
					}
				});

				// Here dslcOptionValue will look like: none none none solid.
			}

			/**
			 * All other option types
			 */
			if ( ! dslcOption.hasClass('dslca-module-edit-field-font') &&
					dslcOption.data('affect-on-change-el') != null &&
					dslcOption.data('affect-on-change-rule') != null
					 ) {

				var dslcExt = dslcOption.data('ext') || '';
				var dslcAffectOnChangeEl = dslcOption.data('affect-on-change-el');
				var dslcAffectOnChangeRule = dslcOption.data('affect-on-change-rule');
				var dslcAffectOnChangeVal = dslcOption.val();
				var dslcAffectOnChangeValOrig = dslcAffectOnChangeVal;

				if ( dslcOption.hasClass('dslca-module-edit-field-checkbox') ) {

					dslcAffectOnChangeVal = dslcOptionValue;
					dslcAffectOnChangeValOrig = dslcOptionValueOrig;
				}

				if ( dslcOption.hasClass('dslca-module-edit-field-image') ) {

					dslcAffectOnChangeVal = 'url("' + dslcAffectOnChangeVal + '")';
				}

				if ( ( null !== dslcAffectOnChangeVal && dslcAffectOnChangeVal.length < 1 ) && ( dslcAffectOnChangeRule == 'background-color' || dslcAffectOnChangeRule == 'background' ) ) {

					dslcAffectOnChangeVal = 'transparent';
				}

				dslcAffectOnChangeRule.split(',').forEach(function(rule){

					rule = rule.replace(/\s+/g, '');

					var module = jQuery(".dslca-module-being-edited", LiveComposer.Builder.PreviewAreaDocument);

					var elems = dslcAffectOnChangeEl.split(',');
					var styleContent = "#" + module[0].id + " " + elems.join(", #" + module[0].id + " ") + " {" + rule + ": " + dslcAffectOnChangeVal + dslcExt + "}";

					LiveComposer.Builder.Helpers.processInlineStyleTag({

						context: dslcOption,
						rule: rule,
						elems: dslcAffectOnChangeEl,
						styleContent: styleContent
					});
				});
			}

			/**
			 * Update option
			 */

			var dslcOptionToApply = '';

			// Do we work with CSS control or module property?
			if ( dslcOptionID.indexOf('css_') !== -1 ) {
				// Apply CSS property.
				dslcOptionToApply = dslcAffectOnChangeValOrig;
			} else {
				// Apply module property.
				dslcOptionToApply = dslcOption.val();
			}

			jQuery( '.dslca-module-option-front[data-id="' + dslcOptionID + '"]', dslcModule ).val( dslcOptionToApply );

			// Trigger 'LC.moduleChange' event.
			// This event can be used by 3-rd party developers to re-init
			// some of the JavaScript code on modure re-rendering.
			LiveComposer.Utils.publish( 'LC.moduleChange', {

				moduleId: dslcModule[0].id,
				optionID: dslcOptionID,
				optionVal: dslcAffectOnChangeValOrig || dslcOption.val()
			});
		}
	});
}

const onSectionOptionsChange = () => {
	// ROW styling option changes
	jQuery(document).on( 'change', '.dslca-modules-section-edit-field', function() {
		var dslcField, dslcFieldID, dslcEl, dslcModulesSection, dslcVal, dslcValReal, dslcValExt, dslcRule, dslcSetting, dslcTargetEl, dslcImgURL;

		dslcField = jQuery(this);
		dslcFieldID = dslcField.data('id');
		dslcVal = dslcField.val();
		dslcValReal = dslcVal;
		dslcValExt = dslcVal + dslcField.data('ext');
		dslcRule = dslcField.data('css-rule');

		dslcEl = jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument); // Currently editing element
		dslcTargetEl = dslcEl;
		dslcSetting = jQuery('.dslca-modules-section-settings input[data-id="' + dslcFieldID + '"]', dslcEl );

		dslcEl.addClass('dslca-modules-section-change-made');

		// If image/upload field alter the value ( use from data )
		if ( dslcField.hasClass('dslca-modules-section-edit-field-upload') ) {

			if ( dslcVal && dslcVal.length ) {

				// dslcVal = dslcField.data('dslca-img-url');
				// dslcVal = jQuery.find('.dslca-modules-section-settings input[data-id="dslca-img-url"]', dslcEl ).val();
				dslcVal = jQuery( '.dslca-modules-section-settings input[data-id="dslca-img-url"]', dslcEl ).val();
			}
		}

		if ( dslcRule == 'background-image' ) {

			dslcVal = 'url("' + dslcVal + '")';
			LiveComposer.Builder.PreviewAreaWindow.dslc_bg_video();
		}

		if ( dslcFieldID == 'bg_image_attachment' ) {

			dslcEl.removeClass('dslc-init-parallax');
		}

		if ( dslcFieldID == 'border-top' ||
			dslcFieldID == 'border-right' ||
			dslcFieldID == 'border-bottom' ||
			dslcFieldID == 'border-left' ) {

			var dslcBorderStyle = jQuery('.dslca-modules-section-settings input[data-id="border_style"]').val();
			dslcSetting = jQuery('.dslca-modules-section-settings input[data-id="border"]', dslcEl );

			dslcValReal = '';

			var dslcChecboxesWrap = dslcField.closest('.dslca-modules-section-edit-option-checkbox-wrapper');
			dslcChecboxesWrap.find('.dslca-modules-section-edit-field-checkbox').each(function(){

				if ( jQuery(this).is(':checked') ) {

					if ( jQuery(this).data('id') == 'border-top' ) {

						dslcValReal += 'top ';
					} else if ( jQuery(this).data('id') == 'border-right' ) {

						dslcValReal += 'right ';
					} else if ( jQuery(this).data('id') == 'border-bottom' ) {

						dslcValReal += 'bottom ';
					} else if ( jQuery(this).data('id') == 'border-left' ) {

						dslcValReal += 'left ';
					}
				}
			});

			if ( dslcField.is(':checked') ) {

				if ( dslcField.data('id') == 'border-top' ) {

					dslcEl.css({ 'border-top-style' : dslcBorderStyle });
				} else if ( dslcField.data('id') == 'border-right' ) {

					dslcEl.css({ 'border-right-style' : dslcBorderStyle });
				} else if ( dslcField.data('id') == 'border-bottom' ) {

					dslcEl.css({ 'border-bottom-style' : dslcBorderStyle });
				} else if ( dslcField.data('id') == 'border-left' ) {

					dslcEl.css({ 'border-left-style' : dslcBorderStyle });
				}

			} else {

				if ( dslcField.data('id') == 'border-top' ) {

					dslcEl.css({ 'border-top-style' : 'hidden' });
				} else if ( dslcField.data('id') == 'border-right' ) {

					dslcEl.css({ 'border-right-style' : 'hidden' });
				} else if ( dslcField.data('id') == 'border-bottom' ) {

					dslcEl.css({ 'border-bottom-style' : 'hidden' });
				} else if ( dslcField.data('id') == 'border-left' ) {

					dslcEl.css({ 'border-left-style' : 'hidden' });
				}
			}
		} else if ( dslcField.hasClass( 'dslca-modules-section-edit-field-checkbox' ) ) {

			var checkboxes = jQuery(this).closest('.dslca-modules-section-edit-option-checkbox-wrapper').find('.dslca-modules-section-edit-field-checkbox');
			var checkboxesVal = '';
			checkboxes.each(function(){

				if ( jQuery(this).prop('checked') ) {

					checkboxesVal += jQuery(this).data('val') + ' ';
				}
			});

			var dslcValReal = checkboxesVal;

			/* Show On */
			if ( dslcField.data('id') == 'show_on' ) {

				if ( checkboxesVal.indexOf( 'desktop' ) !== -1 ) {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslc-hide-on-desktop');
				} else {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).addClass('dslc-hide-on-desktop');
				}

				if ( checkboxesVal.indexOf( 'tablet' ) !== -1 ) {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslc-hide-on-tablet');
				} else {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).addClass('dslc-hide-on-tablet');
				}

				if ( checkboxesVal.indexOf( 'phone' ) !== -1 ) {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslc-hide-on-phone');
				} else {

					jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).addClass('dslc-hide-on-phone');
				}

			}

			// Section divider flip.
			if ( dslcField.data('id') == 'section_divider_bottom_flip' ) {
				if ( dslcValReal.indexOf( 'horizontally' ) === -1 ) {
					jQuery('.dslc-section-divider[data-divider-pos="bottom"]', dslcEl).removeClass('dslc-flip-hor');
				} else {
					jQuery('.dslc-section-divider[data-divider-pos="bottom"]', dslcEl).addClass('dslc-flip-hor');
				}

				if ( dslcValReal.indexOf( 'vertically' ) === -1 ) {
					jQuery('.dslc-section-divider[data-divider-pos="bottom"]', dslcEl).removeClass('dslc-flip-vert');
				} else {
					jQuery('.dslc-section-divider[data-divider-pos="bottom"]', dslcEl).addClass('dslc-flip-vert');
				}

			}

			if ( dslcField.data('id') == 'section_divider_top_flip' ) {
				if ( dslcValReal.indexOf( 'horizontally' ) === -1 ) {
					jQuery('.dslc-section-divider[data-divider-pos="top"]', dslcEl).removeClass('dslc-flip-hor');
				} else {
					jQuery('.dslc-section-divider[data-divider-pos="top"]', dslcEl).addClass('dslc-flip-hor');
				}

				if ( dslcValReal.indexOf( 'vertically' ) === -1 ) {
					jQuery('.dslc-section-divider[data-divider-pos="top"]', dslcEl).removeClass('dslc-flip-vert');
				} else {
					jQuery('.dslc-section-divider[data-divider-pos="top"]', dslcEl).addClass('dslc-flip-vert');
				}

			}

		} else if ( dslcFieldID == 'bg_image_attachment' && dslcVal == 'parallax' ) {
			dslcEl.addClass( 'dslc-init-parallax' );
			LiveComposer.Builder.PreviewAreaWindow.dslc_parallax();
		} else if ( dslcFieldID == 'type' ) {
			if ( dslcVal == 'full' ) {
				dslcEl.addClass('dslc-full');
				dslcField.parent().siblings('div[data-id="css_module_section_width_unit"]').hide();
				dslcField.parent().siblings('div[data-id="css_module_section_width"]').hide();
				dslcEl.css('width', '100%');
			} else {
				dslcEl.removeClass('dslc-full');
				dslcField.parent().siblings('div[data-id="css_module_section_width_unit"]').show();
				dslcField.parent().siblings('div[data-id="css_module_section_width"]').show();
			}
			LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();
		} else if ( dslcFieldID == 'columns_spacing' ) {

			if ( dslcVal == 'nospacing' ) {

				dslcEl.addClass('dslc-no-columns-spacing');
			} else {

				dslcEl.removeClass('dslc-no-columns-spacing');
			}
		} else if ( dslcFieldID == 'custom_class' ) {

		} else if ( dslcFieldID == 'custom_id' ) {

		} else if ( dslcFieldID == 'bg_video' ) {

			jQuery('.dslc-bg-video video', dslcEl).remove();

			if ( dslcVal && dslcVal.length ) {

				var dslcVideoVal = dslcVal;
				dslcVideoVal = dslcVideoVal.replace( '.webm', '' );
				dslcVideoVal = dslcVideoVal.replace( '.mp4', '' );
				jQuery.find('.dslc-bg-video-inner', dslcEl).text('<video><source type="video/mp4" src="' + dslcVideoVal + '.mp4" /><source type="video/webm" src="' + dslcVideoVal + '.webm" /></video>');
				LiveComposer.Builder.PreviewAreaWindow.dslc_bg_video();
			}

		} else if ( dslcFieldID == 'section_divider_top_style' || dslcFieldID == 'section_divider_bottom_style' ) {
			let dividerPosition = 'top';
			if ( dslcFieldID == 'section_divider_bottom_style' ) {
				dividerPosition = 'bottom';
			}
			// Remove previous divider SVG.
			let inlineStyles = jQuery( '.dslc-section-divider[data-divider-pos="' + dividerPosition + '"] svg', dslcEl ).attr('style');
			jQuery( '.dslc-section-divider[data-divider-pos="' + dividerPosition + '"]', dslcEl ).html('');

			if ( dslcVal && dslcVal.length ) {
				const divider = jQuery('#dslc-section-dividers', LiveComposer.Builder.PreviewAreaWindow.document).find( 'svg#' + dslcVal ).clone();
				// Insert new divider SVG.
				jQuery( '.dslc-section-divider[data-divider-pos="' + dividerPosition + '"]', dslcEl ).html( divider[0] );
				if ( undefined !== inlineStyles ) {
					jQuery( '.dslc-section-divider[data-divider-pos="' + dividerPosition + '"] svg', dslcEl ).attr('style', inlineStyles);
				}
			}
		} else if ( dslcFieldID == 'bg_image_thumb' ) {

			if ( dslcValReal == 'enabled' ) {

				if ( jQuery('#dslca-post-data-thumb').length ) {

					var dslcThumbURL = "url('" + jQuery('#dslca-post-data-thumb').val() + "')";
					dslcTargetEl.css(dslcRule, dslcThumbURL );
				}

			} else if ( dslcValReal == 'disabled' ) {

				dslcTargetEl.css(dslcRule, 'none' );
			}
		} else {

			if ( dslcField.data('css-element') ) {

				dslcTargetEl = jQuery( dslcField.data('css-element'), dslcEl );
			}

			dslcRule = dslcRule.replace(/ /g,'').split( ',' );
			var dslcValToApply;

			if ( null != dslcField.data('ext') ) {
				dslcValToApply = dslcValExt;
			} else {
				dslcValToApply = dslcVal;
			}

			// Loop through rules (useful when there are multiple rules)
			for ( var i = 0; i < dslcRule.length; i++ ) {
				// dslcTargetEl.css(dslcRule[i], dslcValToApply);
				if (dslcRule[i].trim() !== "" && dslcValToApply !== undefined && dslcValToApply !== null && dslcValToApply !== "") {
      				dslcTargetEl.css(dslcRule[i], dslcValToApply);
                }
			}
		}

		// Update hidden input with new value
		dslcSetting.val( dslcValReal );

		if ( ! LiveComposer.Builder.Flags.generate_code_after_row_changed ) return false;

		// window.dslc_generate_code();
		// window.dslc_show_publish_button();
	});
}

const onFileUploadOptionsChange = () => {
	// Uploading files
	var file_frame;

	jQuery(document).on('click', '.dslca-module-edit-field-image-add-hook, .dslca-modules-section-edit-field-image-add-hook', function(){

		var hook = jQuery(this);

		if ( hook.hasClass( 'dslca-module-edit-field-image-add-hook' ) ) {

			var field = hook.siblings('.dslca-module-edit-field-image');
			var removeHook = hook.siblings('.dslca-module-edit-field-image-remove-hook');
		} else {

			var field = hook.siblings('.dslca-modules-section-edit-field-upload');
			var removeHook = hook.siblings('.dslca-modules-section-edit-field-image-remove-hook');
		}

		// Whether or not multiple files are allowed
		var multiple = false;

		// Create the media frame.
		file_frame = wp.media.frames.file_frame = wp.media({
			title: 'Choose Image',
			button: {
				text: 'Confirm',
			},
			multiple: multiple
		});

		// When an image is selected, run a callback.
		file_frame.on( 'select', function() {

			var attachment = file_frame.state().get('selection').first().toJSON();
			/*
			Save image ID as value of the image input.
			 */
			// field.val( attachment.id ).data( 'dslca-img-url', attachment.url ).trigger('change'); - previous version
			field.val( attachment.id );

			var dataId = hook.parent().attr("data-id");

			/*
			Save alt as value of the image input.
			 */
			if ( attachment.alt != '' && dataId == 'image' ) {
				jQuery('.dslca-module-edit-option-image_alt input[data-id="image_alt"]').val( attachment.alt );
			}

			/*
			Save alt as value of the image input.
			 */
			if ( attachment.title != '' && dataId == 'image' ) {
				jQuery('.dslca-module-edit-option-image_title input[data-id="image_title"]').val( attachment.title );
			}

			/*
			Save image URL as data attribute of input in dslca-modules-section-settings set
			We need URL in 'dslca-img-url' for live preview
			 */
			jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).find('.dslca-modules-section-settings input[data-id="dslca-img-url"]').val( attachment.url );
			field.trigger('change'); // trigger change only after 'dslca-img-url' is set

			hook.hide();
			removeHook.show();
		});

		// Finally, open the modal
		file_frame.open();
	});

	jQuery(document).on('click', '.dslca-module-edit-field-image-remove-hook, .dslca-modules-section-edit-field-image-remove-hook', function(){

		var hook = jQuery(this);

		if ( hook.hasClass( 'dslca-module-edit-field-image-remove-hook' ) ) {

			var field = hook.siblings('.dslca-module-edit-field-image');
			var addHook = hook.siblings('.dslca-module-edit-field-image-add-hook');
		} else {

			var field = hook.siblings('.dslca-modules-section-edit-field-upload');
			var addHook = hook.siblings('.dslca-modules-section-edit-field-image-add-hook');
		}

		field.val('').trigger('change'); // .dslca-modules-section-edit-field

		/*
		Delete alt and title value.
		 */
		var dataId = hook.parent().attr("data-id");

		if ( dataId == 'image' ) {
			jQuery('.dslca-module-edit-option-image_alt input').attr('value', '').trigger( 'change' );
			jQuery('.dslca-module-edit-option-image_alt input').attr('data-val-bckp', '').trigger( 'change' );
			jQuery('.dslca-module-edit-option-image_title input').attr('value', '').trigger( 'change' );
			jQuery('.dslca-module-edit-option-image_title input').attr('data-val-bckp', '').trigger( 'change' );
		}
		hook.hide();
		addHook.show();
	});
}



/**
 * MODULES SETTINGS PANEL - Filter Module Options
 */
function dslc_module_options_section_filter( sectionID ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_section_filter' );

	// Hide all options
	jQuery('.dslca-module-edit-option').hide();

	// Show options for current section
	jQuery('.dslca-module-edit-option[data-section="' + sectionID + '"]').show();

	// Recall module options tab
	elementOptionsTabs();
}

const resetResponsiveOptions = () => {
	// Get active tab (Tablet/Phone)
	const currentTab = document.querySelector('.dslca-module-edit-options-tab-hook.dslca-active').dataset.id;

	if ( 'tablet_responsive' === currentTab || 'phone_responsive' === currentTab ) {
		// Hide/Show options
		const activeSettings =  document.querySelectorAll('.dslca-module-edit-option[data-tab="' + currentTab + '"]');

		activeSettings.forEach( ( element )=> {
			const optionId =  element.querySelector( '.dslca-module-edit-field' ).dataset.id;

			// Don't want to reset value of the breakpoint enabler.
			if ( 'css_res_t' === optionId || 'css_res_p' === optionId ) {
				return;
			}

			var control         = jQuery('.dslca-module-edit-option-' + optionId );
			var control_storage = control.find('.dslca-module-edit-field');

			/* // Get the element we are editing
			var module = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument);

			// Get the element id
			var module_id = module[0].id;

			var responsive_prefix = '';

			if ( 'tablet_responsive' === control.data('tab') ) {
				responsive_prefix = 'body.dslc-res-tablet ';
			} else if ( 'phone_responsive' === control.data('tab') ) {
				responsive_prefix = 'body.dslc-res-phone ';
			}

			var affect_on_change_el = control_storage.data('affect-on-change-el');

			if ( affect_on_change_el === undefined) return;

			var affect_on_change_elmts = affect_on_change_el.split( ',' );

			affect_on_change_el = '';

			// Loop through elements (useful when there are multiple elements)
			for ( var i = 0; i < affect_on_change_elmts.length; i++ ) {

				if ( i > 0 ) {

					affect_on_change_el += ', ';
				}

				affect_on_change_el += responsive_prefix + '#' + module_id + ' ' + affect_on_change_elmts[i];
			}

			var affect_on_change_rule  = control_storage.data('affect-on-change-rule').replace(/ /g,'');
			var affect_on_change_rules = affect_on_change_rule.split( ',' );

			var control_value;
			var control_data_ext = control_storage.data('ext');


			// Disable

			control_value = dslc_get_control_value(control_id);
			// Temporary backup the current value as data attribute
			control_storage.data( 'val-bckp', control_value );

			// Loop through rules (useful when there are multiple rules)
			for ( var i = 0; i < affect_on_change_rules.length; i++ ) {

				// remove css rule in element inline style
				jQuery( affect_on_change_el, LiveComposer.Builder.PreviewAreaDocument ).css( affect_on_change_rules[i] , '' );
				// remove css rule in css block
				disable_css_rule ( affect_on_change_el, affect_on_change_rules[i], module_id);
				// PROBLEM do not work with multiply rules ex.: .dslc-text-module-content,.dslc-text-module-content p
			}
 */
			control_storage.val('').trigger('change');
		} )
	}
}



/**
 * MODULES SETTINGS PANEL - Show module options tab
 */
const elementOptionsTabs = ( dslcTab ) => {

	if ( window.dslcDebug ) console.log( 'elementOptionsTabs' );

	// Get currently active section
	var dslcSectionID = jQuery('.dslca-options-filter-hook.dslca-active').data('section');

	// If tab not supplied set to first
	dslcTab = typeof dslcTab !== 'undefined' ? dslcTab : jQuery('.dslca-module-edit-options-tab-hook[data-section="' + dslcSectionID + '"]:first');

	// Get the tab ID
	var dslcTabID = dslcTab.data('id');

	// Set active class on tab
	jQuery('.dslca-module-edit-options-tab-hook').removeClass('dslca-active');
	dslcTab.addClass('dslca-active');

	// Show tabs container
	jQuery('.dslca-module-edit-options-tabs').show();

	// Hide/Show tabs hooks
	jQuery('.dslca-module-edit-options-tab-hook').hide();
	jQuery('.dslca-module-edit-options-tab-hook[data-section="' + dslcSectionID + '"]').show();

	if ( dslcTabID ) {

		// Hide/Show options
		jQuery('.dslca-module-edit-option').hide();
		jQuery('.dslca-module-edit-option[data-tab="' + dslcTabID + '"]').show();

		// Hide/Show Tabs
		dslc_module_options_hideshow_tabs();

		// If only one tab hide the tabs container
		if ( jQuery('.dslca-module-edit-options-tab-hook:visible').length < 2 ) {

			jQuery('.dslca-module-edit-options-tabs').hide();
		} else {

			jQuery('.dslca-module-edit-options-tabs').show();
		}

		/**
		 * If responsive tab, change the width of the dslc-content div
		 */

		dslc_disable_responsive_view();

		// Tablet
		if ( dslcTabID == DSLCString.str_res_tablet.toLowerCase() + '_responsive' ) {

			jQuery('body').removeClass('dslc-res-big dslc-res-smaller-monitor dslc-res-phone dslc-res-tablet');
			jQuery('body').addClass('dslc-res-tablet');
			jQuery('html').addClass('dslc-responsive-preview');
		}

		// Phone
		if ( dslcTabID == DSLCString.str_res_phone.toLowerCase() + '_responsive' ) {

			jQuery('body').removeClass('dslc-res-big dslc-res-smaller-monitor dslc-res-phone dslc-res-tablet');
			jQuery('body').addClass('dslc-res-phone');
			jQuery('html').addClass('dslc-responsive-preview');
		}

		// If responsive reload module
		if ( dslcTabID == DSLCString.str_res_tablet.toLowerCase() + '_responsive' || dslcTabID == DSLCString.str_res_phone.toLowerCase() + '_responsive' ) {

			// Show the loader
			jQuery('.dslca-container-loader').show();

			// Reload Module
			(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)(function(){

				// Hide the loader
				jQuery('.dslca-container-loader').hide();
			});
		}
	}

	// Scroll horizontally options panel to the left (not ready)
	if ( jQuery('body').hasClass('rtl') ) {
		var totalWidthOption = 0;
		var totalWidthGroup = 0;
		var totalWidth = 0;

		jQuery('.dslca-module-edit-options-wrapper > .dslca-module-edit-option:visible').each(function(index) {
			if ( ! jQuery(this).hasClass('dslca-module-edit-option-hidden') && ! jQuery(this).hasClass('dslca-module-control-group') ) {
				totalWidthOption += parseInt(jQuery(this).outerWidth(), 10);
			}
		});

		jQuery('.dslca-module-edit-options-wrapper > .dslca-module-control-group:visible').each(function(index) {
			totalWidthGroup += parseInt(jQuery(this).outerWidth(), 10);
		});

		totalWidth = parseInt(totalWidthOption) + parseInt(totalWidthGroup) + 10;

		jQuery('.dslca-module-edit-options-wrapper').css({
			'width': totalWidth + 'px',
		});
	}
}

/**
 * MODULES SETTINGS PANEL - Hide show tabs based on option choices
 */
function dslc_module_options_hideshow_tabs() {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_hideshow_tabs' );

	var dslcSectionID = jQuery('.dslca-options-filter-hook.dslca-active').data('section');

	if ( dslcSectionID == 'styling' ) {

		// Vars
		var dslcContainer = jQuery('.dslca-module-edit'),
		dslcHeading = true,
		dslcFilters = true,
		dslcCarArrows = true,
		dslcCarCircles = true,
		dslcPagination = true,
		dslcElThumb = true,
		dslcElTitle = true,
		dslcElExcerpt = true,
		dslcElMeta = true,
		dslcElButton = true,
		dslcElCats = true,
		dslcElCount = true,
		dslcElSeparator = true,
		dslcElTags = true,
		dslcElSocial = true,
		dslcElPosition = true,
		dslcElIcon = true,
		dslcElContent = true,
		dslcElPrice = true,
		dslcElPriceSec = true,
		dslcElAddCart = true,
		dslcElDetails = true,
		dslcElQuote = true,
		dslcElAuthorName = true,
		dslcElAuthorPos = true,
		dslcElImage = true,
		dslcElLogo = true;


		// Is heading selected?
		if ( ! jQuery('.dslca-module-edit-field[value="main_heading"]').is(':checked') )
			dslcHeading = false;

		// Are filters selected?
		if ( ! jQuery('.dslca-module-edit-field[value="filters"]').is(':checked') )
			dslcFilters = false;

		// Are arrows selected?
		if ( ! jQuery('.dslca-module-edit-field[value="arrows"]').is(':checked') )
			dslcCarArrows = false;

		// Are circles selected?
		if ( ! jQuery('.dslca-module-edit-field[value="circles"]').is(':checked') )
			dslcCarCircles = false;

		// Is it a carousel?
		if ( jQuery('.dslca-module-edit-field[data-id="type"]').val() != 'carousel' ) {
			dslcCarArrows = false;
			dslcCarCircles = false;
		}

		// Is pagination enabled?
		if ( jQuery('.dslca-module-edit-field[data-id="pagination_type"]').val() == 'disabled' ) {
			dslcPagination = false;
		}

		// Is thumb enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="thumbnail"]').is(':checked') ) {
			dslcElThumb = false;
		}

		// Is title enabled?
		if ( jQuery('.dslca-module-edit-field[data-id*="elements"][value="content"]').length && ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="title"]').is(':checked') ) {
			dslcElTitle = false;
		}

		// Is excerpt enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="excerpt"]').is(':checked') ) {
			dslcElExcerpt = false;
		}

		// Is meta enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="meta"]').is(':checked') ) {
			dslcElMeta = false;
		}

		// Is button enabled?
		if ( jQuery('.dslca-module-edit-field[data-id*="elements"][value="button"]').length && ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="button"]').is(':checked') ) {
			dslcElButton = false;
		}

		// Are cats enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="categories"]').is(':checked') ) {
			dslcElCats = false;
		}

		// Is separator enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="separator"]').is(':checked') ) {
			dslcElSeparator = false;
		}

		// Is count enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="count"]').is(':checked') ) {
			dslcElCount = false;
		}

		// Are tags enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="tags"]').is(':checked') ) {
			dslcElTags = false;
		}

		// Are social link enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="social"]').is(':checked') ) {
			dslcElSocial = false;
		}

		// Is position enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="position"]').is(':checked') ) {
			dslcElPosition = false;
		}

		// Is icon enabled?
		if ( jQuery('.dslca-module-edit-field[data-id*="elements"][value="icon"]').length && ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="icon"]').is(':checked') ) {
			dslcElIcon = false;
		}

		// Is content enabled?
		if (  jQuery('.dslca-module-edit-field[data-id*="elements"][value="content"]').length && ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="content"]').is(':checked') ) {
			dslcElContent = false;
		}

		// Is price enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="price"]').is(':checked') ) {
			dslcElPrice = false;
		}

		// Is price secondary enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="price_2"]').is(':checked') ) {
			dslcElPriceSec = false;
		}

		// Is add to cart enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="addtocart"]').is(':checked') ) {
			dslcElAddCart = false;
		}

		// Is add to cart enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="details"]').is(':checked') ) {
			dslcElDetails = false;
		}

		// Is quote enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="quote"]').is(':checked') ) {
			dslcElQuote = false;
		}

		// Is author name enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="author_name"]').is(':checked') ) {
			dslcElAuthorName = false;
		}

		// Is author position enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="author_position"]').is(':checked') ) {
			dslcElAuthorPos = false;
		}

		// Is image enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="image"]').is(':checked') ) {
			dslcElImage = false;
		}

		// Is logo enabled?
		if ( ! jQuery('.dslca-module-edit-field[data-id*="elements"][value="logo"]').is(':checked') ) {
			dslcElLogo = false;
		}


		// Show/Hide Heading
		if ( dslcHeading )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="heading_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="heading_styling"]').hide();

		// Show/Hide Filters
		if ( dslcFilters )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="filters_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="filters_styling"]').hide();

		// Show/Hide Carousel Arrows
		if ( dslcCarArrows )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="carousel_arrows_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="carousel_arrows_styling"]').hide();

		// Show/Hide Carousel Circles
		if ( dslcCarCircles )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="carousel_circles_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="carousel_circles_styling"]').hide();

		// Show/Hide Pagination
		if ( dslcPagination )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="pagination_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="pagination_styling"]').hide();

		// Show/Hide Thumb
		if ( dslcElThumb )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="thumbnail_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="thumbnail_styling"]').hide();

		// Show/Hide Title
		if ( dslcElTitle )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="title_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="title_styling"]').hide();

		// Show/Hide Excerpt
		if ( dslcElExcerpt )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="excerpt_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="excerpt_styling"]').hide();

		// Show/Hide Meta
		if ( dslcElMeta )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="meta_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="meta_styling"]').hide();

		// Show/Hide Button
		if ( dslcElButton )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="button_styling"], .dslca-module-edit-options-tab-hook[data-id="primary_button_styling"],'+
				' .dslca-module-edit-options-tab-hook[data-id="secondary_button_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="button_styling"], .dslca-module-edit-options-tab-hook[data-id="primary_button_styling"],'+
				' .dslca-module-edit-options-tab-hook[data-id="secondary_button_styling"]').hide();

		// Show/Hide Cats
		if ( dslcElCats )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="categories_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="categories_styling"]').hide();

		// Show/Hide Separator
		if ( dslcElSeparator )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="separator_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="separator_styling"]').hide();

		// Show/Hide Count
		if ( dslcElCount )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="count_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="count_styling"]').hide();

		// Show/Hide Tags
		if ( dslcElTags )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="tags_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="tags_styling"]').hide();

		// Show/Hide Tags
		if ( dslcElPosition )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="position_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="position_styling"]').hide();

		// Show/Hide Tags
		if ( dslcElSocial )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="social_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="social_styling"]').hide();

		// Show/Hide Icon
		if ( dslcElIcon )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="icon_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="icon_styling"]').hide();

		// Show/Hide Content
		if ( dslcElContent )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="content_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="content_styling"]').hide();

		// Show/Hide Price
		if ( dslcElPrice )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="price_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="price_styling"]').hide();

		// Show/Hide Price Sec
		if ( dslcElPriceSec )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="price_secondary_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="price_secondary_styling"]').hide();

		// Show/Hide Add to Cart
		if ( dslcElAddCart || dslcElDetails )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="other_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="other_styling"]').hide();

		// Show/Hide Quote
		if ( dslcElQuote )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="quote_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="quote_styling"]').hide();

		// Show/Hide Author Name
		if ( dslcElAuthorName )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="author_name_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="author_name_styling"]').hide();

		// Show/Hide Author Position
		if ( dslcElAuthorPos )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="author_position_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="author_position_styling"]').hide();

		// Show/Hide Image
		if ( dslcElImage )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="image_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="image_styling"]').hide();

		// Show/Hide Quote
		if ( dslcElLogo )
			jQuery('.dslca-module-edit-options-tab-hook[data-id="logo_styling"]').show();
		else
			jQuery('.dslca-module-edit-options-tab-hook[data-id="logo_styling"]').hide();

	}

	/**
	 * Check 'Enable/Disable Custom CSS' control
	 */

	if ( jQuery('.dslca-options-filter-hook[data-section="styling"]').hasClass('dslca-active') ) {

		var dslcCustomCSS = jQuery('.dslca-module-edit-option[data-id="css_custom"]'),
		dslcCustomCSSVal = dslcCustomCSS.find('select').val();

		if ( dslcCustomCSSVal == 'enabled' ) {

			jQuery('.dslca-module-edit-option[data-section="styling"]').css({ visibility : 'visible' });
			jQuery('.dslca-module-edit-option[data-tab]').css( 'visibility', 'visible' );
			jQuery('.dslca-module-edit-options-tabs').show();
		} else {
			jQuery('.dslca-module-edit-option[data-section="styling"]').css({ visibility : 'hidden' });
			jQuery('.dslca-module-control-group.dslca-module-edit-option').css( 'visibility', 'hidden' );
			jQuery('.dslca-module-edit-options-tabs').hide();
			dslcCustomCSS.css({ visibility : 'visible' });
		}

	} else {
		jQuery('.dslca-module-edit-options-tabs').show();
	}

	if ( jQuery('select.dslca-module-edit-field[data-id="css_res_t"]').val() == 'disabled' ) {
		jQuery('.dslca-module-edit-option[data-id*="css_res_t"]').css( 'visibility', 'hidden' );
		jQuery('.dslca-module-edit-option[data-tab="tablet_responsive"]').css( 'visibility', 'hidden' );
	} else {
		jQuery('.dslca-module-edit-option[data-id*="css_res_t"]').css( 'visibility', 'visible' );
		jQuery('.dslca-module-edit-option[data-tab="tablet_responsive"]').css( 'visibility', 'visible' );
	}

	if ( jQuery('select.dslca-module-edit-field[data-id="css_res_p"]').val() == 'disabled' ) {
		jQuery('.dslca-module-edit-option[data-id*="css_res_p"]').css( 'visibility', 'hidden' );
		jQuery('.dslca-module-edit-option[data-tab="phone_responsive"]').css( 'visibility', 'hidden' );
	} else {
		jQuery('.dslca-module-edit-option[data-id*="css_res_p"]').css( 'visibility', 'visible' );
		jQuery('.dslca-module-edit-option[data-tab="phone_responsive"]').css( 'visibility', 'visible' );
	}

	jQuery('.dslca-module-edit-option[data-id="css_res_p"], .dslca-module-edit-option[data-id="css_res_t"]').css( 'visibility', 'visible' );


	if ( jQuery('.dslca-options-filter-hook').hasClass('dslca-active') ) {
		var section_tab = jQuery('.dslca-options-filter-hook.dslca-active').data('section');

		if ( jQuery('.dslca-module-edit-option[data-section="' + section_tab + '"]').hasClass('dep-show') ) {
			jQuery('.dslca-module-edit-option.dep-show').show();
		}

		if ( jQuery('.dslca-module-edit-option[data-section="' + section_tab + '"]').hasClass('dep-hide') ) {
			jQuery('.dslca-module-edit-option.dep-hide').hide();
		}
	}

	if ( jQuery('.dslca-module-edit-options-tab-hook').hasClass('dslca-active') ) {
		var data_tab = jQuery('.dslca-module-edit-options-tab-hook.dslca-active').data('id');

		if ( jQuery('.dslca-module-edit-option[data-tab="' + data_tab + '"]').hasClass('dependent') ) {

			jQuery('.dslca-module-edit-option.dependent').hide();
			jQuery('.dslca-module-edit-option[data-tab="' + data_tab + '"].dep-show').show();
			jQuery('.dslca-module-edit-option[data-tab="' + data_tab + '"].dep-hide').hide();
		} else {

			jQuery('.dslca-module-edit-option.dependent').hide();
		}
	}
	
/* FORCE HIDE TAB BAR WHEN FUNCTIONALITY IS ACTIVE */
function hideFunctionalityTabs() {
    var isFunctionality = jQuery('.dslca-options-filter-hook[data-section="functionality"]').hasClass('dslca-active');

    if (isFunctionality) {
        var wrap = jQuery('.dslca-module-edit-options-tabs');
        
        // Hide the entire tab bar
        wrap.css('display', 'none');

        // Hide all tabs inside it
        wrap.find('.dslca-module-edit-options-tab-hook').css('display', 'none');

        // Remove active class if added
        wrap.find('.dslca-module-edit-options-tab-hook').removeClass('dslca-active');
    }
}

// Run on load
hideFunctionalityTabs();

// Keep hiding even when builder JS updates DOM
var obs = new MutationObserver(hideFunctionalityTabs);
obs.observe(document.body, { childList: true, subtree: true, attributes: true });
}

/**
 * MODULES SETTINGS PANEL - Confirm module options changes
 */
function dslc_module_options_confirm_changes( callback ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_confirm_changes' );

	// Callback
	callback = typeof callback !== 'undefined' ? callback : false;

	// If slider module
	if ( jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument).hasClass('dslc-module-DSLC_Sliders') ) {

		jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');
	// If not slider module
	} else {

		// Add class so we know saving is in progress
		jQuery('body').addClass('dslca-module-saving-in-progress');

		// Reload module with new settings
		(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)( function(){

			// Update preset
			(0,_presets_js__WEBPACK_IMPORTED_MODULE_2__.updatePreset)();

			window.dslc_generate_code();

			jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');

			// Remove classes so we know saving finished
			jQuery('body').removeClass('dslca-module-saving-in-progress');

			// Clean up options container
			jQuery('.dslca-module-edit-options-inner').html('');
			jQuery('.dslca-module-edit-options-tabs').html('');

			window.LiveComposer.Builder.UI.clearUtils();

			// Callback if there's one
			if ( callback ) { callback(); }
		});
	}

		// hide module settings popup
	jQuery("#lc_popup").hide();
	// Show modules listing
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_0__.showSection)('.dslca-modules');

	// Hide the filter hooks
	jQuery('.dslca-header .dslca-options-filter-hook').hide();

	// Hide the save/cancel actions
	jQuery('.dslca-module-edit-actions').hide();

	// Show the section hooks
	jQuery('.dslca-header .dslca-go-to-section-hook').show();

	// window.dslc_generate_code();
	// Show the publish button
	window.dslc_show_publish_button();
	// parent.LiveComposer.Builder.Actions.saveState();
}

/**
 * MODULES SETTINGS PANEL - Cancel module options changes
 */
function dslc_module_options_cancel_changes( callback ) {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_cancel_changes' );

	// Callback
	callback = typeof callback !== 'undefined' ? callback : false;

	// Vars
	var editedModule = jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument);

	// Add backup option values
	jQuery('.dslca-module-options-front', editedModule).html('').append(window.LiveComposer.Builder.moduleBackup);
	// window.LiveComposer.Builder.moduleBackup = false;

	// Reload module
	(0,_module_js__WEBPACK_IMPORTED_MODULE_1__.moduleOutputAltered)( function(){
		window.dslc_generate_code();

		jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-module-being-edited');

		// Clean up options container
		jQuery('.dslca-module-edit-options-inner').html('');
		jQuery('.dslca-module-edit-options-tabs').html('');

		window.LiveComposer.Builder.UI.clearUtils();

		if ( callback ) { callback(); }
	});

	// Hide module settings popup
	jQuery("#lc_popup").hide();
	// Show modules listing
	(0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_0__.showSection)('.dslca-modules');

	// Hide the filter hooks
	jQuery('.dslca-header .dslca-options-filter-hook').hide();

	// Hide the save/cancel actions
	jQuery('.dslca-module-edit-actions').hide();

	// Show the section hooks
	jQuery('.dslca-header .dslca-go-to-section-hook').show();

	// Show the publish button
	window.dslc_show_publish_button();

	window.LiveComposer.Builder.UI.clearUtils();
}

/**
 * MODULES SETTINGS PANEL - Option Tooltips
 */
function dslc_module_options_tooltip() {

	// Close Tooltip
	jQuery(document).on( 'click', '.dslca-module-edit-field-ttip-close', function(){
		jQuery('.dslca-module-edit-field-ttip, .dslca-module-edit-field-icon-ttip').hide();
	});

	// Show Tooltip
	jQuery(document).on( 'click', '.dslca-module-edit-field-ttip-hook', function(){

		var dslcTtip = jQuery('.dslca-module-edit-field-ttip'),
		dslcTtipInner = dslcTtip.find('.dslca-module-edit-field-ttip-inner'),
		dslcHook = jQuery(this),
		dslcTtipContent,
		dslcLabel;

		dslcLabel = dslcHook.parent();

		if ( dslcLabel.parent().hasClass('dslca-modules-section-edit-option') ) {
			dslcTtipContent = dslcHook.closest('.dslca-modules-section-edit-option').find('.dslca-module-edit-field-ttip-content').html();
		} else {
			dslcTtipContent = dslcHook.closest('.dslca-module-edit-option').find('.dslca-module-edit-field-ttip-content').html();
		}

		if ( dslcTtip.is(':visible') ) {

			jQuery('.dslca-module-edit-field-ttip').hide();
		} else {

			dslcTtipInner.html( dslcTtipContent );

			var dslcOffset = dslcHook.offset();
			var dslcTtipHeight = dslcTtip.outerHeight();
			var dslcTtipWidth = dslcTtip.outerWidth();
			var dslcTtipLeft = dslcOffset.left - ( dslcTtipWidth / 2 ) + 6;
			var dslcTtipArrLeft = '50%';

			if ( dslcTtipLeft < 0 ) {

				dslcTtipArrLeft = ( dslcTtipWidth / 2 ) + dslcTtipLeft + 'px';
				dslcTtipLeft = 0;
			}

			jQuery('.dslca-module-edit-field-ttip').show().css({
				top : dslcOffset.top - dslcTtipHeight - 20,
				left: dslcTtipLeft
			});

			jQuery("head").append(jQuery('<style>.dslca-module-edit-field-ttip:after, .dslca-module-edit-field-ttip:before { left: ' + dslcTtipArrLeft + ' }</style>'));
		}
	});

	// Show Tooltip ( Icon Options )
	jQuery(document).on( 'click', '.dslca-module-edit-field-icon-ttip-hook', function(){

		var dslcTtip = jQuery('.dslca-module-edit-field-icon-ttip');
		var dslcHook = jQuery(this);

		if ( dslcTtip.is(':visible') ) {

			jQuery('.dslca-module-edit-field-icon-ttip').hide();
		} else {

			var dslcOffset = dslcHook.offset();
			var dslcTtipHeight = dslcTtip.outerHeight();
			var dslcTtipWidth = dslcTtip.outerWidth();
			var dslcTtipLeft = dslcOffset.left - ( dslcTtipWidth / 2 ) + 6;
			var dslcTtipArrLeft = '50%';

			if ( dslcTtipLeft < 0 ) {

				dslcTtipArrLeft = ( dslcTtipWidth / 2 ) + dslcTtipLeft + 'px';
				dslcTtipLeft = 0;
			}

			jQuery('.dslca-module-edit-field-icon-ttip').show().css({
				top : dslcOffset.top - dslcTtipHeight - 20,
				left: dslcTtipLeft
			});

			jQuery("head").append(jQuery('<style>.dslca-module-edit-field-icon-ttip:after, .dslca-module-edit-field-icon-ttip:before { left: ' + dslcTtipArrLeft + ' }</style>'));
		}
	});
}

/**
 * MODULES SETTINGS PANEL - Font option type
 */
window.dslc_module_options_font = function () {
	// Next Font
	jQuery(document).off( 'click', '.dslca-module-edit-field-font-next' ).on( 'click', '.dslca-module-edit-field-font-next', nextFont );
	function nextFont(e){
		e.preventDefault();

		if ( ! jQuery(this).hasClass('dslca-font-loading') && ! jQuery(this).siblings('.dslca-font-loading').length ) {

			var dslcOption = jQuery(this).closest('.dslca-module-edit-option-font');
			var dslcField = jQuery( '.dslca-module-edit-field-font', dslcOption );
			var dslcCurrIndex = dslcAllFontsArray.indexOf( dslcField.val() );
			var dslcNewIndex = dslcCurrIndex + 1;

			jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text('');

			dslcField.val( dslcAllFontsArray[dslcNewIndex] ).trigger('change');

			jQuery(this).addClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-chevron-right').addClass('dslc-icon-refresh dslc-icon-spin');
		}
	};

	// Previous Font
	jQuery(document).off( 'click', '.dslca-module-edit-field-font-prev' ).on( 'click', '.dslca-module-edit-field-font-prev', prevFont );
	function prevFont(e){

		e.preventDefault();

		if ( ! jQuery(this).hasClass('dslca-font-loading') && ! jQuery(this).siblings('.dslca-font-loading').length ) {

			var dslcOption = jQuery(this).closest('.dslca-module-edit-option-font');
			var dslcField = jQuery( '.dslca-module-edit-field-font', dslcOption );
			var dslcCurrIndex = dslcAllFontsArray.indexOf( dslcField.val() );
			var dslcNewIndex = dslcCurrIndex - 1;

			jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text('');

			if ( dslcNewIndex < 0 ) {

				dslcNewIndex = dslcAllFontsArray.length - 1
			}

			dslcField.val( dslcAllFontsArray[dslcNewIndex] ).trigger('change');

			jQuery(this).addClass('dslca-font-loading').find('.dslca-icon').removeClass('dslc-icon-chevron-left').addClass('dslc-icon-refresh dslc-icon-spin');
		}
	};

	jQuery(document).off( 'blur', '.dslca-module-edit-field-font' ).on( 'blur', '.dslca-module-edit-field-font', onFieldBlur );
	function onFieldBlur(e) {
		var dslcOption = jQuery(this).closest('.dslca-module-edit-option');
		jQuery('.dslca-module-edit-field-font-suggest', dslcOption).hide();
	}

	jQuery(document).off( 'keyup', '.dslca-module-edit-field-font' ).on( 'keyup', '.dslca-module-edit-field-font', onKeyUp );
	// Keyup ( left arrow, right arrow, else )
	function onKeyUp(e) {
		var dslcField, dslcOption, dslcVal, dslcMatchingFont = false, dslcFont;

		dslcField = jQuery(this);
		dslcOption = dslcField.closest('.dslca-module-edit-option');

		// Arrow Up.
		if ( e.which == 38 ) {
			jQuery('.dslca-module-edit-field-font-prev', dslcOption).click();
		}

		// Arrow Down.
		if ( e.which == 40 ) {
			jQuery('.dslca-module-edit-field-font-next', dslcOption).click();
		}

		if ( e.which != 13 && e.which != 38 && e.which != 40 ) {

			dslcVal = dslcField.val();

			var search = [];
			var re = new RegExp('^' + dslcVal, 'i');
			var dslcFontsAmount = dslcAllFontsArray.length;
			var i = 0;

			do {
				if (re.test(dslcAllFontsArray[i])) {
					if ( ! dslcMatchingFont ) {
						var dslcMatchingFont = dslcAllFontsArray[i];
					}
				}
			i++; } while (i < dslcFontsAmount);

			if ( ! dslcMatchingFont ) {
				dslcFont = dslcVal;
				jQuery('.dslca-module-edit-field-font-suggest', dslcOption).hide();
			} else if ( dslcVal !== dslcMatchingFont ) {
				dslcFont = dslcMatchingFont;
				jQuery('.dslca-module-edit-field-font-suggest', dslcOption).show();
			}

			jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text( dslcFont );

			if ( dslcFont.length ){
				dslcField.val( dslcFont.substring( 0 , dslcField.val().length ) );
			}
		}
	};

	jQuery(document).off( 'keydown', '.dslca-module-edit-field-font' ).on( 'keydown', '.dslca-module-edit-field-font', onPushEnter );
	// Key press ( enter = 13 and tab = 9 )
	function onPushEnter(e) {
		if ( e.which == 13 || e.which == 9 ) {
			var dslcField, dslcOption, dslcVal, dslcMatchingFont, dslcFont;

			dslcField = jQuery(this);
			dslcOption = dslcField.closest('.dslca-module-edit-option');

			var suggestedFont = jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text();

			if ( suggestedFont.length ) {
				jQuery(this).val( jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text() ).trigger('change');
				jQuery('.dslca-module-edit-field-font-suggest', dslcOption).text('');
			}
		}
	};
}

/*
 * MODULES SETTINGS PANEL - Change icon code based on direction (next/previous)
 */
function dslc_list_icon( object, direction ) {

	var dslcOption = jQuery(object).closest('.dslca-module-edit-option-icon');
	var dslcField = jQuery( '.dslca-module-edit-field-icon', dslcOption );
	var dslcCurrIndex = dslcIconsCurrentSet.indexOf( dslcField.val() );

	if ( direction == 'previous' ) {

		var dslcNewIndex = dslcCurrIndex - 1;
	} else {

		var dslcNewIndex = dslcCurrIndex + 1;
	}

	jQuery('.dslca-module-edit-field-icon-suggest', dslcOption).text('');

	if ( dslcNewIndex < 0 ) {

		dslcNewIndex = dslcIconsCurrentSet.length - 1
	}

	dslcField.val( dslcIconsCurrentSet[dslcNewIndex] ).trigger('change');
}

/**
 * MODULES SETTINGS PANEL - Icon option type
 */
function dslc_module_options_icon() {

	// Key Up ( arrow up, arrow down, else )

	jQuery(document).on( 'keyup', '.dslca-module-edit-field-icon', function(e) {

		var dslcField, dslcOption, dslcVal, dslcIconsArrayGrep, dslcIcon;

		dslcField = jQuery(this);
		dslcOption = dslcField.closest('.dslca-module-edit-option');

		// Key pressed: arrow up
		if ( e.which == 38 ) {

			dslc_list_icon(dslcField,'previous');
		}

		// Key pressed: arrow down
		if ( e.which == 40 ) {

			dslc_list_icon(dslcField,'next');
		}

		if ( e.which != 13 && e.which != 38 && e.which != 40 ) {

			dslcVal = dslcField.val().toLowerCase();
			dslcField.val( dslcVal );

			dslcIconsArrayGrep = jQuery.grep(dslcIconsCurrentSet, function(value, i) {
				return ( value.indexOf( dslcVal ) == 0 );
			});

			dslcIcon = dslcIconsArrayGrep[0];

			jQuery('.dslca-module-edit-field-icon-suggest', dslcOption).text( dslcIcon );
		}
	});

	// Key Press ( Enter )

	jQuery(document).on( 'keypress', '.dslca-module-edit-field-icon', function(e) {

		if ( e.which == 13 ) {

			e.preventDefault();

			var dslcField, dslcOption, dslcVal, dslcIconsArrayGrep, dslcIcon;

			dslcField = jQuery(this);
			dslcOption = dslcField.closest('.dslca-module-edit-option');

			jQuery(this).val( jQuery('.dslca-module-edit-field-icon-suggest', dslcOption).text() ).trigger('change');

			jQuery('.dslca-module-edit-field-icon-suggest', dslcOption).text('');
		}
	});
}

/**
 * MODULES SETTINGS PANEL - return options id
 */
function dslc_module_options_icon_returnid() {

	jQuery(document).on('click', '.dslca-open-modal-hook[data-modal^=".dslc-list-icons"]', function(el) {
		jQuery(this).closest('.dslca-module-edit-option-icon').find('input').addClass('icon-modal-active');
	});

	jQuery(document).on('click', '.dslca-modal-icons .icon-item', function(el) {

		// Get selected item code
		var selectedIconCode = jQuery(this).find('.icon-item_name').text();
		jQuery('input.icon-modal-active').val(selectedIconCode).change();

		// Close modal window
		(0,_modalwindow_js__WEBPACK_IMPORTED_MODULE_3__.hideModal)( '', jQuery('.dslca-modal:visible') );
		jQuery('input.icon-modal-active').removeClass('icon-modal-active');
	});
}

/**
 * MODULES SETTINGS PANEL - Text align option type
 */
function dslc_module_options_text_align() {

	jQuery(document).on( 'click', '.dslca-module-edit-option-text-align-hook', function(){

		var newOpt = jQuery(this),
		otherOpt = jQuery(this).closest('.dslca-module-edit-option-text-align-wrapper').find('.dslca-module-edit-option-text-align-hook'),
		newVal = newOpt.data('val'),
		realOpt = jQuery(this).closest('.dslca-module-edit-option-text-align-wrapper').siblings('input.dslca-module-edit-field');

		otherOpt.removeClass('dslca-active');
		newOpt.addClass('dslca-active');

		realOpt.val( newVal ).trigger('change');
	});
}

/**
 * MODULES SETTINGS PANEL - Checkbox Option Type
 */
function dslc_module_options_checkbox() {

	jQuery(document).on( 'click', '.dslca-module-edit-option-checkbox-hook, .dslca-modules-section-edit-option-checkbox-hook', function(){

		var checkFake = jQuery(this);
		var checkReal = checkFake.siblings('input[type="checkbox"]');

		if ( checkReal.attr('checked') ) {
			checkReal.attr('checked', false);
			checkFake.find('.dslca-icon').removeClass('dslc-icon-check').addClass('dslc-icon-check-empty');
		} else {
			checkReal.attr('checked', true);
			checkFake.find('.dslca-icon').removeClass('dslc-icon-check-empty').addClass('dslc-icon-check');
		}

		checkReal.change();
	});
}

/**
 * MODULES SETTINGS PANEL - Box Shadow Option Type
 */
function dslc_module_options_box_shadow() {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_box_shadow' );

	/**
	 * Value Change
	 */

	jQuery(document).on( 'change', '.dslca-module-edit-option-box-shadow-hor, '+
		'.dslca-module-edit-option-box-shadow-ver, .dslca-module-edit-option-box-shadow-blur, .dslca-module-edit-option-box-shadow-spread,'+
		' .dslca-module-edit-option-box-shadow-color, .dslca-module-edit-option-box-shadow-inset', function(){

		var boxShadowWrapper = jQuery(this).closest('.dslca-module-edit-option'),
		boxShadowInput = boxShadowWrapper.find('.dslca-module-edit-field'),
		boxShadowHor = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-hor').val(),
		boxShadowVer = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-ver').val(),
		boxShadowBlur = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-blur').val(),
		boxShadowSpread = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-spread').val(),
		boxShadowColor = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-color').val(),
		boxShadowInset = boxShadowWrapper.find('.dslca-module-edit-option-box-shadow-inset').is(':checked');

		if ( boxShadowInset ) { boxShadowInset = ' inset'; } else { boxShadowInset = ''; }

		var boxShadowVal = boxShadowHor + 'px ' + boxShadowVer + 'px ' + boxShadowBlur + 'px ' + boxShadowSpread + 'px ' + boxShadowColor + boxShadowInset;

		boxShadowInput.val( boxShadowVal ).trigger('change');
	});
}

/**
 * MODULES SETTINGS PANEL - Text Shadow Option Type
 */
function dslc_module_options_text_shadow() {

	if ( window.dslcDebug ) console.log( 'dslc_module_options_text_shadow' );

	/**
	 * Value Change
	 */

	jQuery(document).on( 'change', '.dslca-module-edit-option-text-shadow-hor, .dslca-module-edit-option-text-shadow-ver,'+
		'.dslca-module-edit-option-text-shadow-blur, .dslca-module-edit-option-text-shadow-color', function(){

		var textShadowWrapper = jQuery(this).closest('.dslca-module-edit-option'),
		textShadowInput = textShadowWrapper.find('.dslca-module-edit-field'),
		textShadowHor = textShadowWrapper.find('.dslca-module-edit-option-text-shadow-hor').val(),
		textShadowVer = textShadowWrapper.find('.dslca-module-edit-option-text-shadow-ver').val(),
		textShadowBlur = textShadowWrapper.find('.dslca-module-edit-option-text-shadow-blur').val(),
		textShadowColor = textShadowWrapper.find('.dslca-module-edit-option-text-shadow-color').val();

		var textShadowVal = textShadowHor + 'px ' + textShadowVer + 'px ' + textShadowBlur + 'px ' + textShadowColor;

		textShadowInput.val( textShadowVal ).trigger('change');
	});
}

/**
 * MODULES SETTINGS PANEL - Color Option Type
 */
function dslc_module_options_color(field) {

	if (window.dslcDebug) console.log('dslc_module_options_color');

	var dslcColorField,
		dslcAffectOnChangeEl,
		dslcAffectOnChangeRule,
		dslcColorFieldVal,
		dslcModule,
		dslcOptionID,
		dslcCurrColor;

	var dslcColorPallete = [],
		currStorage,
		index;

	var palleteCurrentDommain = 'dslcColors-' + document.domain;

	// Load recent colors
	if (undefined !== localStorage[palleteCurrentDommain]) {
		currStorage = JSON.parse(localStorage[palleteCurrentDommain]);
		dslcColorPallete = currStorage;
	}

	if (1 > dslcColorPallete.length) dslcColorPallete.push('#78b');
	if (2 > dslcColorPallete.length) dslcColorPallete.push('#ab0');
	if (3 > dslcColorPallete.length) dslcColorPallete.push('#de3');

	dslcColorPallete.push('#fff');
	dslcColorPallete.push('#000');
	dslcColorPallete.push('rgba(0,0,0,0)');

	var query = field;

	jQuery(query).each(function () {

		var wrapper = jQuery(this).closest('.dslca-color-option');
		var input = jQuery(this);

        dslcCurrColor = jQuery(this).val();

		// INIT WP COLOR PICKER
		input.wpColorPicker({
			mode: 'hsl',
			palettes: dslcColorPallete,
			change: function (event, ui) {

				dslcColorField = input;

				var color = input.wpColorPicker('color');
				dslcColorFieldVal = color == null ? '' : color;

				// Update value
				dslcColorField.val(dslcColorFieldVal).trigger('change');

				// Update background
				dslcColorField.css('background', dslcColorFieldVal);

				// Live update
				dslcAffectOnChangeEl = dslcColorField.data('affect-on-change-el');
				dslcAffectOnChangeRule = dslcColorField.data('affect-on-change-rule');

				if (dslcAffectOnChangeEl && dslcAffectOnChangeEl !== '.dslca-modules-section-being-edited') {
					jQuery(
						dslcAffectOnChangeEl,
						window.LiveComposer.Builder.PreviewAreaDocument.find('.dslca-module-being-edited')
					).css(dslcAffectOnChangeRule, dslcColorFieldVal);
				}

				// Update option in module
				dslcModule = jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument);
				dslcOptionID = dslcColorField.data('id');
				jQuery('.dslca-module-option-front[data-id="' + dslcOptionID + '"]', dslcModule).val(dslcColorFieldVal);

				dslcModule.addClass('dslca-module-change-made');
			}
		});

		// ADD APPLY BUTTON
		var colorPickerPopup = wrapper.find('.wp-picker-holder .iris-picker');
		colorPickerPopup.append('<button type="button" class="dslca-colorpicker-apply">Apply</button>');

		var apply = wrapper.find('.dslca-colorpicker-apply');

		input.wpColorPicker('open');

		// APPLY LOGIC
		jQuery(apply).on('click', function () {

			if (
				dslcColorFieldVal !== '#fff' &&
				dslcColorFieldVal !== '#ffffff' &&
				dslcColorFieldVal !== '#000' &&
				dslcColorFieldVal !== '#000000' &&
				dslcColorFieldVal !== 'rgba(0,0,0,0)'
			) {
				if (undefined === localStorage[palleteCurrentDommain]) {
					var newStorage = [dslcColorFieldVal];
					localStorage[palleteCurrentDommain] = JSON.stringify(newStorage);
				} else {
					var newStorage = JSON.parse(localStorage[palleteCurrentDommain]);

					if (newStorage.indexOf(dslcColorFieldVal) == -1) {
						newStorage.unshift(dslcColorFieldVal);
						if (newStorage.length > 3) newStorage.pop();
					}
					localStorage[palleteCurrentDommain] = JSON.stringify(newStorage);
				}
			}

			// input.wpColorPicker('close');
		});
		//  *  CLEAR BUTTON SUPPORT
		 
		var clearBtn = wrapper.find('.wp-picker-clear');

		jQuery(clearBtn).on('click', function () {

			dslcColorFieldVal = '';

			// Clear input
			input.val('').trigger('change');

			// Remove color preview
			input.css('background', '');

			// Live preview clear
			const el = input.data('affect-on-change-el');
			const rule = input.data('affect-on-change-rule');

			if (el && el !== '.dslca-modules-section-being-edited') {
				jQuery(
					el,
					window.LiveComposer.Builder.PreviewAreaDocument.find('.dslca-module-being-edited')
				).css(rule, '');
			}

			// Update module option
			var module = jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument);
			var optionID = input.data('id');

			jQuery('.dslca-module-option-front[data-id="' + optionID + '"]', module).val('');

			// Mark as changed
			module.addClass('dslca-module-change-made');

			// Close color picker
			// input.wpColorPicker('close');
		});
		/** --------------------------------------------- */


		// Save this element to destroy later
		window.LiveComposer.Builder.Helpers.colorpickers.push(jQuery(this));
	});
}


/**
 * MODULES SETTINGS PANEL - Numeric Option Type
 */
function dslc_module_options_numeric( fieldWrapper ) {
	if ( window.dslcDebug ) console.log( 'dslc_module_options_numeric' );

	var query = fieldWrapper; // || '.dslca-module-edit-option-slider';

	jQuery(query).each(function(){

		var controlWrapper = jQuery(this);

		// /* Create an empty div to be uses by jQuery as the slider container. */
		// if ( 0 === jQuery('.dslca-module-edit-field-slider', controlWrapper).length ) {
		// 	controlWrapper.append('<div class="dslca-module-edit-field-slider"></div>');
		// }

		var workingWithModule = true;

		/* Is the control part of the module setting panel or section settings? */
		if ( controlWrapper.hasClass('dslca-modules-section-edit-option') ) {
			// We are working with seciton.
			workingWithModule = false;
		} else {
			// We are working with module.
			workingWithModule = true;
		}

		if ( workingWithModule ) {
			var sliderInput = controlWrapper.find('.dslca-module-edit-field');
		} else {
			var sliderInput = controlWrapper.find('.dslca-modules-section-edit-field');
		}

		/* Is the control part of the module setting panel or section settings? */
		if ( controlWrapper.hasClass('dslca-modules-section-edit-option') ) {
			// We are working with seciton.
			var sliderInput = controlWrapper.find('.dslca-modules-section-edit-field');
		} else {
			// We are working with module.
			var sliderInput = controlWrapper.find('.dslca-module-edit-field');
		}

		var sliderExt = '',
		sliderControl = controlWrapper.find('.dslca-module-edit-field-slider'),
		currentVal    = parseFloat( sliderInput.val() ),

		// Max value. By default max is 100.
		max = parseFloat( sliderInput.attr('max') ?? sliderInput.data('max') ),
		
		// Min value. By default min is 0.
		min = parseFloat( sliderInput.attr('min') ?? sliderInput.data('min') ),
		// Increment value. By default increment is 1.
		inc = parseFloat( sliderInput.data('increment') ),
		// Backup values.
		max_orig = max,
		min_orig = min;

		/**
		 * Check if value can't be negative according to module settings.
		 */
		var onlypositive = false;

		if ( undefined !== sliderInput.data('onlypositive') && 1 === sliderInput.data('onlypositive')  ) {
			onlypositive = true;
		}		


		if( sliderInput[0].classList.contains('slider-initiated') ) return;
		sliderInput[0].classList.add("slider-initiated");

		sliderInput.on('keyup', function(e){

			// In some rare cases we have the next error:
			// TypeError: undefined is not an object (evaluating 'a.key.match')
			if (undefined === e) {
				return false;
			}

			// Shift + Up/Down
			if( e.shiftKey ) {

				if( e.keyCode == 38 ) {
					this.value = ( parseInt(this.value) || 0 ) + 9;
					sliderInput.trigger('change');
				}

				if( e.keyCode == 40 ) {
					this.value = ( parseInt(this.value) + 0 ) - 9;
					sliderInput.trigger('change');
				}
			}

			// Backspace, "-"
			if( e.keyCode == 8 || e.keyCode == 45 ) {
				sliderInput.trigger('change');
			}

			// If number key pressed
			if ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105)) {
				sliderInput.trigger('change');
			}

			var charCode = (e.which) ? e.which : e.keyCode;

			//@todo more work here
			if( ( (charCode >= 48 && charCode <= 57) || (charCode >= 96 && charCode <= 105) ) && e.keyCode != 8 && e.keyCode != 39 && e.keyCode != 37 && e.keyCode != 46 ) {
				return false;
			}
		});

		// sliderInput.unbind('change');
		sliderInput.on('change', function(e){

			var val = parseFloat(this.value) || 0;

			// Detect extension (px, %, etc.)
			var ext = sliderInput.data('ext');

			let min, max;

			if (ext === '%') {
				// For percentage, restrict to -100..100
				min = -100;
				max = 100;
			} else if (ext === 'px') {
				// For px, use data-min and data-max
				min = parseFloat(sliderInput.data('min'));
				max = parseFloat(sliderInput.data('max'));
			} else {
				// Fallback (optional)
				min = parseFloat(sliderInput.attr('min') ?? sliderInput.data('min'));
				max = parseFloat(sliderInput.attr('max') ?? sliderInput.data('max'));
			}

			// Only positive rule
			if (onlypositive && val < 0) {
				val = 0;
			}

			// Apply min / max restriction
			if (!isNaN(min) && val < min) {
				val = min;
			}

			if (!isNaN(max) && val > max) {
				val = max;
			}

			// Write corrected value back
			this.value = val;
			var containerWrapper;

			if ( workingWithModule ) {
				containerWrapper = jQuery( e.target.closest('.dslca-module-edit-option-slider') );
			} else {
				containerWrapper = jQuery( e.target.closest('.dslca-modules-section-edit-option-slider') );
			}

			/**
			 * Move the slider needle to reflect the value changes
			 * made via direct input of via keyboard arrow keys.
			 */
			// var currentSliderInstance = containerWrapper.find('.dslca-module-edit-field-slider');
			// if ( undefined !== currentSliderInstance.slider( 'instance' ) ) {
			// 	currentSliderInstance.slider( 'value', this.value );
			// }

			if ( workingWithModule ) {
				// Add changed class to the module.
				var module = jQuery('.dslca-module-being-edited', window.LiveComposer.Builder.PreviewAreaDocument);
				module.addClass('dslca-module-change-made');
			}
		});
		// sliderInput.on('input', function() {
		// 	sliderInput.trigger('change');
		// });

		return false;
	}); // .each
}

function dslc_disable_responsive_view () {
	jQuery('html').removeClass('dslc-responsive-preview');
	jQuery('body').removeClass('dslc-res-big dslc-res-smaller-monitor dslc-res-phone dslc-res-tablet');

}


function dslc_filter_module_options( sectionID ) { dslc_module_options_section_filter( sectionID ); }
function dslc_confirm_changes( callback ) { dslc_module_options_confirm_changes( callback ); }
function dslc_cancel_changes( callback ) { dslc_module_options_cancel_changes( callback ); }
function dslc_init_colorpicker() { dslc_module_options_color(); }
function dslc_init_options_slider() { dslc_module_options_numeric(); }
function dslc_module_edit_options_hideshow_tabs() { dslc_module_options_hideshow_tabs(); }

/***/ }),

/***/ "./js/src/editor/backend/templates.js":
/*!********************************************!*\
  !*** ./js/src/editor/backend/templates.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   templatesPanelInit: () => (/* binding */ templatesPanelInit)
/* harmony export */ });
/* harmony import */ var _sections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sections.js */ "./js/src/editor/backend/sections.js");
/* harmony import */ var _dragndrop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dragndrop.js */ "./js/src/editor/backend/dragndrop.js");
/* harmony import */ var _modulearea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modulearea.js */ "./js/src/editor/backend/modulearea.js");
/* harmony import */ var _modalwindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modalwindow.js */ "./js/src/editor/backend/modalwindow.js");
/*********************************
 *
 * = TEMPLATES =
 *
 * - dslc_load_template ( Load Template )
 * - dslc_import_template ( Import Template )
 * - dslc_save_template ( Save TEmplate )
 * - dslc_delete_template ( Delete Template )
 *
 ***********************************/






/**
 * TEMPLATES - Load
 */
const loadTemplateById = ( template ) => {

	if ( window.dslcDebug ) console.log( 'dslc_load_template' );

	// Vars
	var dslcModule, dslcModuleID;

	// Template preloader
	jQuery('#wpcontent').prepend('<div class="lc-template-loader"></div>');

	var block = '<div class="lc-loader lds-css"><div class="lds-spinner"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>';

	jQuery('.lc-template-loader').prepend(block);


	// Ajax call to get template's HTML
	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-load-template',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_template_id : template
		},
		function( response ) {

			// Apply the template's HTML
			jQuery('#dslc-main', LiveComposer.Builder.PreviewAreaDocument).html( response.output );

			jQuery('.lc-template-loader').remove();

			// Call other functions
			LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();

			// Check init for rows and module areas
			(0,_sections_js__WEBPACK_IMPORTED_MODULE_0__.sectionsInitJS)();
			(0,_modulearea_js__WEBPACK_IMPORTED_MODULE_2__.moduleareasInitJS)();

			(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_1__.dragAndDropInit)();
			window.dslc_show_publish_button();
			window.dslc_generate_code();
			parent.LiveComposer.Builder.Actions.saveState();
		}
	);
}

/**
 * TEMPLATES - Import
 */
function dslc_template_import() {

	if ( window.dslcDebug ) console.log( 'dslc_import_template' );

	// Vars
	var dslcModule, dslcModuleID;

	// Hide the title on the button and show loading animation
	jQuery('.dslca-modal-templates-import .dslca-modal-title').css({ opacity : 0 });
	jQuery('.dslca-modal-templates-import .dslca-loading').show();

	// Ajax call to load template's HTML
	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-import-template',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_template_code : jQuery('#dslca-import-code').val()
		},
		function( response ) {

			// Apply the template's HTML
			jQuery('#dslc-main', LiveComposer.Builder.PreviewAreaDocument).html( response.output );

			// Hide the loading on the button and show the title
			jQuery('.dslca-modal-templates-import .dslca-loading').hide();
			jQuery('.dslca-modal-templates-import .dslca-modal-title').css({ opacity : 1 });

			// Hide the modal
			(0,_modalwindow_js__WEBPACK_IMPORTED_MODULE_3__.hideModal)( '', '.dslca-modal-templates-import' );

			// Call other functions
			LiveComposer.Builder.PreviewAreaWindow.dslc_bg_video();
			(0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_1__.dragAndDropInit)();
			window.dslc_show_publish_button();
			window.dslc_generate_code();
			parent.LiveComposer.Builder.Actions.saveState();
		}
	);
}

/**
 * TEMPLATES - SAVE
 */
function dslc_template_save() {
	if ( window.dslcDebug ) console.log( 'dslc_save_template' );

	// AJAX call to save the template
	jQuery.post(
		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-save-template',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_template_code : jQuery('#dslca-code').val(),
			dslc_template_title : jQuery('#dslca-save-template-title').val()
		},
		function( response ) {
			// Hide the modal
			(0,_modalwindow_js__WEBPACK_IMPORTED_MODULE_3__.hideModal)( '', '.dslca-modal-templates-save' );
		}
	);
}

/**
 * TEMPLATES - DELETE
 */
function dslc_template_delete( template ) {

	if ( window.dslcDebug ) console.log( 'dslc_delete_template' );

	// AJAX call to delete template
	jQuery.post(

		DSLCAjax.ajaxurl,
		{
			action : 'dslc-ajax-delete-template',
			_wpnonce : DSLCAjax._wpnonce,
			dslc : 'active',
			dslc_template_id : template
		},
		function( response ) {

			// Remove template from the template listing
			jQuery('.dslca-template[data-id="' + template + '"]').fadeOut(200, function(){
				jQuery(this).remove();
				parent.LiveComposer.Builder.Actions.saveState();
			});
		}
	);
}

/**
 * Deprecated Functions and Fallbacks
 */
 function dslc_import_template() { dslc_template_import(); }
 function dslc_save_template() { dslc_template_save(); }
 function dslc_delete_template( template ) { dslc_template_delete( template ); }

 /**
  * TEMPLATES - Document Ready
  */

 const templatesPanelInit = () => {

	/**
	 * Hook - Load Template
	 */
	let templateItem = document.querySelectorAll('.dslca-template');
	// Attach import function to each template item.
	templateItem.forEach(function(element) {
		element.addEventListener('click', event => {
			event.preventDefault();
			let importButton = event.target.closest("[data-id]");
			loadTemplateById( importButton.dataset.id );
		});
	});

	/**
	 * Hook - Import Template
	 */
	jQuery('.dslca-template-import-form').submit(function(e){
		e.preventDefault();
		dslc_template_import();
	});

	/**
	 * Hook - Save Template
	 */
	jQuery('.dslca-template-save-form').submit(function(e){
		e.preventDefault();
		dslc_template_save();
	});

	/**
	 * Hook - Delete Template
	 */
	jQuery(document).on( 'click', '.dslca-delete-template-hook', function(e){

		e.stopPropagation();
		dslc_template_delete( jQuery(this).data('id') );
	});

}


/***/ }),

/***/ "./js/src/editor/backend/uigeneral.js":
/*!********************************************!*\
  !*** ./js/src/editor/backend/uigeneral.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fixContenteditable: () => (/* binding */ fixContenteditable),
/* harmony export */   hidePublishButton: () => (/* binding */ hidePublishButton),
/* harmony export */   keypressEvents: () => (/* binding */ keypressEvents),
/* harmony export */   showSection: () => (/* binding */ showSection)
/* harmony export */ });
/* harmony import */ var _settings_panel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.panel.js */ "./js/src/editor/backend/settings.panel.js");
/* harmony import */ var _modalwindow_class_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modalwindow.class.js */ "./js/src/editor/backend/modalwindow.class.js");
/* harmony import */ var _codegeneration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./codegeneration.js */ "./js/src/editor/backend/codegeneration.js");
/* harmony import */ var _popup_drag_resize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./popup-drag-resize.js */ "./js/src/editor/backend/popup-drag-resize.js");
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");
/*********************************
 *
 * = UI - GENERAL =
 *
 * - dslc_hide_composer ( Hides the composer elements )
 * - dslc_show_composer ( Shows the composer elements )
 * - dslc_show_publish_button ( Shows the publish button )
 * - dslc_show_section now showSection ( Show a specific section )
 * - dslc_generate_filters ( Generate origin filters )
 * - dslca-search-modules ( Search Modules )
 * - dslc_filter_origin ( Origin filtering for templates/modules listing )
 * - dragAndDropInit ( Initiate drag and drop functionality )
 ***********************************/




 



/**
 * Try to detect JS errors in WP Admin part.
 */
 window.onerror = function( error, file, line, char ) {

	dslca_generate_error_report ( error, file, line, char );
}

/**
 * Hook - Open Error Log button
 */
jQuery(document).on( 'click', '.dslca-show-js-error-hook', function(e){

	e.preventDefault();

	var errors_container = document.getElementById('dslca-js-errors-report');

	if ( ! jQuery('body').hasClass('dslca-saving-in-progress') ) {

		(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_1__.CModalWindow)({

			title: '<a href="https://livecomposerplugin.com/support/" target="_blank"><span class="dslca-icon dslc-icon-comment"></span> &nbsp; Get Support Info</a>',
			content: '<span class="dslca-error-report">' + errors_container.value + '</span>',
		});
	}
});


/**
 * UI - GENERAL - Document Ready
 */

jQuery(document).ready(function($) {

	/**
	 * Try to detect JS errors in preview area.
	 */
	jQuery("#page-builder-frame")[0].contentWindow.onerror = function( error, file, line, char ) {
		dslca_generate_error_report ( error, file, line, char );
	}

	// Put JS error log data in a hidden textarea.
	dslca_update_report_log();

 	jQuery('body').addClass('dslca-enabled dslca-drag-not-in-progress');
 	jQuery('.dslca-invisible-overlay').hide();
 	jQuery('.dslca-section').eq(0).show();
});

/**
 * Action - "Currently Editing" scroll on click
 */

jQuery(document).on( 'click', '.dslca-currently-editing', function(){

	var activeElement = false,
	newOffset = false,
	outlineColor;

	if ( jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).length ) {

		activeElement = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument);
		outlineColor = '#5890e5';

	} else if ( jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument).length ) {

		activeElement = jQuery('.dslca-modules-section-being-edited', LiveComposer.Builder.PreviewAreaDocument);
		outlineColor = '#eabba9';
	}

	if ( activeElement ) {
		newOffset = activeElement.offset().top - 100;
		if ( newOffset < 0 ) { newOffset = 0; }

		var callbacks = [];

		jQuery( 'html, body', LiveComposer.Builder.PreviewAreaDocument ).animate({ scrollTop: newOffset }, 300, function(){
			activeElement.removeAttr('style');
		});
	}

});

/**
 * Save composer code with CMD+S or Ctrl+S
 */
jQuery(window).keypress( function(e){

	if ((e.metaKey || e.ctrlKey) && e.keyCode == 83) {

		dslc_ajax_save_composer();
		e.preventDefault();
        return false;
	}
});

/**
 * Hook - Hide Composer
 */

jQuery(document).on( 'click', '.dslca-hide-composer-hook', function(e){

	e.preventDefault();
	dslc_hide_composer()
});

/**
 * Hook - Show Composer
 */

jQuery(document).on( 'click', '.dslca-show-composer-hook', function(e){
	e.preventDefault();
	dslc_show_composer();
});

/**
 * Hook - Section Show - Modules Listing
 */

jQuery(document).on( 'click', '.dslca-go-to-modules-hook', function(e){
	e.preventDefault();
	showSection( '.dslca-modules' );
});

/**
 * Hook - Section Show - Dynamic
 */

jQuery(document).on( 'click', '.dslca-go-to-section-hook', function(e){

	e.preventDefault();

	// Do nothing if clicked on active tab
	if ( jQuery(this).hasClass('dslca-active') ) {

		return;
	}

	var sectionTitle = jQuery(this).data('section');
	showSection( sectionTitle );

	if ( jQuery(this).hasClass('dslca-go-to-section-modules') || jQuery(this).hasClass('dslca-go-to-section-templates')  ) {

		jQuery(this).addClass('dslca-active').siblings('.dslca-go-to-section-hook').removeClass('dslca-active');
	}
});

/**
 * Hook - Close Composer
 */

jQuery(document).on( 'click', '.dslca-close-composer-hook', function(e){

	e.preventDefault();

	var redirect_url = jQuery(this).attr('href');

	if ( ! jQuery('body').hasClass('dslca-saving-in-progress') && jQuery('.dslca-save-composer').is(':visible') ) {
		// Show warning if changes weren't saved.
		(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_1__.CModalWindow)({

			title: DSLCString.str_exit_title,
			content: DSLCString.str_exit_descr,
			confirm: function() {
				window.location = redirect_url;
			}
		});
	} else {
		window.location = redirect_url;
	}
});

/**
 * Submit Form
 */

jQuery(document).on( 'click', '.dslca-submit', function(){
	jQuery(this).closest('form').submit();
});

/**
 * Hook - Show Origin Filters
 */

jQuery(document).on( 'click', '.dslca-section-title', function(e){

	e.stopPropagation();

	if ( jQuery('.dslca-section-title-filter', this).length ) {

		dslc_generate_filters();

		// Open filter panel
		jQuery('.dslca-section-title-filter-options').slideToggle(300);
	}
});
/**
 * Hook - Search Modules
 */

jQuery(document).on( 'input', '.dslca-search-modules', function(e){

	var searchValue = jQuery(this).val().toLowerCase();
	var modules = jQuery('.dslca-sections .dslca-modules .dslca-section-scroller .dslca-section-scroller-inner .dslca-section-scroller-content');
	var filterValue = jQuery(".dslca-sections .dslca-modules .dslca-section-title .dslca-section-title-filter-curr").text();
	if(filterValue == "Elements" || filterValue == "Show All")
	{
		if(searchValue == "")
		{
		jQuery(".dslca-origin", modules).attr("data-display-module", "true");  
		}
		else
		{
		jQuery(".dslca-origin", modules).attr("data-display-module", "false");
		modules.children().each(function () {
			var title = jQuery(this).children(".dslca-module-title").text().toLowerCase();
			if (title.includes(searchValue))
			{
			this.dataset.displayModule = "true";
			}
		});
		}
	}
	else
	{
		if(searchValue == "")
		{
			jQuery('.dslca-origin[data-origin="' + filterValue + '"]', modules).attr("data-display-module", "true");  
		}
		else
		{
			jQuery('.dslca-origin', modules).attr("data-display-module", "false");
			modules.children().each(function () {
			var title = jQuery(this).children(".dslca-module-title").text().toLowerCase();
			if (title.includes(searchValue) && jQuery(this).attr("data-origin") == filterValue)
			{
				this.dataset.displayModule = "true";
			}
			});
		}
	}

});

/**
 * Hook - Apply Filter Origin
 */

jQuery(document).on( 'click', '.dslca-section-title-filter-options a', function(e){

	e.preventDefault();
	e.stopPropagation();

	var origin = jQuery(this).data('origin');
	var section = jQuery(this).closest('.dslca-section');
	// blank search field on filter change
	jQuery('.dslca-search-modules').val("");

	if ( section.hasClass('dslca-templates-load') ) {
		jQuery('.dslca-section-title-filter-curr', section).text( jQuery(this).text());
	} else {
		jQuery('.dslca-section-title-filter-curr', section).text( jQuery(this).text());
	}

	// jQuery('.dslca-section-scroller-inner').css({ left : 0 });
	jQuery(this).parent().siblings('.dslca-icon').toggleClass('dslc-icon-angle-up dslc-icon-angle-down');

	dslc_filter_origin( origin, section );

	// Close filter panel
	jQuery('.dslca-section-title-filter-options').slideToggle(300);
});


/**
 * UI - GENERAL - Hide Composer
 */

function dslc_hide_composer() {

	if ( window.dslcDebug ) console.log( 'dslc_hide_composer' );

	// Hide "hide" button and show "show" button
	jQuery('.dslca-hide-composer-hook').hide();
	jQuery('.dslca-show-composer-hook').show();

	// Add class to know it's hidden
	jQuery('body').addClass('dslca-composer-hidden');
	jQuery('body', LiveComposer.Builder.PreviewAreaDocument).addClass('dslca-composer-hidden');
	LiveComposer.Builder.Flags.uiHidden = true;


	// Hide ( animation ) the main composer area ( at the bottom )
	jQuery('.dslca-container').css({ bottom : jQuery('.dslca-container').outerHeight() * -1 });

	// Hide the header  part of the main composer area ( at the bottom )
	jQuery('.dslca-header').hide();

}

/**
 * UI - GENERAL - Show Composer
 */

function dslc_show_composer() {

	if ( window.dslcDebug ) console.log( 'dslc_show_composer' );

	// Hide the "show" button and show the "hide" button
	jQuery('.dslca-show-composer-hook').hide();
	jQuery('.dslca-hide-composer-hook').show();

	// Remove the class from the body so we know it's not hidden
	jQuery('body').removeClass('dslca-composer-hidden');
	jQuery('body', LiveComposer.Builder.PreviewAreaDocument).removeClass('dslca-composer-hidden');
	LiveComposer.Builder.Flags.uiHidden = false;


	// Show ( animate ) the main composer area ( at the bottom )
	jQuery('.dslca-container').css({ bottom : 0 });

	// Show the header of the main composer area ( at the bottom )
	jQuery('.dslca-header').show();
}

/**
 * UI - GENERAL - Show Publish Button
 */

window.dslc_show_publish_button = function() {

	if ( window.dslcDebug ) console.log( 'dslc_show_publish_button' );

	jQuery('.dslca-save-composer').show().addClass('dslca-init-animation');
	jQuery('.dslca-save-draft-composer').show().addClass('dslca-init-animation');
}

const hidePublishButton = () => {
	if ( window.dslcDebug ) console.log( 'hidePublishButton' );

	jQuery('.dslca-save-composer').hide();
	jQuery('.dslca-save-draft-composer').hide();
}

/**
 * UI - GENERAL - Show Section
 */

const showSection = ( section ) => {
	if ( window.dslcDebug ) console.log( 'showSection' );

	// Add class to body so we know it's in progress
	// jQuery('body').addClass('dslca-anim-in-progress');

	// Get vars
	var sectionTitle = jQuery(section).data('title'),
	newColor = jQuery(section).data('bg');

	// Hide ( animate ) the container
	jQuery('.dslca-container').css({ bottom: -500 });

	// Hide all sections and show specific section
	// jQuery('.dslca-section').hide();
	if (section !== ".dslca-module-edit" && section !== ".dslca-modules-section-edit") {
		jQuery(".dslca-section").hide();
	}

	// 2. If 'e' is equal to ".dslca-modules", perform two actions related to activation classes.
	if (section === ".dslca-modules") {
		// Remove active class from the templates button
		jQuery(".dslca-go-to-section-templates").removeClass("dslca-active");

		// Add active class to the modules button
		jQuery(".dslca-go-to-section-modules").addClass("dslca-active");
	}
	
	jQuery(section).show();

	// Change "currently editing"
	if ( section == '.dslca-module-edit' ) {

		jQuery('.dslca-currently-editing')
			.show()
				.find('strong')
				.text( jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument).attr('title') + ' element' );
	} else if ( section == '.dslca-modules-section-edit' ) {

		jQuery('.dslca-currently-editing')
			.show()
			.css( 'background-color', '#006add' )
				.find('strong')
				.text( 'Row' );
	} else {

		jQuery('.dslca-currently-editing')
			.hide()
				.find('strong')
				.text('');
	}

	// Filter module option tabs
	(0,_settings_panel_js__WEBPACK_IMPORTED_MODULE_0__.elementOptionsTabs)();

	// Show ( animate ) the container
	// setTimeout( function() {
		jQuery('.dslca-container').css({ bottom : 0 });
	// }, 300 );

	// Remove class from body so we know it's finished
	// jQuery('body').removeClass('dslca-anim-in-progress');

	// Set initial background color for the color picker fields
	// Fixes the bug with section color pickers to keep values from the previously
	// edited section.
	jQuery(section).find('input.dslca-module-edit-field-colorpicker').each( function (item) {
		jQuery(this).css('background', jQuery(this).val());
	});
}

/**
 * UI - GENERAL - Generate Origin Filters
 */

function dslc_generate_filters() {

	if ( window.dslcDebug ) console.log( 'dslc_generate_filters' );

	// Vars
	var el, filters = [], filtersHTML = '<a html="#" data-origin="">Show All</a>', els = jQuery('.dslca-section:visible .dslca-origin');

	// Go through each and generate the filters
	els.each(function(){
		el = jQuery(this);

		if ( jQuery.inArray( el.data('origin'), filters ) == -1 ) {
			filters.push( el.data('origin') );
			filtersHTML += '<a href="#" data-origin="' + el.data('origin') + '">' + el.data('origin') + '</a>';
		}
	});
	jQuery('.dslca-section-title-filter .dslca-icon').toggleClass('dslc-icon-angle-up dslc-icon-angle-down');
	jQuery('.dslca-section:visible .dslca-section-title-filter-options').html( filtersHTML ).css( 'background', jQuery('.dslca-section:visible').data('bg') );
}

/**
 * UI - GENERAL - Origin Filter
 */

function dslc_filter_origin( origin, section ) {

	if ( window.dslcDebug ) console.log( 'dslc_filter_origin' );

	jQuery('.dslca-origin', section).attr('data-display-module', 'false');
	jQuery('.dslca-origin[data-origin="' + origin + '"]', section).attr('data-display-module', 'true');

	if ( origin == '' ) {

		jQuery('.dslca-origin', section).attr('data-display-module', 'true');
		jQuery('.dslca-origin.dslca-exclude', section).attr('data-display-module', 'false')
	}
}


/**
 * Prevent drag and drop of the modules
 * into the inner content areas of the other modules
 */
const fixContenteditable = () => {

	window.LiveComposer.Builder.PreviewAreaDocument.on('dragstart', '.dslca-module, .dslc-module-front, .dslc-modules-area, .dslc-modules-section', function (e) {

		jQuery('[contenteditable]', window.LiveComposer.Builder.PreviewAreaDocument).attr('contenteditable', false);
	});

	window.LiveComposer.Builder.PreviewAreaDocument.on('dragend mousedown', '.dslca-module, .dslc-module-front, .dslc-modules-area, .dslc-modules-section', function (e) {

		jQuery('[contenteditable]', window.LiveComposer.Builder.PreviewAreaDocument).attr('contenteditable', true);
	});
}

/**
 * Disable/Enable module control.
 *
 * @param  {string} control_id CSS ID of the control we are toggling
 * @return {void}
 */
function dslc_toogle_control ( control_id ) {

	if ( control_id === undefined) control_id = false;
	if ( !control_id ) return;

	var control         = jQuery('.dslca-module-edit-option-' + control_id );
	var control_storage = control.find('.dslca-module-edit-field');

	// Get the element we are editing
	var module = jQuery('.dslca-module-being-edited', LiveComposer.Builder.PreviewAreaDocument);

	// Get the element id
	var module_id = module[0].id;

	var responsive_prefix = '';

	if ( 'tablet_responsive' === control.data('tab') ) {
		responsive_prefix = 'body.dslc-res-tablet ';
	} else if ( 'phone_responsive' === control.data('tab') ) {
		responsive_prefix = 'body.dslc-res-phone ';
	}

	var affect_on_change_el = control_storage.data('affect-on-change-el');

	if ( affect_on_change_el === undefined) return;

	var affect_on_change_elmts = affect_on_change_el.split( ',' );

	affect_on_change_el = '';

	// Loop through elements (useful when there are multiple elements)
	for ( var i = 0; i < affect_on_change_elmts.length; i++ ) {

		if ( i > 0 ) {

			affect_on_change_el += ', ';
		}

		affect_on_change_el += responsive_prefix + '#' + module_id + ' ' + affect_on_change_elmts[i];
	}

	var affect_on_change_rule  = control_storage.data('affect-on-change-rule').replace(/ /g,'');
	var affect_on_change_rules = affect_on_change_rule.split( ',' );

	var control_value;
	var control_data_ext = control_storage.data('ext');

	control.toggleClass('dslca-option-off');

	if ( control.hasClass('dslca-option-off')) {
		// Disable

		control_value = dslc_get_control_value(control_id);
		// Temporary backup the current value as data attribute
		control_storage.data( 'val-bckp', control_value );
		// control_value = dslc_combine_value_and_extension( control_value, control_data_ext);

		// Loop through rules (useful when there are multiple rules)
		for ( var i = 0; i < affect_on_change_rules.length; i++ ) {

			// remove css rule in element inline style
			jQuery( affect_on_change_el, LiveComposer.Builder.PreviewAreaDocument ).css( affect_on_change_rules[i] , '' );
			// remove css rule in css block
			disable_css_rule ( affect_on_change_el, affect_on_change_rules[i], module_id);
			// PROBLEM do not work with multiply rules ex.: .dslc-text-module-content,.dslc-text-module-content p
		}

		control_storage.val('').trigger('change');
	} else {
		// Enable

		// Restore value of the data backup attribute
		control_storage.val( control_storage.data('val-bckp') ).trigger('change');
		control_value = dslc_get_control_value(control_id);
		control_value = dslc_combine_value_and_extension( control_value, control_data_ext || '');

		// Loop through rules (useful when there are multiple rules)
		for ( var i = 0; i < affect_on_change_rules.length; i++ ) {

			var styleContent = affect_on_change_el + "{" + affect_on_change_rules[i] + ": " + control_value + "}";

			LiveComposer.Builder.Helpers.processInlineStyleTag({

				context: control,
				rule: affect_on_change_rules[i],
				elems: affect_on_change_el.replace(new RegExp('#' + module_id, 'gi'), '').trim(),
				styleContent: styleContent
			});
		}
	}
}

jQuery(document).ready(function($){

	// Option Control Toggle
	jQuery(document).on( 'click', '.dslca-module-edit-option .dslc-control-toggle', function(e){

		e.preventDefault();
		var control_id = jQuery(e.target).closest('.dslca-module-edit-option').find('.dslca-module-edit-field').data('id');
		dslc_toogle_control ( control_id );
	});


	// Disable Toggle If the Control Focused
	jQuery(document).on( 'mousedown', '.dslca-module-edit-option', function(e){

		var toggle = jQuery('.dslc-control-toggle');
		if ( ! toggle.is(e.target) // if the target of the click isn't the container...
		     && toggle.has(e.target).length === 0 ) // ... nor a descendant of the container
		{

			if ( jQuery(e.target).closest('.dslca-module-edit-option').hasClass('dslca-option-off') ) {

				var control_id = jQuery(e.target).closest('.dslca-module-edit-option').find('.dslca-module-edit-field').data('id');
				dslc_toogle_control (control_id);
			}
		}
	});
});

function disable_css_rule(selectorCSS, ruleCSS, moduleID) {

	var cssRules;
	var target_stylsheet_ID = 'css-for-' + moduleID;
	var stylesheet = document.getElementById('page-builder-frame').contentWindow.document.getElementById(target_stylsheet_ID);

	selectorCSS = selectorCSS.replace( /\s\s+/g, ' ' );

	if (stylesheet) {

	   stylesheet = stylesheet.sheet;

		if (stylesheet['rules']) {

			cssRules = 'rules';
		} else if (stylesheet['cssRules']) {

			cssRules = 'cssRules';
		} else {

			//no rules found... browser unknown
		}

		// Go through each CSS rule (ex.: .content h1 {...})
		for (var R = 0; R < stylesheet[cssRules].length; R++) {

			// Is current CSS rule equal to the selectorCSS we are looking for?
			// (ex.: '.content h1' == '.content h1' )
			if (stylesheet[cssRules][R].selectorText == selectorCSS) {

				// Get CSS property we are looking for... (ex.: font-size : ...; )
				if(stylesheet[cssRules][R].style[ruleCSS]){

						stylesheet[cssRules][R].style[ruleCSS] = '';
					break;
				}
			}
		}
	}
}

function dslc_combine_value_and_extension ( value, extension) {
	if ( '' === value || null === value ) {
		return value;
	}

	// Check if value do not already include extension
	if ( value.indexOf(extension) == -1 ) {
		value = value + extension;
	}

	return value;
}

function dslc_get_control_value ( control_id ) {

	var control      = jQuery('.dslca-module-edit-option-' + control_id );
	var control_type = 'text';
	var control_storage = control.find('.dslca-module-edit-field');
	var value;

/*
	if ( control.hasClass('dslca-module-edit-option-select') ) {

	} else {
		// text based controls
		value = control_storage.val();
	}
*/
	value = control_storage.val();

	return value;
}

/**
 * Bind keypress events with both parent and iframe pages.
 * Function called when content inside iframe is loaded.
 *
 * @return {void}
 */
const keypressEvents = () => {

	jQuery( [document, LiveComposer.Builder.PreviewAreaWindow.document ] ).unbind('keydown').bind('keydown', function (keydown_event) {
		// Modal window [ESC]/[Enter]
		window.dslc_modal_keypress_events( keydown_event );

		// Prevent backspace from navigating back
		dslc_disable_backspace_navigation( keydown_event );

		// Prompt Modal on F5
		dslc_notice_on_refresh( keydown_event );

		// Save Page
		dslc_save_page( keydown_event );

		// CMD button press event.
		dslc_cmd_press( keydown_event );

		// Events to run when any button preset.
		dslc_keydown( keydown_event );
		// ----------------------------------------------------
        // ** NEW: UNDO (Ctrl/Cmd + Z) & REDO (Ctrl/Cmd + Y/Shift+Z) **
        // ----------------------------------------------------
        if ( (keydown_event.metaKey || keydown_event.ctrlKey) ) {
            // UNDO: Ctrl/Cmd + Z
            if ( keydown_event.which === 90 && ! keydown_event.shiftKey ) { // 90 is key code for Z
                keydown_event.preventDefault();
                if (typeof LiveComposer.Builder.Actions.undo === 'function') {
                    LiveComposer.Builder.Actions.undo();
                }
                return false;
            }
            // REDO: Ctrl/Cmd + Y (89) or Ctrl/Cmd + Shift + Z
            if ( keydown_event.which === 89 || (keydown_event.which === 90 && keydown_event.shiftKey) ) {
                keydown_event.preventDefault();
                if (typeof LiveComposer.Builder.Actions.redo === 'function') {
                    LiveComposer.Builder.Actions.redo();
                }
                return false;
            }
        }
        // ----------------------------------------------------
        // ** END NEW CODE **
        // ----------------------------------------------------
	});

	// Key UP events.
	jQuery( [document, LiveComposer.Builder.PreviewAreaWindow.document ] ).unbind('keyup').bind('keyup', function (keyup_event) {
		dslc_cmd_unpress( keyup_event );
	});
}

/**
 * Action - Prevent backspace from navigating back
 */

function dslc_disable_backspace_navigation (event) {

	var doPrevent = false;

	if (event.keyCode === 8) {

		var d = event.srcElement || event.target;

		if ( (d.tagName.toUpperCase() === 'INPUT' && (
				d.type.toUpperCase() === 'TEXT' ||
				d.type.toUpperCase() === 'PASSWORD' ||
				d.type.toUpperCase() === 'NUMBER' ||
				d.type.toUpperCase() === 'FILE')
			  )
			 || d.tagName.toUpperCase() === 'TEXTAREA'
			 || jQuery(d).hasClass('dslca-editable-content')
			 || jQuery(d).hasClass('dslc-tabs-nav-hook-title')
			 || jQuery(d).hasClass('dslc-accordion-title') ) {

			doPrevent = d.readOnly || d.disabled;
		} else {

			doPrevent = true;
		}
	}

	if (doPrevent) {
		event.preventDefault();
	}
}

/**
 * Actions - Prompt Modal on F5
 *
 * 116 – F5
 * 81 + event.metaKey = CMD + R
 */

function dslc_notice_on_refresh(e) {

	if ( e.which == 116 || ( e.which === 82 && e.metaKey ) ) {

		if ( jQuery('.dslca-save-composer-hook').offsetParent !== null || jQuery('.dslca-module-edit-save').offsetParent !== null ) {

			e.preventDefault();
			(0,_modalwindow_class_js__WEBPACK_IMPORTED_MODULE_1__.CModalWindow)({

				title: DSLCString.str_refresh_title,
				content: DSLCString.str_refresh_descr,
				confirm: function() {

					window.location.reload();
				}
			});

			/*dslc_js_confirm( 'disable_lc', '<span class="dslca-prompt-modal-title">' + DSLCString.str_refresh_title +
			 '</span><span class="dslca-prompt-modal-descr">' + DSLCString.str_refresh_descr + '</span>', document.URL );*/
		}
	}
}

/**
 * If Control or Command key is pressed and the S key is pressed run dslc_save_composer.
 * 83 is the key code for S.
 */
function dslc_save_page(e) {

    if ( e.which == 83 && ( e.metaKey || e.ctrlKey )  ) {
    	if ( jQuery('.dslca-save-composer-hook').css('display') == 'block' ) {
	        (0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_2__.dslc_save_composer)();
	        e.preventDefault();
	        return false;
	    }
    }
}


/**
 * If any key is pressed.
 */
function dslc_keydown( e ) {
    if ( LiveComposer.Builder.UI.cmdMode ) {
		if ( ! e.metaKey && ! e.ctrlKey ) {
		LiveComposer.Builder.UI.cmdMode = false;
		LiveComposer.Builder.PreviewAreaWindow.document.querySelector('body').classList.remove( 'key-press-cmd' );
		}
    }
}

/**
 * If Command key is pressed.
 */
function dslc_cmd_press( e ) {
    if ( e.metaKey || e.ctrlKey ) {
		LiveComposer.Builder.UI.cmdMode = true;
		LiveComposer.Builder.PreviewAreaWindow.document.querySelector('body').classList.add( 'key-press-cmd' );
    }
}

/**
 * If Command key is released.
 */
function dslc_cmd_unpress( e ) {
    if ( e.key === "Meta" ) {
		LiveComposer.Builder.UI.cmdMode = false;
		LiveComposer.Builder.PreviewAreaWindow.document.querySelector('body').classList.remove( 'key-press-cmd' );
    }
}

/**
 * Generate report about JS error and save it in a local storage.
 * @param  String error Error text
 * @param  String file  File with error
 * @param  String line  Line with error
 * @param  String char  Column with error
 * @return void
 */
function dslca_generate_error_report ( error, file, line, char ) {

	var title = 'JavaScript error detected in a third-party plugin';

	if ( file.match("wp-content\/plugins\/live-composer-page-builder\/js") != null ) {

		title = 'Live Composer returned JS error';
	}

	var error_report = '';
	error_report += '<br /><strong style="color:#E55F5F;">' + title + '</strong><br />';
	error_report += error + '<br /> File "' + file + '", line ' + line + ', char ' + char + '<br />';

	if ( 'undefined' !== typeof(Storage)) {
		localStorage.setItem('js_errors_report', error_report);
	}
}

/**
 * Put in a hidden div#dslca-js-errors-report information from local storage
 * @return void
 */
function dslca_update_report_log() {

	var errors_container = document.getElementById('dslca-js-errors-report');
	var error_report = localStorage.getItem('js_errors_report');

	if ( null !== error_report ) {
		if ( error_report.includes('lc-extensions') || error_report.includes('page-builder') ) {
			errors_container.value = error_report;
			localStorage.removeItem('js_errors_report');
			document.querySelector( '.dslca-show-js-error-container' ).style.display = 'block';			
			document.querySelector('.dslca-show-js-error-hook').style.display = 'block';
		}
	}
}


// ============================================================
jQuery(document).on('editorFrameLoaded', function(){

	var $ = jQuery;
	var headerFooter = jQuery('div[data-hf]', LiveComposer.Builder.PreviewAreaDocument);
	var overlay = '';

	headerFooter.each(function(index, el) {
		var linkToEdit = jQuery(el).data('editing-link');
		var hfType = jQuery(el).data('editing-type');
		var editingLabel = jQuery(el).data('editing-label');
		var editingSubLabel = jQuery(el).data('editing-sublabel');

		overlay += '<div class="dslc-hf-block-overlay"><a target="_blank" href="' + linkToEdit + '" class="dslc-hf-block-overlay-button dslca-link">' + editingLabel + '</a>';
		if ( editingSubLabel !== undefined ) {
			overlay += ' <span class="dslc-hf-block-overlay-text">' + editingSubLabel + '</span>';
		}
		overlay += '</div>';

		var htmlObject = document.createElement('div');
		htmlObject.innerHTML = overlay;

		el.append( htmlObject );
	}); 

});

// ============================================================
document.addEventListener('DOMContentLoaded', () => {

    const closeBtn1 = document.getElementById("lc_closeBtn");
    const closeBtn2 = document.getElementById("lc_closeBtn2");
	const dragOverlay = document.getElementById("dslc-drag-overlay");

    // Initialize Module Popup (lc_popup)
    (0,_popup_drag_resize_js__WEBPACK_IMPORTED_MODULE_3__.makePopupDraggableAndResizable)('lc_popup', 'lc_popupHeader', dragOverlay, closeBtn1);
    
    // Initialize Row Popup (lc_popup2)
    (0,_popup_drag_resize_js__WEBPACK_IMPORTED_MODULE_3__.makePopupDraggableAndResizable)('lc_popup2', 'lc_popupHeader2', dragOverlay, closeBtn2);
	const popup = document.getElementById('lc_popupContent');
    const btnMin = document.getElementById('lc_popup_minimize');
    const btnMax = document.getElementById('lc_popup_maximize');
 
    // Hide popup
    btnMin.addEventListener('click', function() {
        popup.classList.remove('show');
 
        btnMin.classList.remove('show');
        btnMin.classList.add('hide');
 
        btnMax.classList.remove('hide');
        btnMax.classList.add('show');
    });
 
    // Show popup
    btnMax.addEventListener('click', function() {
        popup.classList.add('show');
 
        btnMax.classList.remove('show');
        btnMax.classList.add('hide');
 
        btnMin.classList.remove('hide');
        btnMin.classList.add('show');
    });
 
    const popup2 = document.getElementById('lc_popupContent2');
    const btnMin2 = document.getElementById('lc_popup_minimize2');
    const btnMax2 = document.getElementById('lc_popup_maximize2');
 
    // Hide popup
    btnMin2.addEventListener('click', function() {
        popup2.classList.remove('show');
 
        btnMin2.classList.remove('show');
        btnMin2.classList.add('hide');
 
        btnMax2.classList.remove('hide');
        btnMax2.classList.add('show');
    });
 
    // Show popup
    btnMax2.addEventListener('click', function() {
        popup2.classList.add('show');
 
        btnMax2.classList.remove('show');
        btnMax2.classList.add('hide');
 
        btnMin2.classList.remove('hide');
        btnMin2.classList.add('show');
    });
 
});

/***/ }),

/***/ "./js/src/editor/backend/utils.class.js":
/*!**********************************************!*\
  !*** ./js/src/editor/backend/utils.class.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   untilsInitJs: () => (/* binding */ untilsInitJs)
/* harmony export */ });
/**
 * Custom utils
 */



const Utils = {
	addslashes: function(str)
	{
		 str = str.replace(/\\/g, '\\\\');
		 str = str.replace(/\'/g, '\\\'');
		 str = str.replace(/\"/g, '\\"');
		 str = str.replace(/\0/g, '\\0');
		 return str;
	},

	basename: function(path)
	{
		return path.split(/[\\/]/).pop();
	},

	/**
	 * Check if browser is IE
	 */
	msieversion: function() {

	    var ua = window.navigator.userAgent;
	    var msie = ua.indexOf("MSIE ");

	    if (msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./))  // If Internet Explorer, return version number
	    {
	        return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)));
	    }
	    else  // If another browser, return 0
	    {
	        return false;
	    }
	},

	/**
	 * Check if variables in array is desired types
	 * @param  {array} array
	 * @return {boolean}
	 */
	checkParams: function(array)
	{
		if(!Array.isArray(array))
		{
			throw ('Param is not array');
		}

		/// Instead of switch construction
		var types = {
			integer: function(param)
			{
				return isNaN(parseInt(param));
			},
			float: function(param)
			{
				return isNaN(parseFloat(param));
			},
			string: function(param)
			{
				return param != null && param != undefined && typeof param == 'string';
			},
			array: function(param)
			{
				return Array.isArray(param);
			},
			object: function(param)
			{
				return typeof param == 'object';
			}
		}

		/// Check it!
		array.map(function(item){
			if(!types[item[1]](item[0])){
				throw('Param ' + item[0] + ' is not ' + item[1]);
			}
		});
	},

	/**
	 * Converts UTF-8 to base64
	 *
	 * @param  {string} t utf-8
	 * @return {string}   b64
	 */
	utf8_to_b64: function(t) {

		return window.btoa(unescape(encodeURIComponent(t)));
	},

	/**
	 * Converts base64 to UTF-8
	 *
	 * @param  {string} str in b64
	 * @return {string}   in utf-8
	 */
	b64_to_utf8: function(str) {

		return decodeURIComponent(escape(window.atob(str)));
	},

	/**
	 * Get Page Params
	 *
	 * @return {array}
	 */
	get_page_params: function() {

		return decodeURIComponent(window.location.search.slice(1)).split('&').reduce(function _reduce ( a, b) { b = b.split('='); a[b[0]] = b[1]; return a; }, {});
	},

	get_unique_id: function() {

		return Math.random().toString(32).slice(2);
	},

	/**
	 * Update module option in raw JSON code (dslc_code) of the module
	 *
	 * @param  {DOM element} module    Module Element
	 * @param  {string} property_name  Name of the option we change
	 * @param  {string} property_value Value of the option we change
	 * @return {void}
	 */
	update_module_property_raw: function (module, property_name, property_value ) {
		// Hidden textarea element with raw base64 code of the module
		// <textarea class="dslca-module-code">YTo2On....iOjE7fQ==</textarea>
		var module_code_container = module.getElementsByClassName('dslca-module-code')[0];

		// Hidden textarea element with value of this particular setting
		// <textarea data-id="property_name">property_value</textarea>
		var property_container = module.querySelector( '.dslca-module-option-front[data-id="' + property_name + '"]' );

		// Get module raw code
		var module_code = module_code_container.value;

		module_code = JSON.parse( module_code );
		module_code[property_name] = property_value;
		module_code = JSON.stringify( module_code );

		// Update raw code
		module_code_container.value = module_code;
		module_code_container.innerText = module_code; // See comment block below

		// Change the property in hidden textarea as well
		property_container.value = property_value;
		property_container.innerText  = property_value; // See comment block below

		/**
		 * FireFox will not duplicate textarea value properly using .cloneNode(true)
		 * if we don't use .innerHTML statement (Chrome works fine with .value only).
		 *
		 * See bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=237783
		 */
	},

	/**
	 * Update section option in raw JSON code (dslc_code) of the section
	 *
	 * @param  {DOM element} section    `section Element
	 * @param  {string} property_name  Name of the option we change
	 * @param  {string} property_value Value of the option we change
	 * @return {void}
	 */
	update_section_property_raw: function (section, property_name, property_value ) {
		// Hidden textarea element with raw base64 code of the roq
		// <textarea class="dslca-section-code"></textarea>
		var section_code_container = section.getElementsByClassName('dslca-section-code')[0];

		// Hidden input element with value of this particular setting
		// <input data-id="property_name">property_value</textarea>
		var property_container = section.querySelector( '.dslca-modules-section-settings input[data-id="' + property_name + '"]' );

		// Get module raw code
		var section_code = section_code_container.value;

		section_code = JSON.parse( section_code );
		section_code[property_name] = property_value;
		section_code = JSON.stringify( section_code );

		// Update raw code
		section_code_container.value = section_code;
		section_code_container.innerText = section_code; // See comment block below

		// Change the property in hidden textarea as well
		property_container.setAttribute( 'value', property_value );
		property_container.setAttribute( 'data-def', property_value );
	},

	/**
	 * Provide custom events publish.
	 * Also echoes all the custom events in the preview iframe as well.
	 *
	 * @param  {string} eventName
	 * @param  {object||string||null||numeric} eventData [description]
	 */
	publish: function( eventName, eventData ) {

		eventData = eventData ? eventData : {};

		this.checkParams( [
			[eventName, 'string'],
			[eventData, 'object']
		] );

		jQuery(document).trigger( {
			type: eventName,
			message: {details: eventData}
		} );

		LiveComposer.Builder.PreviewAreaWindow.dslca_publish_event( eventName, eventData );
	}
};

const untilsInitJs = () => {
	window.LiveComposer.Utils = Utils;
}


/***/ }),

/***/ "./node_modules/animejs/dist/modules/animation/additive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/animation/additive.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAdditiveAnimation: () => (/* binding */ addAdditiveAnimation),
/* harmony export */   additive: () => (/* binding */ additive)
/* harmony export */ });
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _core_render_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/render.js */ "./node_modules/animejs/dist/modules/core/render.js");
/**
 * Anime.js - animation - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */





const additive = {
  animation: null,
  update: _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
};

/**
 * @import {
 *   Tween,
 *   TweenAdditiveLookups,
 * } from '../types/index.js'
 */

/**
 * @typedef AdditiveAnimation
 * @property {Number} duration
 * @property {Number} _offset
 * @property {Number} _delay
 * @property {Tween} _head
 * @property {Tween} _tail
 */

/**
 * @param  {TweenAdditiveLookups} lookups
 * @return {AdditiveAnimation}
 */
const addAdditiveAnimation = lookups => {
  let animation = additive.animation;
  if (!animation) {
    animation = {
      duration: _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue,
      computeDeltaTime: _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
      _offset: 0,
      _delay: 0,
      _head: null,
      _tail: null,
    };
    additive.animation = animation;
    additive.update = () => {
      lookups.forEach(propertyAnimation => {
        for (let propertyName in propertyAnimation) {
          const tweens = propertyAnimation[propertyName];
          const lookupTween = tweens._head;
          if (lookupTween) {
            const valueType = lookupTween._valueType;
            const additiveValues = valueType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX || valueType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR ? (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(lookupTween._fromNumbers) : null;
            let additiveValue = lookupTween._fromNumber;
            let tween = tweens._tail;
            while (tween && tween !== lookupTween) {
              if (additiveValues) {
                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
              } else {
                additiveValue += tween._number;
              }
              tween = tween._prevAdd;
            }
            lookupTween._toNumber = additiveValue;
            lookupTween._toNumbers = additiveValues;
          }
        }
      });
      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
      (0,_core_render_js__WEBPACK_IMPORTED_MODULE_2__.render)(animation, 1, 1, 0, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.FORCE);
    };
  }
  return animation;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/animation/animation.js":
/*!******************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/animation/animation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSAnimation: () => (/* binding */ JSAnimation),
/* harmony export */   animate: () => (/* binding */ animate)
/* harmony export */ });
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _core_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/* harmony import */ var _core_targets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/targets.js */ "./node_modules/animejs/dist/modules/core/targets.js");
/* harmony import */ var _core_values_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/values.js */ "./node_modules/animejs/dist/modules/core/values.js");
/* harmony import */ var _core_styles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/styles.js */ "./node_modules/animejs/dist/modules/core/styles.js");
/* harmony import */ var _core_units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/units.js */ "./node_modules/animejs/dist/modules/core/units.js");
/* harmony import */ var _easings_eases_parser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../easings/eases/parser.js */ "./node_modules/animejs/dist/modules/easings/eases/parser.js");
/* harmony import */ var _timer_timer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../timer/timer.js */ "./node_modules/animejs/dist/modules/timer/timer.js");
/* harmony import */ var _composition_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./composition.js */ "./node_modules/animejs/dist/modules/animation/composition.js");
/* harmony import */ var _additive_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./additive.js */ "./node_modules/animejs/dist/modules/animation/additive.js");
/**
 * Anime.js - animation - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */













/**
 * @import {
 *   Tween,
 *   TweenKeyValue,
 *   TweenParamsOptions,
 *   TweenValues,
 *   DurationKeyframes,
 *   PercentageKeyframes,
 *   AnimationParams,
 *   TweenPropValue,
 *   ArraySyntaxValue,
 *   TargetsParam,
 *   TimerParams,
 *   TweenParamValue,
 *   DOMTarget,
 *   TargetsArray,
 *   Callback,
 *   EasingFunction,
 * } from '../types/index.js'
 *
 * @import {
 *   Timeline,
 * } from '../timeline/timeline.js'
 *
 * @import {
 *   Spring,
 * } from '../easings/spring/index.js'
 */

// Defines decomposed values target objects only once and mutate their properties later to avoid GC
// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
const fromTargetObject = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.createDecomposedValueTargetObject)();
const toTargetObject = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.createDecomposedValueTargetObject)();
const inlineStylesStore = {};
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
const keyObjectTarget = { to: null };

let tweenId = 0;
let keyframes;
/** @type {TweenParamsOptions & TweenValues} */
let key;

/**
 * @param {DurationKeyframes | PercentageKeyframes} keyframes
 * @param {AnimationParams} parameters
 * @return {AnimationParams}
 */
const generateKeyframes = (keyframes, parameters) => {
  /** @type {AnimationParams} */
  const properties = {};
  if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isArr)(keyframes)) {
    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isKey);
    for (let i = 0, l = propertyNames.length; i < l; i++) {
      const propName = propertyNames[i];
      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {
        /** @type {TweenKeyValue} */
        const newKey = {};
        for (let p in key) {
          const keyValue = /** @type {TweenPropValue} */(key[p]);
          if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isKey)(p)) {
            if (p === propName) {
              newKey.to = keyValue;
            }
          } else {
            newKey[p] = keyValue;
          }
        }
        return newKey;
      });
      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);
    }

  } else {
    const totalDuration = /** @type {Number} */((0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(parameters.duration, _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.defaults.duration));
    const keys = Object.keys(keyframes)
    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })
    .sort((a, b) => a.o - b.o);
    keys.forEach(key => {
      const offset = key.o;
      const prop = key.p;
      for (let name in prop) {
        if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isKey)(name)) {
          let propArray = /** @type {Array} */(properties[name]);
          if (!propArray) propArray = properties[name] = [];
          const duration = offset * totalDuration;
          let length = propArray.length;
          let prevKey = propArray[length - 1];
          const keyObj = { to: prop[name] };
          let durProgress = 0;
          for (let i = 0; i < length; i++) {
            durProgress += propArray[i].duration;
          }
          if (length === 1) {
            keyObj.from = prevKey.to;
          }
          if (prop.ease) {
            keyObj.ease = prop.ease;
          }
          keyObj.duration = duration - (length ? durProgress : 0);
          propArray.push(keyObj);
        }
      }
      return key;
    });

    for (let name in properties) {
      const propArray = /** @type {Array} */(properties[name]);
      let prevEase;
      // let durProgress = 0
      for (let i = 0, l = propArray.length; i < l; i++) {
        const prop = propArray[i];
        // Emulate WAPPI easing parameter position
        const currentEase = prop.ease;
        prop.ease = prevEase ? prevEase : undefined;
        prevEase = currentEase;
        // durProgress += prop.duration;
        // if (i === l - 1 && durProgress !== totalDuration) {
        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
        // }
      }
      if (!propArray[0].duration) {
        propArray.shift();
      }
    }

  }

  return properties;
};

class JSAnimation extends _timer_timer_js__WEBPACK_IMPORTED_MODULE_8__.Timer {
  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   * @param {Boolean} [fastSet=false]
   * @param {Number} [index=0]
   * @param {Number} [length=0]
   */
  constructor(
    targets,
    parameters,
    parent,
    parentPosition,
    fastSet = false,
    index = 0,
    length = 0
  ) {

    super(/** @type {TimerParams & AnimationParams} */(parameters), parent, parentPosition);

    const parsedTargets = (0,_core_targets_js__WEBPACK_IMPORTED_MODULE_3__.registerTargets)(targets);
    const targetsLength = parsedTargets.length;

    // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties

    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;
    const params = /** @type {AnimationParams} */(kfParams ? (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mergeObjects)(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);

    const {
      delay,
      duration,
      ease,
      playbackEase,
      modifier,
      composition,
      onRender,
    } = params;

    const animDefaults = parent ? parent.defaults : _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.defaults;
    const animaPlaybackEase = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(playbackEase, animDefaults.playbackEase);
    const animEase = animaPlaybackEase ? (0,_easings_eases_parser_js__WEBPACK_IMPORTED_MODULE_7__.parseEase)(animaPlaybackEase) : null;
    const hasSpring = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(ease) && !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(/** @type {Spring} */(ease).ease);
    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(ease, animEase ? 'linear' : animDefaults.ease);
    const tDuration = hasSpring ? /** @type {Spring} */(ease).settlingDuration : (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(duration, animDefaults.duration);
    const tDelay = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(delay, animDefaults.delay);
    const tModifier = modifier || animDefaults.modifier;
    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
    const tComposition = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(composition) && targetsLength >= _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.K ? _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.none : !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(composition) ? composition : animDefaults.composition;
    // const absoluteOffsetTime = this._offset;
    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
    // This allows targeting the current animation in the spring onComplete callback
    if (hasSpring) /** @type {Spring} */(ease).parent = this;

    let iterationDuration = NaN;
    let iterationDelay = NaN;
    let animationAnimationLength = 0;
    let shouldTriggerRender = 0;

    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {

      const target = parsedTargets[targetIndex];
      const ti = index || targetIndex;
      const tl = length || targetsLength;

      let lastTransformGroupIndex = NaN;
      let lastTransformGroupLength = NaN;

      for (let p in params) {

        if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isKey)(p)) {

          const tweenType = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getTweenType)(target, p);

          const propName = (0,_core_styles_js__WEBPACK_IMPORTED_MODULE_5__.sanitizePropertyName)(p, target, tweenType);

          let propValue = params[p];

          const isPropValueArray = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isArr)(propValue);

          if (fastSet && !isPropValueArray) {
            fastSetValuesArray[0] = propValue;
            fastSetValuesArray[1] = propValue;
            propValue = fastSetValuesArray;
          }

          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
          // Normalize property values to valid keyframe syntax:
          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
          if (isPropValueArray) {
            const arrayLength = /** @type {Array} */(propValue).length;
            const isNotObjectValue = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isObj)(propValue[0]);
            // Convert [x, y] to [{to: [x, y]}]
            if (arrayLength === 2 && isNotObjectValue) {
              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));
              keyframesTargetArray[0] = keyObjectTarget;
              keyframes = keyframesTargetArray;
            // Convert [x, y, z] to [[x, y], z]
            } else if (arrayLength > 2 && isNotObjectValue) {
              keyframes = [];
              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {
                if (!i) {
                  fastSetValuesArray[0] = v;
                } else if (i === 1) {
                  fastSetValuesArray[1] = v;
                  keyframes.push(fastSetValuesArray);
                } else {
                  keyframes.push(v);
                }
              });
            } else {
              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);
            }
          } else {
            keyframesTargetArray[0] = propValue;
            keyframes = keyframesTargetArray;
          }

          let siblings = null;
          let prevTween = null;
          let firstTweenChangeStartTime = NaN;
          let lastTweenChangeEndTime = 0;
          let tweenIndex = 0;

          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {

            const keyframe = keyframes[tweenIndex];

            if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isObj)(keyframe)) {
              key = keyframe;
            } else {
              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);
              key = keyObjectTarget;
            }

            toFunctionStore.func = null;

            const computedToValue = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)(key.to, target, ti, tl, toFunctionStore);

            let tweenToValue;
            // Allows function based values to return an object syntax value ({to: v})
            if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isObj)(computedToValue) && !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(computedToValue.to)) {
              key = computedToValue;
              tweenToValue = computedToValue.to;
            } else {
              tweenToValue = computedToValue;
            }
            const tweenFromValue = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)(key.from, target, ti, tl);
            const keyEasing = key.ease;
            const hasSpring = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(keyEasing) && !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(/** @type {Spring} */(keyEasing).ease);
            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time
            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;
            // Calculate default individual keyframe duration by dividing the tl of keyframes
            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).settlingDuration : (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)((0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(key.duration, (l > 1 ? (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
            // Default delay value should only be applied to the first tween
            const tweenDelay = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)((0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
            const computedComposition = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)((0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.setValue)(key.composition, tComposition), target, ti, tl);
            const tweenComposition = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isNum)(computedComposition) ? computedComposition : _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes[computedComposition];
            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
            const tweenModifier = key.modifier || tModifier;
            const hasFromvalue = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(tweenFromValue);
            const hasToValue = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(tweenToValue);
            const isFromToArray = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isArr)(tweenToValue);
            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
            // Rounding is necessary here to minimize floating point errors when working in seconds
            const absoluteStartTime = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(absoluteOffsetTime + tweenStartTime, 12);

            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;

            let prevSibling = prevTween;

            if (tweenComposition !== _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.none) {
              if (!siblings) siblings = (0,_composition_js__WEBPACK_IMPORTED_MODULE_9__.getTweenSiblings)(target, propName);
              let nextSibling = siblings._head;
              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                prevSibling = nextSibling;
                nextSibling = nextSibling._nextRep;
                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                  while (nextSibling) {
                    (0,_composition_js__WEBPACK_IMPORTED_MODULE_9__.overrideTween)(nextSibling);
                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                    nextSibling = nextSibling._nextRep;
                  }
                }
              }
            }

            // Decompose values
            if (isFromToValue) {
              (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(isFromToArray ? (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
              (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(isFromToArray ? (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getFunctionValue)(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
              if (fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.NUMBER) {
                if (prevSibling) {
                  if (prevSibling._valueType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT) {
                    fromTargetObject.t = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT;
                    fromTargetObject.u = prevSibling._unit;
                  }
                } else {
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(
                    (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getOriginalAnimatableValue)(target, propName, tweenType, inlineStylesStore),
                    _core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue
                  );
                  if (_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT) {
                    fromTargetObject.t = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT;
                    fromTargetObject.u = _core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue.u;
                  }
                }
              }
            } else {
              if (hasToValue) {
                (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(tweenToValue, toTargetObject);
              } else {
                if (prevTween) {
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeTweenValue)(prevTween, toTargetObject);
                } else {
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getOriginalAnimatableValue)(target, propName, tweenType, inlineStylesStore), toTargetObject);
                }
              }
              if (hasFromvalue) {
                (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(tweenFromValue, fromTargetObject);
              } else {
                if (prevTween) {
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeTweenValue)(prevTween, fromTargetObject);
                } else {
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getOriginalAnimatableValue)(target, propName, tweenType, inlineStylesStore), fromTargetObject);
                }
              }
            }

            // Apply operators
            if (fromTargetObject.o) {
              fromTargetObject.n = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getRelativeValue)(
                !prevSibling ? (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(
                  (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getOriginalAnimatableValue)(target, propName, tweenType, inlineStylesStore),
                  _core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue
                ).n : prevSibling._toNumber,
                fromTargetObject.n,
                fromTargetObject.o
              );
            }

            if (toTargetObject.o) {
              toTargetObject.n = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getRelativeValue)(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
            }

            // Values omogenisation in cases of type difference between "from" and "to"
            if (fromTargetObject.t !== toTargetObject.t) {
              if (fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX || toTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX) {
                const complexValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                const notComplexValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                notComplexValue.t = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX;
                notComplexValue.s = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(complexValue.s);
                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
              } else if (fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT || toTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT) {
                const unitValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT ? fromTargetObject : toTargetObject;
                const notUnitValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT ? toTargetObject : fromTargetObject;
                notUnitValue.t = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT;
                notUnitValue.u = unitValue.u;
              } else if (fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR || toTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR) {
                const colorValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR ? fromTargetObject : toTargetObject;
                const notColorValue = fromTargetObject.t === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR ? toTargetObject : fromTargetObject;
                notColorValue.t = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR;
                notColorValue.s = colorValue.s;
                notColorValue.d = [0, 0, 0, 1];
              }
            }

            // Unit conversion
            if (fromTargetObject.u !== toTargetObject.u) {
              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
              valueToConvert = (0,_core_units_js__WEBPACK_IMPORTED_MODULE_6__.convertValueUnit)(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
              // TODO:
              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
            }

            // Fill in non existing complex values
            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
              // TODO: Check if n should be used instead of 0 for default complex values
              shortestValue.d = longestValue.d.map((/** @type {Number} */_, /** @type {Number} */i) => (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
              shortestValue.s = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(longestValue.s);
            }

            // Tween factory

            // Rounding is necessary here to minimize floating point errors when working in seconds
            const tweenUpdateDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(+tweenDuration || _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue, 12);

            // Copy the value of the iniline style if it exist and imediatly nullify it to prevents false positive on other targets
            let inlineValue = inlineStylesStore[propName];
            if (!(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isNil)(inlineValue)) inlineStylesStore[propName] = null;

            /** @type {Tween} */
            const tween = {
              parent: this,
              id: tweenId++,
              property: propName,
              target: target,
              _value: null,
              _func: toFunctionStore.func,
              _ease: (0,_easings_eases_parser_js__WEBPACK_IMPORTED_MODULE_7__.parseEase)(tweenEasing),
              _fromNumbers: (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(fromTargetObject.d),
              _toNumbers: (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(toTargetObject.d),
              _strings: (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(toTargetObject.s),
              _fromNumber: fromTargetObject.n,
              _toNumber: toTargetObject.n,
              _numbers: (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(fromTargetObject.d), // For additive tween and animatables
              _number: fromTargetObject.n, // For additive tween and animatables
              _unit: toTargetObject.u,
              _modifier: tweenModifier,
              _currentTime: 0,
              _startTime: tweenStartTime,
              _delay: +tweenDelay,
              _updateDuration: tweenUpdateDuration,
              _changeDuration: tweenUpdateDuration,
              _absoluteStartTime: absoluteStartTime,
              // NOTE: Investigate bit packing to stores ENUM / BOOL
              _tweenType: tweenType,
              _valueType: toTargetObject.t,
              _composition: tweenComposition,
              _isOverlapped: 0,
              _isOverridden: 0,
              _renderTransforms: 0,
              _inlineValue: inlineValue,
              _prevRep: null, // For replaced tween
              _nextRep: null, // For replaced tween
              _prevAdd: null, // For additive tween
              _nextAdd: null, // For additive tween
              _prev: null,
              _next: null,
            };

            if (tweenComposition !== _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.none) {
              (0,_composition_js__WEBPACK_IMPORTED_MODULE_9__.composeTween)(tween, siblings);
            }

            if (isNaN(firstTweenChangeStartTime)) {
              firstTweenChangeStartTime = tween._startTime;
            }
            // Rounding is necessary here to minimize floating point errors when working in seconds
            lastTweenChangeEndTime = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(tweenStartTime + tweenUpdateDuration, 12);
            prevTween = tween;
            animationAnimationLength++;

            (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(this, tween);

          }

          // Update animation timings with the added tweens properties

          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
            iterationDelay = firstTweenChangeStartTime;
          }

          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
            iterationDuration = lastTweenChangeEndTime;
          }

          // TODO: Find a way to inline tween._renderTransforms = 1 here
          if (tweenType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM) {
            lastTransformGroupIndex = animationAnimationLength - tweenIndex;
            lastTransformGroupLength = animationAnimationLength;
          }

        }

      }

      // Set _renderTransforms to last transform property to correctly render the transforms list
      if (!isNaN(lastTransformGroupIndex)) {
        let i = 0;
        (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, (/** @type {Tween} */tween) => {
          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
            tween._renderTransforms = 1;
            if (tween._composition === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.blend) {
              (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(_additive_js__WEBPACK_IMPORTED_MODULE_10__.additive.animation, (/** @type {Tween} */additiveTween) => {
                if (additiveTween.id === tween.id) {
                  additiveTween._renderTransforms = 1;
                }
              });
            }
          }
          i++;
        });
      }

    }

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    if (iterationDelay) {
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, (/** @type {Tween} */tween) => {
        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
        if (!(tween._startTime - tween._delay)) {
          tween._delay -= iterationDelay;
        }
        tween._startTime -= iterationDelay;
      });
      iterationDuration -= iterationDelay;
    } else {
      iterationDelay = 0;
    }

    // Prevents iterationDuration to be NaN if no valid animatable props have been provided
    // Prevents _iterationCount to be NaN if no valid animatable props have been provided
    if (!iterationDuration) {
      iterationDuration = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
      this.iterationCount = 0;
    }
    /** @type {TargetsArray} */
    this.targets = parsedTargets;
    /** @type {Number} */
    this.duration = iterationDuration === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue ? _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clampInfinity)(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
    /** @type {Callback<this>} */
    this.onRender = onRender || animDefaults.onRender;
    /** @type {EasingFunction} */
    this._ease = animEase;
    /** @type {Number} */
    this._delay = iterationDelay;
    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
    // this._delay = parent ? 0 : iterationDelay;
    // this._offset += parent ? iterationDelay : 0;
    /** @type {Number} */
    this.iterationDuration = iterationDuration;

    if (!this._autoplay && shouldTriggerRender) this.onRender(this);
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.normalizeTime)(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, (/** @type {Tween} */tween) => {
      // Rounding is necessary here to minimize floating point errors
      tween._updateDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.normalizeTime)(tween._updateDuration * timeScale);
      tween._changeDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.normalizeTime)(tween._changeDuration * timeScale);
      tween._currentTime *= timeScale;
      tween._startTime *= timeScale;
      tween._absoluteStartTime *= timeScale;
    });
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, (/** @type {Tween} */tween) => {
      const tweenFunc = tween._func;
      if (tweenFunc) {
        const ogValue = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getOriginalAnimatableValue)(tween.target, tween.property, tween._tweenType);
        (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(ogValue, _core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue);
        // TODO: Check for from / to Array based values here,
        (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposeRawValue)(tweenFunc(), toTargetObject);
        tween._fromNumbers = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue.d);
        tween._fromNumber = _core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue.n;
        tween._toNumbers = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(toTargetObject.d);
        tween._strings = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(toTargetObject.s);
        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025
        tween._toNumber = toTargetObject.o ? (0,_core_values_js__WEBPACK_IMPORTED_MODULE_4__.getRelativeValue)(_core_values_js__WEBPACK_IMPORTED_MODULE_4__.decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
      }
    });
    // This forces setter animations to render once
    if (this.duration === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue) this.restart();
    return this;
  }

  /**
   * Cancel the animation and revert all the values affected by this animation to their original state
   * @return {this}
   */
  revert() {
    super.revert();
    return (0,_core_styles_js__WEBPACK_IMPORTED_MODULE_5__.cleanInlineStyles)(this);
  }

  /**
   * @typedef {this & {then: null}} ResolvedJSAnimation
   */

  /**
   * @param  {Callback<ResolvedJSAnimation>} [callback]
   * @return Promise<this>
   */
  then(callback) {
    return super.then(callback);
  }

}

/**
 * @param {TargetsParam} targets
 * @param {AnimationParams} parameters
 * @return {JSAnimation}
 */
const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();




/***/ }),

/***/ "./node_modules/animejs/dist/modules/animation/composition.js":
/*!********************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/animation/composition.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   composeTween: () => (/* binding */ composeTween),
/* harmony export */   getTweenSiblings: () => (/* binding */ getTweenSiblings),
/* harmony export */   overrideTween: () => (/* binding */ overrideTween),
/* harmony export */   removeTargetsFromRenderable: () => (/* binding */ removeTargetsFromRenderable),
/* harmony export */   removeTweenSliblings: () => (/* binding */ removeTweenSliblings)
/* harmony export */ });
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _core_styles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/styles.js */ "./node_modules/animejs/dist/modules/core/styles.js");
/* harmony import */ var _engine_engine_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../engine/engine.js */ "./node_modules/animejs/dist/modules/engine/engine.js");
/* harmony import */ var _additive_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./additive.js */ "./node_modules/animejs/dist/modules/animation/additive.js");
/**
 * Anime.js - animation - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */







/**
 * @import {
 *   TweenReplaceLookups,
 *   TweenAdditiveLookups,
 *   TweenPropertySiblings,
 *   Tween,
 *   Target,
 *   TargetsArray,
 *   Renderable,
 * } from '../types/index.js'
 *
 * @import {
 *   JSAnimation,
 * } from '../animation/animation.js'
*/

const lookups = {
  /** @type {TweenReplaceLookups} */
  _rep: new WeakMap(),
  /** @type {TweenAdditiveLookups} */
  _add: new Map(),
};

/**
 * @param  {Target} target
 * @param  {String} property
 * @param  {String} lookup
 * @return {TweenPropertySiblings}
 */
const getTweenSiblings = (target, property, lookup = '_rep') => {
  const lookupMap = lookups[lookup];
  let targetLookup = lookupMap.get(target);
  if (!targetLookup) {
    targetLookup = {};
    lookupMap.set(target, targetLookup);
  }
  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
    _head: null,
    _tail: null,
  }
};

/**
 * @param  {Tween} p
 * @param  {Tween} c
 * @return {Number|Boolean}
 */
const addTweenSortMethod = (p, c) => {
  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
};

/**
 * @param {Tween} tween
 */
const overrideTween = tween => {
  tween._isOverlapped = 1;
  tween._isOverridden = 1;
  tween._changeDuration = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
  tween._currentTime = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
};

/**
 * @param  {Tween} tween
 * @param  {TweenPropertySiblings} siblings
 * @return {Tween}
 */
const composeTween = (tween, siblings) => {

  const tweenCompositionType = tween._composition;

  // Handle replaced tweens

  if (tweenCompositionType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.replace) {

    const tweenAbsStartTime = tween._absoluteStartTime;

    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');

    const prevSibling = tween._prevRep;

    // Update the previous siblings for composition replace tweens

    if (prevSibling) {

      const prevParent = prevSibling.parent;
      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;

      // Handle looped animations tween

      if (
        // Check if the previous tween is from a different animation
        tween.parent.id !== prevParent.id &&
        // Check if the animation has loops
        prevParent.iterationCount> 1 &&
        // Check if _absoluteChangeEndTime of last loop overlaps the current tween
        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
      ) {

        // TODO: Find a way to only override the iterations overlapping with the tween
        overrideTween(prevSibling);

        let prevPrevSibling = prevSibling._prevRep;

        // If the tween was part of a set of keyframes, override its siblings
        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
          overrideTween(prevPrevSibling);
          prevPrevSibling = prevPrevSibling._prevRep;
        }

      }

      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;

      if (prevAbsEndTime > absoluteUpdateStartTime) {

        const prevChangeStartTime = prevSibling._startTime;
        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
        // Rounding is necessary here to minimize floating point errors when working in seconds
        const updatedPrevChangeDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);

        prevSibling._changeDuration = updatedPrevChangeDuration;
        prevSibling._currentTime = updatedPrevChangeDuration;
        prevSibling._isOverlapped = 1;

        // Override the previous tween if its new _changeDuration is lower than minValue
        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough
        if (updatedPrevChangeDuration < _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue) {
          overrideTween(prevSibling);
        }
      }

      // Pause (and cancel) the parent if it only contains overlapped tweens

      let pausePrevParentAnimation = true;

      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(prevParent, (/** @type Tween */t) => {
        if (!t._isOverlapped) pausePrevParentAnimation = false;
      });

      if (pausePrevParentAnimation) {
        const prevParentTL = prevParent.parent;
        if (prevParentTL) {
          let pausePrevParentTL = true;
          (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(prevParentTL, (/** @type JSAnimation */a) => {
            if (a !== prevParent) {
              (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(a, (/** @type Tween */t) => {
                if (!t._isOverlapped) pausePrevParentTL = false;
              });
            }
          });
          if (pausePrevParentTL) {
            prevParentTL.cancel();
          }
        } else {
          prevParent.cancel();
          // Previously, calling .cancel() on a timeline child would affect the render order of other children
          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
          // This is no longer needed since timeline tween composition is now handled separately
          // Keeping this here for reference
          // prevParent.completed = true;
          // prevParent.pause();
        }
      }

    }

    // let nextSibling = tween._nextRep;

    // // All the next siblings are automatically overridden

    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     console.log(tween.id, nextSibling.id);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

  // Handle additive tweens composition

  } else if (tweenCompositionType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.blend) {

    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
    const additiveAnimation = (0,_additive_js__WEBPACK_IMPORTED_MODULE_4__.addAdditiveAnimation)(lookups._add);

    let lookupTween = additiveTweenSiblings._head;

    if (!lookupTween) {
      lookupTween = { ...tween };
      lookupTween._composition = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.replace;
      lookupTween._updateDuration = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
      lookupTween._startTime = 0;
      lookupTween._numbers = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(tween._fromNumbers);
      lookupTween._number = 0;
      lookupTween._next = null;
      lookupTween._prev = null;
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(additiveTweenSiblings, lookupTween);
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(additiveAnimation, lookupTween);
    }

    // Convert the values of TO to FROM and set TO to 0

    const toNumber = tween._toNumber;
    tween._fromNumber = lookupTween._fromNumber - toNumber;
    tween._toNumber = 0;
    tween._numbers = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(tween._fromNumbers);
    tween._number = 0;
    lookupTween._fromNumber = toNumber;

    if (tween._toNumbers) {
      const toNumbers = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(tween._toNumbers);
      if (toNumbers) {
        toNumbers.forEach((value, i) => {
          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
          tween._toNumbers[i] = 0;
        });
      }
      lookupTween._fromNumbers = toNumbers;
    }

    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');

  }

  return tween;

};

/**
 * @param  {Tween} tween
 * @return {Tween}
 */
const removeTweenSliblings = tween => {
  const tweenComposition = tween._composition;
  if (tweenComposition !== _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.none) {
    const tweenTarget = tween.target;
    const tweenProperty = tween.property;
    const replaceTweensLookup = lookups._rep;
    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
    if (tweenComposition === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.blend) {
      const addTweensLookup = lookups._add;
      const addTargetProps = addTweensLookup.get(tweenTarget);
      if (!addTargetProps) return;
      const additiveTweenSiblings = addTargetProps[tweenProperty];
      const additiveAnimation = _additive_js__WEBPACK_IMPORTED_MODULE_4__.additive.animation;
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
      // If only one tween is left in the additive lookup, it's the tween lookup
      const lookupTween = additiveTweenSiblings._head;
      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
        (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
        (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(additiveAnimation, lookupTween);
        let shouldClean = true;
        for (let prop in addTargetProps) {
          if (addTargetProps[prop]._head) {
            shouldClean = false;
            break;
          }
        }
        if (shouldClean) {
          addTweensLookup.delete(tweenTarget);
        }
      }
    }
  }
  return tween;
};

/**
 * @param  {TargetsArray} targetsArray
 * @param  {JSAnimation} animation
 * @param  {String} [propertyName]
 * @return {Boolean}
 */
const removeTargetsFromJSAnimation = (targetsArray, animation, propertyName) => {
  let tweensMatchesTargets = false;
  (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(animation, (/**@type {Tween} */tween) => {
    const tweenTarget = tween.target;
    if (targetsArray.includes(tweenTarget)) {
      const tweenName = tween.property;
      const tweenType = tween._tweenType;
      const normalizePropName = (0,_core_styles_js__WEBPACK_IMPORTED_MODULE_2__.sanitizePropertyName)(propertyName, tweenTarget, tweenType);
      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
        // Make sure to flag the previous CSS transform tween to renderTransform
        if (tween.parent._tail === tween &&
            tween._tweenType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM &&
            tween._prev &&
            tween._prev._tweenType === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM
        ) {
          tween._prev._renderTransforms = 1;
        }
        // Removes the tween from the selected animation
        (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(animation, tween);
        // Detach the tween from its siblings to make sure blended tweens are correctlly removed
        removeTweenSliblings(tween);
        tweensMatchesTargets = true;
      }
    }
  }, true);
  return tweensMatchesTargets;
};

/**
 * @param  {TargetsArray} targetsArray
 * @param  {Renderable} [renderable]
 * @param  {String} [propertyName]
 */
const removeTargetsFromRenderable = (targetsArray, renderable, propertyName) => {
  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : _engine_engine_js__WEBPACK_IMPORTED_MODULE_3__.engine);
  let removeMatches;
  if (parent._hasChildren) {
    let iterationDuration = 0;
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(parent, (/** @type {Renderable} */child) => {
      if (!child._hasChildren) {
        removeMatches = removeTargetsFromJSAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);
        // Remove the child from its parent if no tweens and no children left after the removal
        if (removeMatches && !child._head) {
          child.cancel();
          (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeChild)(parent, child);
        } else {
          // Calculate the new iterationDuration value to handle onComplete with last child in render()
          const childTLOffset = child._offset + child._delay;
          const childDur = childTLOffset + child.duration;
          if (childDur > iterationDuration) {
            iterationDuration = childDur;
          }
        }
      }
      // Make sure to also remove engine's children targets
      // NOTE: Avoid recursion?
      if (child._head) {
        removeTargetsFromRenderable(targetsArray, child, propertyName);
      } else {
        child._hasChildren = false;
      }
    }, true);
    // Update iterationDuration value to handle onComplete with last child in render()
    if (!(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(/** @type {Renderable} */(parent).iterationDuration)) {
      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;
    }
  } else {
    removeMatches = removeTargetsFromJSAnimation(
      targetsArray,
      /** @type {JSAnimation} */(parent),
      propertyName
    );
  }
  if (removeMatches && !parent._head) {
    parent._hasChildren = false;
    // Cancel the parent if there are no tweens and no children left after the removal
    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();
  }
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/clock.js":
/*!*********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/clock.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Clock: () => (/* binding */ Clock)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




/**
 * @import {
 *   Tickable,
 *   Tween,
 * } from '../types/index.js'
*/

/*
 * Base class to control framerate and playback rate.
 * Inherited by Engine, Timer, Animation and Timeline.
 */
class Clock {

  /** @param {Number} [initTime] */
  constructor(initTime = 0) {
    /** @type {Number} */
    this.deltaTime = 0;
    /** @type {Number} */
    this._currentTime = initTime;
    /** @type {Number} */
    this._elapsedTime = initTime;
    /** @type {Number} */
    this._startTime = initTime;
    /** @type {Number} */
    this._lastTime = initTime;
    /** @type {Number} */
    this._scheduledTime = 0;
    /** @type {Number} */
    this._frameDuration = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(_consts_js__WEBPACK_IMPORTED_MODULE_0__.K / _consts_js__WEBPACK_IMPORTED_MODULE_0__.maxFps, 0);
    /** @type {Number} */
    this._fps = _consts_js__WEBPACK_IMPORTED_MODULE_0__.maxFps;
    /** @type {Number} */
    this._speed = 1;
    /** @type {Boolean} */
    this._hasChildren = false;
    /** @type {Tickable|Tween} */
    this._head = null;
    /** @type {Tickable|Tween} */
    this._tail = null;
  }

  get fps() {
    return this._fps;
  }

  set fps(frameRate) {
    const previousFrameDuration = this._frameDuration;
    const fr = +frameRate;
    const fps = fr < _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : fr;
    const frameDuration = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(_consts_js__WEBPACK_IMPORTED_MODULE_0__.K / fps, 0);
    this._fps = fps;
    this._frameDuration = frameDuration;
    this._scheduledTime += frameDuration - previousFrameDuration;
  }

  get speed() {
    return this._speed;
  }

  set speed(playbackRate) {
    const pbr = +playbackRate;
    this._speed = pbr < _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : pbr;
  }

  /**
   * @param  {Number} time
   * @return {tickModes}
   */
  requestTick(time) {
    const scheduledTime = this._scheduledTime;
    const elapsedTime = this._elapsedTime;
    this._elapsedTime += (time - elapsedTime);
    // If the elapsed time is lower than the scheduled time
    // this means not enough time has passed to hit one frameDuration
    // so skip that frame
    if (elapsedTime < scheduledTime) return _consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.NONE;
    const frameDuration = this._frameDuration;
    const frameDelta = elapsedTime - scheduledTime;
    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
    // Skips ahead if the actual elapsed time is higher.
    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
    return _consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.AUTO;
  }

  /**
   * @param  {Number} time
   * @return {Number}
   */
  computeDeltaTime(time) {
    const delta = time - this._lastTime;
    this.deltaTime = delta;
    this._lastTime = time;
    return delta;
  }

}




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/colors.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/colors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertColorStringValuesToRgbaArray: () => (/* binding */ convertColorStringValuesToRgbaArray)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




/**
 * @import {
 *   ColorArray,
 * } from '../types/index.js'
*/

/**
 * RGB / RGBA Color value string -> RGBA values array
 * @param  {String} rgbValue
 * @return {ColorArray}
 */
const rgbToRgba = rgbValue => {
  const rgba = _consts_js__WEBPACK_IMPORTED_MODULE_0__.rgbExecRgx.exec(rgbValue) || _consts_js__WEBPACK_IMPORTED_MODULE_0__.rgbaExecRgx.exec(rgbValue);
  const a = !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(rgba[4]) ? +rgba[4] : 1;
  return [
    +rgba[1],
    +rgba[2],
    +rgba[3],
    a
  ]
};

/**
 * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
 * @param  {String} hexValue
 * @return {ColorArray}
 */
const hexToRgba = hexValue => {
  const hexLength = hexValue.length;
  const isShort = hexLength === 4 || hexLength === 5;
  return [
    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
  ]
};

/**
 * @param  {Number} p
 * @param  {Number} q
 * @param  {Number} t
 * @return {Number}
 */
const hue2rgb = (p, q, t) => {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  return t < 1 / 6 ? p + (q - p) * 6 * t :
         t < 1 / 2 ? q :
         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
         p;
};

/**
 * HSL / HSLA Color value string -> RGBA values array
 * @param  {String} hslValue
 * @return {ColorArray}
 */
const hslToRgba = hslValue => {
  const hsla = _consts_js__WEBPACK_IMPORTED_MODULE_0__.hslExecRgx.exec(hslValue) || _consts_js__WEBPACK_IMPORTED_MODULE_0__.hslaExecRgx.exec(hslValue);
  const h = +hsla[1] / 360;
  const s = +hsla[2] / 100;
  const l = +hsla[3] / 100;
  const a = !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(hsla[4]) ? +hsla[4] : 1;
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < .5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(hue2rgb(p, q, h + 1 / 3) * 255, 0);
    g = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(hue2rgb(p, q, h) * 255, 0);
    b = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(hue2rgb(p, q, h - 1 / 3) * 255, 0);
  }
  return [r, g, b, a];
};

/**
 * All in one color converter that converts a color string value into an array of RGBA values
 * @param  {String} colorString
 * @return {ColorArray}
 */
const convertColorStringValuesToRgbaArray = colorString => {
  return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isRgb)(colorString) ? rgbToRgba(colorString) :
         (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isHex)(colorString) ? hexToRgba(colorString) :
         (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isHsl)(colorString) ? hslToRgba(colorString) :
         [0, 0, 0, 1];
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/consts.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/consts.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ K),
/* harmony export */   compositionTypes: () => (/* binding */ compositionTypes),
/* harmony export */   cssVarPrefix: () => (/* binding */ cssVarPrefix),
/* harmony export */   cssVariableMatchRgx: () => (/* binding */ cssVariableMatchRgx),
/* harmony export */   digitWithExponentRgx: () => (/* binding */ digitWithExponentRgx),
/* harmony export */   doc: () => (/* binding */ doc),
/* harmony export */   emptyString: () => (/* binding */ emptyString),
/* harmony export */   hexTestRgx: () => (/* binding */ hexTestRgx),
/* harmony export */   hslExecRgx: () => (/* binding */ hslExecRgx),
/* harmony export */   hslaExecRgx: () => (/* binding */ hslaExecRgx),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isDomSymbol: () => (/* binding */ isDomSymbol),
/* harmony export */   isRegisteredTargetSymbol: () => (/* binding */ isRegisteredTargetSymbol),
/* harmony export */   isSvgSymbol: () => (/* binding */ isSvgSymbol),
/* harmony export */   lowerCaseRgx: () => (/* binding */ lowerCaseRgx),
/* harmony export */   maxFps: () => (/* binding */ maxFps),
/* harmony export */   maxValue: () => (/* binding */ maxValue),
/* harmony export */   minValue: () => (/* binding */ minValue),
/* harmony export */   morphPointsSymbol: () => (/* binding */ morphPointsSymbol),
/* harmony export */   noop: () => (/* binding */ noop),
/* harmony export */   proxyTargetSymbol: () => (/* binding */ proxyTargetSymbol),
/* harmony export */   relativeValuesExecRgx: () => (/* binding */ relativeValuesExecRgx),
/* harmony export */   rgbExecRgx: () => (/* binding */ rgbExecRgx),
/* harmony export */   rgbaExecRgx: () => (/* binding */ rgbaExecRgx),
/* harmony export */   shortTransforms: () => (/* binding */ shortTransforms),
/* harmony export */   tickModes: () => (/* binding */ tickModes),
/* harmony export */   transformsExecRgx: () => (/* binding */ transformsExecRgx),
/* harmony export */   transformsFragmentStrings: () => (/* binding */ transformsFragmentStrings),
/* harmony export */   transformsSymbol: () => (/* binding */ transformsSymbol),
/* harmony export */   tweenTypes: () => (/* binding */ tweenTypes),
/* harmony export */   unitsExecRgx: () => (/* binding */ unitsExecRgx),
/* harmony export */   validTransforms: () => (/* binding */ validTransforms),
/* harmony export */   valueTypes: () => (/* binding */ valueTypes),
/* harmony export */   win: () => (/* binding */ win)
/* harmony export */ });
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */

// Environments

// TODO: Do we need to check if we're running inside a worker ?
const isBrowser = typeof window !== 'undefined';

/** @type {Window & {AnimeJS: Array}|null} */
const win = isBrowser ? /** @type {Window & {AnimeJS: Array}} */(/** @type {unknown} */(window)) : null;

/** @type {Document|null} */
const doc = isBrowser ? document : null;

// Enums

/** @enum {Number} */
const tweenTypes = {
  OBJECT: 0,
  ATTRIBUTE: 1,
  CSS: 2,
  TRANSFORM: 3,
  CSS_VAR: 4,
};

/** @enum {Number} */
const valueTypes = {
  NUMBER: 0,
  UNIT: 1,
  COLOR: 2,
  COMPLEX: 3,
};

/** @enum {Number} */
const tickModes = {
  NONE: 0,
  AUTO: 1,
  FORCE: 2,
};

/** @enum {Number} */
const compositionTypes = {
  replace: 0,
  none: 1,
  blend: 2,
};

// Cache symbols

const isRegisteredTargetSymbol = Symbol();
const isDomSymbol = Symbol();
const isSvgSymbol = Symbol();
const transformsSymbol = Symbol();
const morphPointsSymbol = Symbol();
const proxyTargetSymbol = Symbol();

// Numbers

const minValue = 1e-11;
const maxValue = 1e12;
const K = 1e3;
const maxFps = 120;

// Strings

const emptyString = '';
const cssVarPrefix = 'var(';

const shortTransforms = /*#__PURE__*/ (() => {
  const map = new Map();
  map.set('x', 'translateX');
  map.set('y', 'translateY');
  map.set('z', 'translateZ');
  return map;
})();

const validTransforms = [
  'translateX',
  'translateY',
  'translateZ',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'scale',
  'scaleX',
  'scaleY',
  'scaleZ',
  'skew',
  'skewX',
  'skewY',
  'matrix',
  'matrix3d',
  'perspective',
];

const transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});

// Functions

/** @return {void} */
const noop = () => {};

// Regex

const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
// export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
// export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
const lowerCaseRgx = /([a-z])([A-Z])/g;
const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
const relativeValuesExecRgx = /(\*=|\+=|-=)/;
const cssVariableMatchRgx = /var\(\s*(--[\w-]+)(?:\s*,\s*([^)]+))?\s*\)/;




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/globals.js":
/*!***********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/globals.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults),
/* harmony export */   globalVersions: () => (/* binding */ globalVersions),
/* harmony export */   globals: () => (/* binding */ globals),
/* harmony export */   scope: () => (/* binding */ scope)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */



/**
 * @import {
 *   DefaultsParams,
 *   DOMTarget,
 * } from '../types/index.js'
 *
 * @import {
 *   Scope,
 * } from '../scope/index.js'
*/

/** @type {DefaultsParams} */
const defaults = {
  id: null,
  keyframes: null,
  playbackEase: null,
  playbackRate: 1,
  frameRate: _consts_js__WEBPACK_IMPORTED_MODULE_0__.maxFps,
  loop: 0,
  reversed: false,
  alternate: false,
  autoplay: true,
  persist: false,
  duration: _consts_js__WEBPACK_IMPORTED_MODULE_0__.K,
  delay: 0,
  loopDelay: 0,
  ease: 'out(2)',
  composition: _consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.replace,
  modifier: v => v,
  onBegin: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onBeforeUpdate: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onUpdate: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onLoop: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onPause: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onComplete: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
  onRender: _consts_js__WEBPACK_IMPORTED_MODULE_0__.noop,
};

const scope = {
  /** @type {Scope} */
  current: null,
  /** @type {Document|DOMTarget} */
  root: _consts_js__WEBPACK_IMPORTED_MODULE_0__.doc,
};

const globals = {
  /** @type {DefaultsParams} */
  defaults,
  /** @type {Number} */
  precision: 4,
  /** @type {Number} equals 1 in ms mode, 0.001 in s mode */
  timeScale: 1,
  /** @type {Number} */
  tickThreshold: 200,
};

const globalVersions = { version: '4.2.2', engine: null };

if (_consts_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
  if (!_consts_js__WEBPACK_IMPORTED_MODULE_0__.win.AnimeJS) _consts_js__WEBPACK_IMPORTED_MODULE_0__.win.AnimeJS = [];
  _consts_js__WEBPACK_IMPORTED_MODULE_0__.win.AnimeJS.push(globalVersions);
}




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/helpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PI: () => (/* binding */ PI),
/* harmony export */   _round: () => (/* binding */ _round),
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   addChild: () => (/* binding */ addChild),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   clampInfinity: () => (/* binding */ clampInfinity),
/* harmony export */   cloneArray: () => (/* binding */ cloneArray),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEachChildren: () => (/* binding */ forEachChildren),
/* harmony export */   isArr: () => (/* binding */ isArr),
/* harmony export */   isCol: () => (/* binding */ isCol),
/* harmony export */   isFnc: () => (/* binding */ isFnc),
/* harmony export */   isHex: () => (/* binding */ isHex),
/* harmony export */   isHsl: () => (/* binding */ isHsl),
/* harmony export */   isKey: () => (/* binding */ isKey),
/* harmony export */   isNil: () => (/* binding */ isNil),
/* harmony export */   isNum: () => (/* binding */ isNum),
/* harmony export */   isObj: () => (/* binding */ isObj),
/* harmony export */   isRgb: () => (/* binding */ isRgb),
/* harmony export */   isStr: () => (/* binding */ isStr),
/* harmony export */   isSvg: () => (/* binding */ isSvg),
/* harmony export */   isUnd: () => (/* binding */ isUnd),
/* harmony export */   isValidSVGAttribute: () => (/* binding */ isValidSVGAttribute),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   mergeObjects: () => (/* binding */ mergeObjects),
/* harmony export */   normalizeTime: () => (/* binding */ normalizeTime),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   parseNumber: () => (/* binding */ parseNumber),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   removeChild: () => (/* binding */ removeChild),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   snap: () => (/* binding */ snap),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   stringStartsWith: () => (/* binding */ stringStartsWith),
/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




/**
 * @import {
 *   Target,
 *   DOMTarget,
 * } from '../types/index.js'
*/

// Strings

/**
 * @param  {String} str
 * @return {String}
 */
const toLowerCase = str => str.replace(_consts_js__WEBPACK_IMPORTED_MODULE_0__.lowerCaseRgx, '$1-$2').toLowerCase();

/**
 * Prioritize this method instead of regex when possible
 * @param  {String} str
 * @param  {String} sub
 * @return {Boolean}
 */
const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;

// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.
const now = Date.now;

// Types checkers

const isArr = Array.isArray;
/**@param {any} a @return {a is Record<String, any>} */
const isObj = a => a && a.constructor === Object;
/**@param {any} a @return {a is Number} */
const isNum = a => typeof a === 'number' && !isNaN(a);
/**@param {any} a @return {a is String} */
const isStr = a => typeof a === 'string';
/**@param {any} a @return {a is Function} */
const isFnc = a => typeof a === 'function';
/**@param {any} a @return {a is undefined} */
const isUnd = a => typeof a === 'undefined';
/**@param {any} a @return {a is null | undefined} */
const isNil = a => isUnd(a) || a === null;
/**@param {any} a @return {a is SVGElement} */
const isSvg = a => _consts_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser && a instanceof SVGElement;
/**@param {any} a @return {Boolean} */
const isHex = a => _consts_js__WEBPACK_IMPORTED_MODULE_0__.hexTestRgx.test(a);
/**@param {any} a @return {Boolean} */
const isRgb = a => stringStartsWith(a, 'rgb');
/**@param {any} a @return {Boolean} */
const isHsl = a => stringStartsWith(a, 'hsl');
/**@param {any} a @return {Boolean} */
const isCol = a => isHex(a) || isRgb(a) || isHsl(a);
/**@param {any} a @return {Boolean} */
const isKey = a => !_globals_js__WEBPACK_IMPORTED_MODULE_1__.globals.defaults.hasOwnProperty(a);

// SVG

// Consider the following as CSS animation
// CSS opacity animation has better default values (opacity: 1 instead of 0))
// rotate is more commonly intended to be used as a transform
const svgCssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];

/**
 * @param  {Target} el
 * @param  {String} propertyName
 * @return {Boolean}
 */
const isValidSVGAttribute = (el, propertyName) => {
  if (svgCssReservedProperties.includes(propertyName)) return false;
  if (el.getAttribute(propertyName) || propertyName in el) {
    if (propertyName === 'scale') { // Scale
      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);
      // Only consider scale as a valid SVG attribute on filter element
      return elParentNode && elParentNode.tagName === 'filter';
    }
    return true;
  }
};

// Number

/**
 * @param  {Number|String} str
 * @return {Number}
 */
const parseNumber = str => isStr(str) ?
  parseFloat(/** @type {String} */(str)) :
  /** @type {Number} */(str);

// Math

const pow = Math.pow;
const sqrt = Math.sqrt;
const sin = Math.sin;
const cos = Math.cos;
const abs = Math.abs;
const exp = Math.exp;
const ceil = Math.ceil;
const floor = Math.floor;
const asin = Math.asin;
const max = Math.max;
const atan2 = Math.atan2;
const PI = Math.PI;
const _round = Math.round;

/**
 * Clamps a value between min and max bounds
 *
 * @param  {Number} v - Value to clamp
 * @param  {Number} min - Minimum boundary
 * @param  {Number} max - Maximum boundary
 * @return {Number}
 */
const clamp = (v, min, max) => v < min ? min : v > max ? max : v;

const powCache = {};

/**
 * Rounds a number to specified decimal places
 *
 * @param  {Number} v - Value to round
 * @param  {Number} decimalLength - Number of decimal places
 * @return {Number}
 */
const round = (v, decimalLength) => {
  if (decimalLength < 0) return v;
  if (!decimalLength) return _round(v);
  let p = powCache[decimalLength];
  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
  return _round(v * p) / p;
};

/**
 * Snaps a value to nearest increment or array value
 *
 * @param  {Number} v - Value to snap
 * @param  {Number|Array<Number>} increment - Step size or array of snap points
 * @return {Number}
 */
const snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;

/**
 * Linear interpolation between two values
 *
 * @param  {Number} start - Starting value
 * @param  {Number} end - Ending value
 * @param  {Number} factor - Interpolation factor in the range [0, 1]
 * @return {Number} The interpolated value
 */
const lerp = (start, end, factor) => start + (end - start) * factor;

/**
 * Replaces infinity with maximum safe value
 *
 * @param  {Number} v - Value to check
 * @return {Number}
 */
const clampInfinity = v => v === Infinity ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.maxValue : v === -Infinity ? -_consts_js__WEBPACK_IMPORTED_MODULE_0__.maxValue : v;

/**
 * Normalizes time value with minimum threshold
 *
 * @param  {Number} v - Time value to normalize
 * @return {Number}
 */
const normalizeTime = v => v <= _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : clampInfinity(round(v, 11));

// Arrays

/**
 * @template T
 * @param    {T[]} a
 * @return   {T[]}
 */
const cloneArray = a => isArr(a) ? [ ...a ] : a;

// Objects

/**
 * @template T
 * @template U
 * @param    {T} o1
 * @param    {U} o2
 * @return   {T & U}
 */
const mergeObjects = (o1, o2) => {
  const merged = /** @type {T & U} */({ ...o1 });
  for (let p in o2) {
    const o1p = /** @type {T & U} */(o1)[p];
    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;
  }  return merged;
};

// Linked lists

/**
 * @param  {Object} parent
 * @param  {Function} callback
 * @param  {Boolean} [reverse]
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
const forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {
  let next = parent._head;
  let adjustedNextProp = nextProp;
  if (reverse) {
    next = parent._tail;
    adjustedNextProp = prevProp;
  }
  while (next) {
    const currentNext = next[adjustedNextProp];
    callback(next);
    next = currentNext;
  }
};

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
const removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {
  const prev = child[prevProp];
  const next = child[nextProp];
  prev ? prev[nextProp] = next : parent._head = next;
  next ? next[prevProp] = prev : parent._tail = prev;
  child[prevProp] = null;
  child[nextProp] = null;
};

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {Function} [sortMethod]
 * @param  {String} prevProp
 * @param  {String} nextProp
 * @return {void}
 */
const addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {
  let prev = parent._tail;
  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
  const next = prev ? prev[nextProp] : parent._head;
  prev ? prev[nextProp] = child : parent._head = child;
  next ? next[prevProp] = child : parent._tail = child;
  child[prevProp] = prev;
  child[nextProp] = next;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/render.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/render.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   tick: () => (/* binding */ tick)
/* harmony export */ });
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */





/**
 *   @import {
 *   Tickable,
 *   Renderable,
 *   CallbackArgument,
 *   Tween,
 *   DOMTarget,
 * } from '../types/index.js'
*/

/**
 * @import {
 *   JSAnimation,
 * } from '../animation/animation.js'
*/

/**
 * @import {
 *   Timeline,
 * } from '../timeline/timeline.js'
*/

/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {tickModes} tickMode
 * @return {Number}
 */
const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {

  const parent = tickable.parent;
  const duration = tickable.duration;
  const completed = tickable.completed;
  const iterationDuration = tickable.iterationDuration;
  const iterationCount = tickable.iterationCount;
  const _currentIteration = tickable._currentIteration;
  const _loopDelay = tickable._loopDelay;
  const _reversed = tickable._reversed;
  const _alternate = tickable._alternate;
  const _hasChildren = tickable._hasChildren;
  const tickableDelay = tickable._delay;
  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime

  const tickableEndTime = tickableDelay + iterationDuration;
  const tickableAbsoluteTime = time - tickableDelay;
  const tickablePrevTime = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(tickablePrevAbsoluteTime, -tickableDelay, duration);
  const tickableCurrentTime = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(tickableAbsoluteTime, -tickableDelay, duration);
  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
  const isCurrentTimeAboveZero = tickableCurrentTime > 0;
  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
  const isSetter = duration <= _consts_js__WEBPACK_IMPORTED_MODULE_1__.minValue;
  const forcedTick = tickMode === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tickModes.FORCE;

  let isOdd = 0;
  let iterationElapsedTime = tickableAbsoluteTime;
  // Render checks
  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer
  let hasRendered = 0;

  // Execute the "expensive" iterations calculations only when necessary
  if (iterationCount > 1) {
    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers
    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
    tickable._currentIteration = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(currentIteration, 0, iterationCount);
    // Prevent the iteration count to go above the max iterations when reaching the end of the animation
    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
    isOdd = tickable._currentIteration % 2;
    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
  }

  // Checks if exactly one of _reversed and (_alternate && isOdd) is true
  const isReversed = _reversed ^ (_alternate && isOdd);
  const _ease = /** @type {Renderable} */(tickable)._ease;
  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;

  tickable._currentTime = tickableAbsoluteTime;
  tickable._iterationTime = iterationTime;
  tickable.backwards = isRunningBackwards;

  if (isCurrentTimeAboveZero && !tickable.began) {
    tickable.began = true;
    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
      tickable.onBegin(/** @type {CallbackArgument} */(tickable));
    }
  } else if (tickableAbsoluteTime <= 0) {
    tickable.began = false;
  }

  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function
  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values
  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
    tickable.onLoop(/** @type {CallbackArgument} */(tickable));
  }

  if (
    forcedTick ||
    tickMode === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tickModes.AUTO && (
      time >= tickableDelay && time <= tickableEndTime || // Normal render
      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state
    ) ||
    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||
    iterationTime <= tickableDelay && tickablePrevTime > 0 ||
    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped
  ) {

    if (isCurrentTimeAboveZero) {
      // Trigger onUpdate callback before rendering
      tickable.computeDeltaTime(tickablePrevTime);
      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));
    }

    // Start tweens rendering
    if (!_hasChildren) {

      // Time has jumped more than globals.tickThreshold so consider this tick manual
      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= _globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.tickThreshold;
      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;

      // Only Animation can have tweens, Timer returns undefined
      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);
      let tweenTarget;
      let tweenStyle;
      let tweenTargetTransforms;
      let tweenTargetTransformsProperties;
      let tweenTransformsNeedUpdate = 0;

      while (tween) {

        const tweenComposition = tween._composition;
        const tweenCurrentTime = tween._currentTime;
        const tweenChangeDuration = tween._changeDuration;
        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
        const tweenNextRep = tween._nextRep;
        const tweenPrevRep = tween._prevRep;
        const tweenHasComposition = tweenComposition !== _consts_js__WEBPACK_IMPORTED_MODULE_1__.compositionTypes.none;

        if ((forcedRender || (
            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&
            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)
          )) && (!tweenHasComposition || (
            !tween._isOverridden &&
            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&
            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&
            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))
          ))
        ) {

          const tweenNewTime = tween._currentTime = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(iterationTime - tween._startTime, 0, tweenChangeDuration);
          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
          const tweenModifier = tween._modifier;
          const tweenValueType = tween._valueType;
          const tweenType = tween._tweenType;
          const tweenIsObject = tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tweenTypes.OBJECT;
          const tweenIsNumber = tweenValueType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.valueTypes.NUMBER;
          // Only round the in-between frames values if the final value is a string
          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : _globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.precision;

          // Recompose tween value
          /** @type {String|Number} */
          let value;
          /** @type {Number} */
          let number;

          if (tweenIsNumber) {
            value = number = /** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));
          } else if (tweenValueType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.valueTypes.UNIT) {
            // Rounding the values speed up string composition
            number = /** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));
            value = `${number}${tween._unit}`;
          } else if (tweenValueType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.valueTypes.COLOR) {
            const fn = tween._fromNumbers;
            const tn = tween._toNumbers;
            const r = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(/** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(fn[0], tn[0], tweenProgress))), 0, 255), 0);
            const g = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(/** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(fn[1], tn[1], tweenProgress))), 0, 255), 0);
            const b = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(/** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(fn[2], tn[2], tweenProgress))), 0, 255), 0);
            const a = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(/** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);
            value = `rgba(${r},${g},${b},${a})`;
            if (tweenHasComposition) {
              const ns = tween._numbers;
              ns[0] = r;
              ns[1] = g;
              ns[2] = b;
              ns[3] = a;
            }
          } else if (tweenValueType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.valueTypes.COMPLEX) {
            value = tween._strings[0];
            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
              const n = /** @type {Number} */(tweenModifier((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.lerp)(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));
              const s = tween._strings[j + 1];
              value += `${s ? n + s : n}`;
              if (tweenHasComposition) {
                tween._numbers[j] = n;
              }
            }
          }

          // For additive tweens and Animatables
          if (tweenHasComposition) {
            tween._number = number;
          }

          if (!internalRender && tweenComposition !== _consts_js__WEBPACK_IMPORTED_MODULE_1__.compositionTypes.blend) {

            const tweenProperty = tween.property;
            tweenTarget = tween.target;

            if (tweenIsObject) {
              tweenTarget[tweenProperty] = value;
            } else if (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tweenTypes.ATTRIBUTE) {
              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));
            } else {
              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;
              if (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tweenTypes.TRANSFORM) {
                if (tweenTarget !== tweenTargetTransforms) {
                  tweenTargetTransforms = tweenTarget;
                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.
                  tweenTargetTransformsProperties = tweenTarget[_consts_js__WEBPACK_IMPORTED_MODULE_1__.transformsSymbol];
                }
                tweenTargetTransformsProperties[tweenProperty] = value;
                tweenTransformsNeedUpdate = 1;
              } else if (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tweenTypes.CSS) {
                tweenStyle[tweenProperty] = value;
              } else if (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_1__.tweenTypes.CSS_VAR) {
                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));
              }
            }

            if (isCurrentTimeAboveZero) hasRendered = 1;

          } else {
            // Used for composing timeline tweens without having to do a real render
            tween._value = value;
          }

        }

        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax
        // to reduce memory usage on string composition
        if (tweenTransformsNeedUpdate && tween._renderTransforms) {
          let str = _consts_js__WEBPACK_IMPORTED_MODULE_1__.emptyString;
          for (let key in tweenTargetTransformsProperties) {
            str += `${_consts_js__WEBPACK_IMPORTED_MODULE_1__.transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;
          }
          tweenStyle.transform = str;
          tweenTransformsNeedUpdate = 0;
        }

        tween = tween._next;
      }

      if (!muteCallbacks && hasRendered) {
        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));
      }
    }

    if (!muteCallbacks && isCurrentTimeAboveZero) {
      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));
    }

  }

  // End tweens rendering

  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards
  if (parent && isSetter) {
    if (!muteCallbacks && (
      // (tickableAbsoluteTime > 0 instead) of (tickableAbsoluteTime >= duration) to prevent floating point precision issues
      // see: https://github.com/juliangarnier/anime/issues/1088
      (parent.began && !isRunningBackwards && tickableAbsoluteTime > 0 && !completed) ||
      (isRunningBackwards && tickableAbsoluteTime <= _consts_js__WEBPACK_IMPORTED_MODULE_1__.minValue && completed)
    )) {
      tickable.onComplete(/** @type {CallbackArgument} */(tickable));
      tickable.completed = !isRunningBackwards;
    }
  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops
  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
    if (iterationCount === Infinity) {
      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer
      tickable._startTime += tickable.duration;
    } else if (tickable._currentIteration >= iterationCount - 1) {
      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick
      tickable.paused = true;
      if (!completed && !_hasChildren) {
        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function
        tickable.completed = true;
        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
          tickable.onComplete(/** @type {CallbackArgument} */(tickable));
          tickable._resolve(/** @type {CallbackArgument} */(tickable));
        }
      }
    }
  // Otherwise set the completed flag to false
  } else {
    tickable.completed = false;
  }

  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?
  return hasRendered;
};

/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {Number} tickMode
 * @return {void}
 */
const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
  const _currentIteration = tickable._currentIteration;
  render(tickable, time, muteCallbacks, internalRender, tickMode);
  if (tickable._hasChildren) {
    const tl = /** @type {Timeline} */(tickable);
    const tlIsRunningBackwards = tl.backwards;
    const tlChildrenTime = internalRender ? time : tl._iterationTime;
    const tlCildrenTickTime = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.now)();

    let tlChildrenHasRendered = 0;
    let tlChildrenHaveCompleted = true;

    // If the timeline has looped forward, we need to manually triggers children skipped callbacks
    if (!internalRender && tl._currentIteration !== _currentIteration) {
      const tlIterationDuration = tl.iterationDuration;
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.forEachChildren)(tl, (/** @type {JSAnimation} */child) => {
        if (!tlIsRunningBackwards) {
          // Force an internal render to trigger the callbacks if the child has not completed on loop
          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
            render(child, tlIterationDuration, muteCallbacks, 1, _consts_js__WEBPACK_IMPORTED_MODULE_1__.tickModes.FORCE);
          }
          // Reset their began and completed flags to allow retrigering callbacks on the next iteration
          child.began = false;
          child.completed = false;
        } else {
          const childDuration = child.duration;
          const childStartTime = child._offset + child._delay;
          const childEndTime = childStartTime + childDuration;
          // Triggers the onComplete callback on reverse for children on the edges of the timeline
          if (!muteCallbacks && childDuration <= _consts_js__WEBPACK_IMPORTED_MODULE_1__.minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
            child.onComplete(child);
          }
        }
      });
      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));
    }

    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.forEachChildren)(tl, (/** @type {JSAnimation} */child) => {
      const childTime = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.round)((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds
      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
    }, tlIsRunningBackwards);

    // Renders on timeline are triggered by its children so it needs to be set after rendering the children
    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));

    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end
    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {
      // Make sure the paused flag is false in case it has been skipped in the render function
      tl.paused = true;
      if (!tl.completed) {
        tl.completed = true;
        if (!muteCallbacks) {
          tl.onComplete(/** @type {CallbackArgument} */(tl));
          tl._resolve(/** @type {CallbackArgument} */(tl));
        }
      }
    }
  }
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/styles.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/styles.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanInlineStyles: () => (/* binding */ cleanInlineStyles),
/* harmony export */   sanitizePropertyName: () => (/* binding */ sanitizePropertyName)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




/**
 * @import {
 *   JSAnimation,
 * } from '../animation/animation.js'
*/

/**
* @import {
*   Target,
*   DOMTarget,
*   Renderable,
*   Tween,
* } from '../types/index.js'
*/

const propertyNamesCache = {};

/**
 * @param  {String} propertyName
 * @param  {Target} target
 * @param  {tweenTypes} tweenType
 * @return {String}
 */
const sanitizePropertyName = (propertyName, target, tweenType) => {
  if (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM) {
    const t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.shortTransforms.get(propertyName);
    return t ? t : propertyName;
  } else if (
    tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.CSS ||
    // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
    // but properties like "baseFrequency" should stay in lowerCamelCase
    (tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.ATTRIBUTE && ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isSvg)(target) && propertyName in /** @type {DOMTarget} */(target).style))
  ) {
    const cachedPropertyName = propertyNamesCache[propertyName];
    if (cachedPropertyName) {
      return cachedPropertyName;
    } else {
      const lowerCaseName = propertyName ? (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.toLowerCase)(propertyName) : propertyName;
      propertyNamesCache[propertyName] = lowerCaseName;
      return lowerCaseName;
    }
  } else {
    return propertyName;
  }
};

/**
 * @template {Renderable} T
 * @param {T} renderable
 * @return {T}
 */
const cleanInlineStyles = renderable => {
  // Allow cleanInlineStyles() to be called on timelines
  if (renderable._hasChildren) {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(renderable, cleanInlineStyles, true);
  } else {
    const animation = /** @type {JSAnimation} */(renderable);
    animation.pause();
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(animation, (/** @type {Tween} */tween) => {
      const tweenProperty = tween.property;
      const tweenTarget = tween.target;
      if (tweenTarget[_consts_js__WEBPACK_IMPORTED_MODULE_0__.isDomSymbol]) {
        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;
        const originalInlinedValue = tween._inlineValue;
        const tweenHadNoInlineValue = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isNil)(originalInlinedValue) || originalInlinedValue === _consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString;
        if (tween._tweenType === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM) {
          const cachedTransforms = tweenTarget[_consts_js__WEBPACK_IMPORTED_MODULE_0__.transformsSymbol];
          if (tweenHadNoInlineValue) {
            delete cachedTransforms[tweenProperty];
          } else {
            cachedTransforms[tweenProperty] = originalInlinedValue;
          }
          if (tween._renderTransforms) {
            if (!Object.keys(cachedTransforms).length) {
              targetStyle.removeProperty('transform');
            } else {
              let str = _consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString;
              for (let key in cachedTransforms) {
                str += _consts_js__WEBPACK_IMPORTED_MODULE_0__.transformsFragmentStrings[key] + cachedTransforms[key] + ') ';
              }
              targetStyle.transform = str;
            }
          }
        } else {
          if (tweenHadNoInlineValue) {
            targetStyle.removeProperty((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.toLowerCase)(tweenProperty));
          } else {
            targetStyle[tweenProperty] = originalInlinedValue;
          }
        }
        if (animation._tail === tween) {
          animation.targets.forEach(t => {
            if (t.getAttribute && t.getAttribute('style') === _consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString) {
              t.removeAttribute('style');
            }          });
        }
      }
    });
  }
  return renderable;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/targets.js":
/*!***********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/targets.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNodeList: () => (/* binding */ getNodeList),
/* harmony export */   parseTargets: () => (/* binding */ parseTargets),
/* harmony export */   registerTargets: () => (/* binding */ registerTargets)
/* harmony export */ });
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */





/**
* @import {
*   DOMTarget,
*   DOMTargetsParam,
*   JSTargetsArray,
*   TargetsParam,
*   JSTargetsParam,
*   TargetsArray,
*   DOMTargetsArray,
* } from '../types/index.js'
*/

/**
 * @param  {DOMTargetsParam|TargetsParam} v
 * @return {NodeList|HTMLCollection}
 */
function getNodeList(v) {
  const n = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isStr)(v) ? _globals_js__WEBPACK_IMPORTED_MODULE_0__.scope.root.querySelectorAll(v) : v;
  if (n instanceof NodeList || n instanceof HTMLCollection) return n;
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function parseTargets(targets) {
  if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isNil)(targets)) return /** @type {TargetsArray} */([]);
  if (!_consts_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser) return /** @type {JSTargetsArray} */((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isArr)(targets) && targets.flat(Infinity) || [targets]);
  if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isArr)(targets)) {
    const flattened = targets.flat(Infinity);
    /** @type {TargetsArray} */
    const parsed = [];
    for (let i = 0, l = flattened.length; i < l; i++) {
      const item = flattened[i];
      if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isNil)(item)) {
        const nodeList = getNodeList(item);
        if (nodeList) {
          for (let j = 0, jl = nodeList.length; j < jl; j++) {
            const subItem = nodeList[j];
            if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isNil)(subItem)) {
              let isDuplicate = false;
              for (let k = 0, kl = parsed.length; k < kl; k++) {
                if (parsed[k] === subItem) {
                  isDuplicate = true;
                  break;
                }
              }
              if (!isDuplicate) {
                parsed.push(subItem);
              }
            }
          }
        } else {
          let isDuplicate = false;
          for (let j = 0, jl = parsed.length; j < jl; j++) {
            if (parsed[j] === item) {
              isDuplicate = true;
              break;
            }
          }
          if (!isDuplicate) {
            parsed.push(item);
          }
        }
      }
    }
    return parsed;
  }
  const nodeList = getNodeList(targets);
  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));
  return /** @type {TargetsArray} */([targets]);
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function registerTargets(targets) {
  const parsedTargetsArray = parseTargets(targets);
  const parsedTargetsLength = parsedTargetsArray.length;
  if (parsedTargetsLength) {
    for (let i = 0; i < parsedTargetsLength; i++) {
      const target = parsedTargetsArray[i];
      if (!target[_consts_js__WEBPACK_IMPORTED_MODULE_1__.isRegisteredTargetSymbol]) {
        target[_consts_js__WEBPACK_IMPORTED_MODULE_1__.isRegisteredTargetSymbol] = true;
        const isSvgType = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isSvg)(target);
        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;
        if (isDom) {
          target[_consts_js__WEBPACK_IMPORTED_MODULE_1__.isDomSymbol] = true;
          target[_consts_js__WEBPACK_IMPORTED_MODULE_1__.isSvgSymbol] = isSvgType;
          target[_consts_js__WEBPACK_IMPORTED_MODULE_1__.transformsSymbol] = {};
        }
      }
    }
  }
  return parsedTargetsArray;
}




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/transforms.js":
/*!**************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/transforms.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseInlineTransforms: () => (/* binding */ parseInlineTransforms)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




/**
* @import {
*   DOMTarget,
* } from '../types/index.js'
*/

/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const parseInlineTransforms = (target, propName, animationInlineStyles) => {
  const inlineTransforms = target.style.transform;
  let inlinedStylesPropertyValue;
  if (inlineTransforms) {
    const cachedTransforms = target[_consts_js__WEBPACK_IMPORTED_MODULE_0__.transformsSymbol];
    let t; while (t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.transformsExecRgx.exec(inlineTransforms)) {
      const inlinePropertyName = t[1];
      // const inlinePropertyValue = t[2];
      const inlinePropertyValue = t[2].slice(1, -1);
      cachedTransforms[inlinePropertyName] = inlinePropertyValue;
      if (inlinePropertyName === propName) {
        inlinedStylesPropertyValue = inlinePropertyValue;
        // Store the new parsed inline styles if animationInlineStyles is provided
        if (animationInlineStyles) {
          animationInlineStyles[propName] = inlinePropertyValue;
        }
      }
    }
  }
  return inlineTransforms && !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(propName, 'scale') ? '1' :
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(propName, 'rotate') || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(propName, 'skew') ? '0deg' : '0px';
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/units.js":
/*!*********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/units.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertValueUnit: () => (/* binding */ convertValueUnit)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */




const angleUnitsMap = { 'deg': 1, 'rad': 180 / _helpers_js__WEBPACK_IMPORTED_MODULE_1__.PI, 'turn': 360 };
const convertedValuesCache = {};

/**
* @import {
*   DOMTarget,
*   TweenDecomposedValue,
* } from '../types/index.js'
*/

/**
 * @param  {DOMTarget} el
 * @param  {TweenDecomposedValue} decomposedValue
 * @param  {String} unit
 * @param  {Boolean} [force]
 * @return {TweenDecomposedValue}
 */
const convertValueUnit = (el, decomposedValue, unit, force = false) => {
  const currentUnit = decomposedValue.u;
  const currentNumber = decomposedValue.n;
  if (decomposedValue.t === _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary
    return decomposedValue;
  }
  const cachedKey = currentNumber + currentUnit + unit;
  const cached = convertedValuesCache[cachedKey];
  if (!(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(cached) && !force) {
    decomposedValue.n = cached;
  } else {
    let convertedValue;
    if (currentUnit in angleUnitsMap) {
      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
    } else {
      const baseline = 100;
      const tempEl = /** @type {DOMTarget} */(el.cloneNode());
      const parentNode = el.parentNode;
      const parentEl = (parentNode && (parentNode !== _consts_js__WEBPACK_IMPORTED_MODULE_0__.doc)) ? parentNode : _consts_js__WEBPACK_IMPORTED_MODULE_0__.doc.body;
      parentEl.appendChild(tempEl);
      const elStyle = tempEl.style;
      elStyle.width = baseline + currentUnit;
      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      elStyle.width = baseline + unit;
      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      const factor = currentUnitWidth / newUnitWidth;
      parentEl.removeChild(tempEl);
      convertedValue = factor * currentNumber;
    }
    decomposedValue.n = convertedValue;
    convertedValuesCache[cachedKey] = convertedValue;
  }
  decomposedValue.t === _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT;
  decomposedValue.u = unit;
  return decomposedValue;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/core/values.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/core/values.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDecomposedValueTargetObject: () => (/* binding */ createDecomposedValueTargetObject),
/* harmony export */   decomposeRawValue: () => (/* binding */ decomposeRawValue),
/* harmony export */   decomposeTweenValue: () => (/* binding */ decomposeTweenValue),
/* harmony export */   decomposedOriginalValue: () => (/* binding */ decomposedOriginalValue),
/* harmony export */   getFunctionValue: () => (/* binding */ getFunctionValue),
/* harmony export */   getOriginalAnimatableValue: () => (/* binding */ getOriginalAnimatableValue),
/* harmony export */   getRelativeValue: () => (/* binding */ getRelativeValue),
/* harmony export */   getTweenType: () => (/* binding */ getTweenType),
/* harmony export */   setValue: () => (/* binding */ setValue)
/* harmony export */ });
/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _transforms_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transforms.js */ "./node_modules/animejs/dist/modules/core/transforms.js");
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors.js */ "./node_modules/animejs/dist/modules/core/colors.js");
/**
 * Anime.js - core - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */






/**
* @import {
*   Target,
*   DOMTarget,
*   Tween,
*   TweenPropValue,
*   TweenDecomposedValue,
* } from '../types/index.js'
*/

/**
 * @template T, D
 * @param {T|undefined} targetValue
 * @param {D} defaultValue
 * @return {T|D}
 */
const setValue = (targetValue, defaultValue) => {
  return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(targetValue) ? defaultValue : targetValue;
};

/**
 * @param  {TweenPropValue} value
 * @param  {Target} target
 * @param  {Number} index
 * @param  {Number} total
 * @param  {Object} [store]
 * @return {any}
 */
const getFunctionValue = (value, target, index, total, store) => {
  let func;
  if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isFnc)(value)) {
    func = () => {
      const computed = /** @type {Function} */(value)(target, index, total);
      // Fallback to 0 if the function returns undefined / NaN / null / false / 0
      return !isNaN(+computed) ? +computed : computed || 0;
    };
  } else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(value) && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(value, _consts_js__WEBPACK_IMPORTED_MODULE_0__.cssVarPrefix)) {
    func = () => {
      const match = value.match(_consts_js__WEBPACK_IMPORTED_MODULE_0__.cssVariableMatchRgx);
      const cssVarName = match[1];
      const fallbackValue = match[2];
      let computed = getComputedStyle(/** @type {HTMLElement} */(target))?.getPropertyValue(cssVarName);
      // Use fallback if CSS variable is not set or empty
      if ((!computed || computed.trim() === _consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString) && fallbackValue) {
        computed = fallbackValue.trim();
      }
      return computed || 0;
    };
  } else {
    return value;
  }
  if (store) store.func = func;
  return func();
};

/**
 * @param  {Target} target
 * @param  {String} prop
 * @return {tweenTypes}
 */
const getTweenType = (target, prop) => {
  return !target[_consts_js__WEBPACK_IMPORTED_MODULE_0__.isDomSymbol] ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.OBJECT :
    // Handle SVG attributes
    target[_consts_js__WEBPACK_IMPORTED_MODULE_0__.isSvgSymbol] && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isValidSVGAttribute)(target, prop) ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.ATTRIBUTE :
    // Handle CSS Transform properties differently than CSS to allow individual animations
    _consts_js__WEBPACK_IMPORTED_MODULE_0__.validTransforms.includes(prop) || _consts_js__WEBPACK_IMPORTED_MODULE_0__.shortTransforms.get(prop) ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM :
    // CSS variables
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(prop, '--') ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.CSS_VAR :
    // All other CSS properties
    prop in /** @type {DOMTarget} */(target).style ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.CSS :
    // Handle other DOM Attributes
    prop in target ? _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.OBJECT :
    _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.ATTRIBUTE;
};

/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const getCSSValue = (target, propName, animationInlineStyles) => {
  const inlineStyles = target.style[propName];
  if (inlineStyles && animationInlineStyles) {
    animationInlineStyles[propName] = inlineStyles;
  }
  const value = inlineStyles || getComputedStyle(target[_consts_js__WEBPACK_IMPORTED_MODULE_0__.proxyTargetSymbol] || target).getPropertyValue(propName);
  return value === 'auto' ? '0' : value;
};

/**
 * @param {Target} target
 * @param {String} propName
 * @param {tweenTypes} [tweenType]
 * @param {Object|void} [animationInlineStyles]
 * @return {String|Number}
 */
const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
  const type = !(0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(tweenType) ? tweenType : getTweenType(target, propName);
  return type === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.OBJECT ? target[propName] || 0 :
         type === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :
         type === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.TRANSFORM ? (0,_transforms_js__WEBPACK_IMPORTED_MODULE_2__.parseInlineTransforms)(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :
         type === _consts_js__WEBPACK_IMPORTED_MODULE_0__.tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :
         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);
};

/**
 * @param  {Number} x
 * @param  {Number} y
 * @param  {String} operator
 * @return {Number}
 */
const getRelativeValue = (x, y, operator) => {
  return operator === '-' ? x - y :
         operator === '+' ? x + y :
         x * y;
};

/** @return {TweenDecomposedValue} */
const createDecomposedValueTargetObject = () => {
  return {
    /** @type {valueTypes} */
    t: _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.NUMBER,
    n: 0,
    u: null,
    o: null,
    d: null,
    s: null,
  }
};

/**
 * @param  {String|Number} rawValue
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeRawValue = (rawValue, targetObject) => {
  /** @type {valueTypes} */
  targetObject.t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.NUMBER;
  targetObject.n = 0;
  targetObject.u = null;
  targetObject.o = null;
  targetObject.d = null;
  targetObject.s = null;
  if (!rawValue) return targetObject;
  const num = +rawValue;
  if (!isNaN(num)) {
    // It's a number
    targetObject.n = num;
    return targetObject;
  } else {
    // let str = /** @type {String} */(rawValue).trim();
    let str = /** @type {String} */(rawValue);
    // Parsing operators (+=, -=, *=) manually is much faster than using regex here
    if (str[1] === '=') {
      targetObject.o = str[0];
      str = str.slice(2);
    }
    // Skip exec regex if the value type is complex or color to avoid long regex backtracking
    const unitMatch = str.includes(' ') ? false : _consts_js__WEBPACK_IMPORTED_MODULE_0__.unitsExecRgx.exec(str);
    if (unitMatch) {
      // Has a number and a unit
      targetObject.t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.UNIT;
      targetObject.n = +unitMatch[1];
      targetObject.u = unitMatch[2];
      return targetObject;
    } else if (targetObject.o) {
      // Has an operator (+=, -=, *=)
      targetObject.n = +str;
      return targetObject;
    } else if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isCol)(str)) {
      // Is a color
      targetObject.t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COLOR;
      targetObject.d = (0,_colors_js__WEBPACK_IMPORTED_MODULE_3__.convertColorStringValuesToRgbaArray)(str);
      return targetObject;
    } else {
      // Is a more complex string (generally svg coords, calc() or filters CSS values)
      const matchedNumbers = str.match(_consts_js__WEBPACK_IMPORTED_MODULE_0__.digitWithExponentRgx);
      targetObject.t = _consts_js__WEBPACK_IMPORTED_MODULE_0__.valueTypes.COMPLEX;
      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
      targetObject.s = str.split(_consts_js__WEBPACK_IMPORTED_MODULE_0__.digitWithExponentRgx) || [];
      return targetObject;
    }
  }
};

/**
 * @param  {Tween} tween
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeTweenValue = (tween, targetObject) => {
  targetObject.t = tween._valueType;
  targetObject.n = tween._toNumber;
  targetObject.u = tween._unit;
  targetObject.o = null;
  targetObject.d = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(tween._toNumbers);
  targetObject.s = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cloneArray)(tween._strings);
  return targetObject;
};

const decomposedOriginalValue = createDecomposedValueTargetObject();




/***/ }),

/***/ "./node_modules/animejs/dist/modules/easings/eases/parser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/easings/eases/parser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   easeInPower: () => (/* binding */ easeInPower),
/* harmony export */   easeTypes: () => (/* binding */ easeTypes),
/* harmony export */   eases: () => (/* binding */ eases),
/* harmony export */   parseEase: () => (/* binding */ parseEase),
/* harmony export */   parseEaseString: () => (/* binding */ parseEaseString)
/* harmony export */ });
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../none.js */ "./node_modules/animejs/dist/modules/easings/none.js");
/**
 * Anime.js - easings - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */





/**
 * @import {
 *   EasingFunction,
 *   EasingFunctionWithParams,
 *   EasingParam,
 *   BackEasing,
 *   ElasticEasing,
 *   PowerEasing,
 * } from '../../types/index.js'
*/


/** @type {PowerEasing} */
const easeInPower = (p = 1.68) => t => (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)(t, +p);

/**
 * @callback EaseType
 * @param {EasingFunction} Ease
 * @return {EasingFunction}
 */

/** @type {Record<String, EaseType>} */
const easeTypes = {
  in: easeIn => t => easeIn(t),
  out: easeIn => t => 1 - easeIn(1 - t),
  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,
};

/**
 * Easing functions adapted and simplified from https://robertpenner.com/easing/
 * (c) 2001 Robert Penner
 */

const halfPI = _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.PI / 2;
const doublePI = _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.PI * 2;

/** @type {Record<String, EasingFunctionWithParams|EasingFunction>} */
const easeInFunctions = {
  [_core_consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString]: easeInPower,
  Quad: easeInPower(2),
  Cubic: easeInPower(3),
  Quart: easeInPower(4),
  Quint: easeInPower(5),
  /** @type {EasingFunction} */
  Sine: t => 1 - (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.cos)(t * halfPI),
  /** @type {EasingFunction} */
  Circ: t => 1 - (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(1 - t * t),
  /** @type {EasingFunction} */
  Expo: t => t ? (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)(2, 10 * t - 10) : 0,
  /** @type {EasingFunction} */
  Bounce: t => {
    let pow2, b = 4;
    while (t < ((pow2 = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)(2, --b)) - 1) / 11);
    return 1 / (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)(4, 3 - b) - 7.5625 * (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)((pow2 * 3 - 2) / 22 - t, 2);
  },
  /** @type {BackEasing} */
  Back: (overshoot = 1.7) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,
  /** @type {ElasticEasing} */
  Elastic: (amplitude = 1, period = .3) => {
    const a = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(+amplitude, 1, 10);
    const p = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(+period, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue, 2);
    const s = (p / doublePI) * (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.asin)(1 / a);
    const e = doublePI / p;
    return t => t === 0 || t === 1 ? t : -a * (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.pow)(2, -10 * (1 - t)) * (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.sin)(((1 - t) - s) * e);
  }
};

/**
 * @typedef  {Object} EasesFunctions
 * @property {typeof none} linear
 * @property {typeof none} none
 * @property {PowerEasing} in
 * @property {PowerEasing} out
 * @property {PowerEasing} inOut
 * @property {PowerEasing} outIn
 * @property {EasingFunction} inQuad
 * @property {EasingFunction} outQuad
 * @property {EasingFunction} inOutQuad
 * @property {EasingFunction} outInQuad
 * @property {EasingFunction} inCubic
 * @property {EasingFunction} outCubic
 * @property {EasingFunction} inOutCubic
 * @property {EasingFunction} outInCubic
 * @property {EasingFunction} inQuart
 * @property {EasingFunction} outQuart
 * @property {EasingFunction} inOutQuart
 * @property {EasingFunction} outInQuart
 * @property {EasingFunction} inQuint
 * @property {EasingFunction} outQuint
 * @property {EasingFunction} inOutQuint
 * @property {EasingFunction} outInQuint
 * @property {EasingFunction} inSine
 * @property {EasingFunction} outSine
 * @property {EasingFunction} inOutSine
 * @property {EasingFunction} outInSine
 * @property {EasingFunction} inCirc
 * @property {EasingFunction} outCirc
 * @property {EasingFunction} inOutCirc
 * @property {EasingFunction} outInCirc
 * @property {EasingFunction} inExpo
 * @property {EasingFunction} outExpo
 * @property {EasingFunction} inOutExpo
 * @property {EasingFunction} outInExpo
 * @property {EasingFunction} inBounce
 * @property {EasingFunction} outBounce
 * @property {EasingFunction} inOutBounce
 * @property {EasingFunction} outInBounce
 * @property {BackEasing} inBack
 * @property {BackEasing} outBack
 * @property {BackEasing} inOutBack
 * @property {BackEasing} outInBack
 * @property {ElasticEasing} inElastic
 * @property {ElasticEasing} outElastic
 * @property {ElasticEasing} inOutElastic
 * @property {ElasticEasing} outInElastic
 */

const eases = (/*#__PURE__ */ (() => {
  const list = { linear: _none_js__WEBPACK_IMPORTED_MODULE_2__.none, none: _none_js__WEBPACK_IMPORTED_MODULE_2__.none };
  for (let type in easeTypes) {
    for (let name in easeInFunctions) {
      const easeIn = easeInFunctions[name];
      const easeType = easeTypes[type];
      list[type + name] = /** @type {EasingFunctionWithParams|EasingFunction} */(
        name === _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.emptyString || name === 'Back' || name === 'Elastic' ?
        (a, b) => easeType(/** @type {EasingFunctionWithParams} */(easeIn)(a, b)) :
        easeType(/** @type {EasingFunction} */(easeIn))
      );
    }
  }
  return /** @type {EasesFunctions} */(list);
})());

/** @type {Record<String, EasingFunction>} */
const easesLookups = { linear: _none_js__WEBPACK_IMPORTED_MODULE_2__.none, none: _none_js__WEBPACK_IMPORTED_MODULE_2__.none };

/**
 * @param  {String} string
 * @return {EasingFunction}
 */
const parseEaseString = (string) => {
  if (easesLookups[string]) return easesLookups[string];
  if (string.indexOf('(') <= -1) {
    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');
    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasingFunctionWithParams} */(eases[string])() : eases[string]);
    return parsedFn ? easesLookups[string] = parsedFn : _none_js__WEBPACK_IMPORTED_MODULE_2__.none;
  } else {
    const split = string.slice(0, -1).split('(');
    const parsedFn = /** @type {EasingFunctionWithParams} */(eases[split[0]]);
    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : _none_js__WEBPACK_IMPORTED_MODULE_2__.none;
  }
};

const deprecated = ['steps(', 'irregular(', 'linear(', 'cubicBezier('];

/**
 * @param  {EasingParam} ease
 * @return {EasingFunction}
 */
const parseEase = ease => {
  if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(ease)) {
    for (let i = 0, l = deprecated.length; i < l; i++) {
      if ((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringStartsWith)(ease, deprecated[i])) {
        console.warn(`String syntax for \`ease: "${ease}"\` has been removed from the core and replaced by importing and passing the easing function directly: \`ease: ${ease}\``);
        return _none_js__WEBPACK_IMPORTED_MODULE_2__.none;
      }
    }
  }
  const easeFunc = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isFnc)(ease) ? ease : (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(ease) ? parseEaseString(/** @type {String} */(ease)) : _none_js__WEBPACK_IMPORTED_MODULE_2__.none;
  return easeFunc;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/easings/none.js":
/*!***********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/easings/none.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   none: () => (/* binding */ none)
/* harmony export */ });
/**
 * Anime.js - easings - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */

/**
 * @import {
 *   EasingFunction,
 * } from '../types/index.js'
*/

/** @type {EasingFunction} */
const none = t => t;




/***/ }),

/***/ "./node_modules/animejs/dist/modules/engine/engine.js":
/*!************************************************************!*\
  !*** ./node_modules/animejs/dist/modules/engine/engine.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   engine: () => (/* binding */ engine)
/* harmony export */ });
/* harmony import */ var _core_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _core_clock_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/clock.js */ "./node_modules/animejs/dist/modules/core/clock.js");
/* harmony import */ var _core_render_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/render.js */ "./node_modules/animejs/dist/modules/core/render.js");
/* harmony import */ var _animation_additive_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../animation/additive.js */ "./node_modules/animejs/dist/modules/animation/additive.js");
/**
 * Anime.js - engine - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */








/**
 * @import {
 *   DefaultsParams,
 * } from '../types/index.js'
*/

/**
 * @import {
 *   Tickable,
 * } from '../types/index.js'
*/

const engineTickMethod = /*#__PURE__*/ (() => _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? requestAnimationFrame : setImmediate)();
const engineCancelMethod = /*#__PURE__*/ (() => _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? cancelAnimationFrame : clearImmediate)();

class Engine extends _core_clock_js__WEBPACK_IMPORTED_MODULE_3__.Clock {

  /** @param {Number} [initTime] */
  constructor(initTime) {
    super(initTime);
    this.useDefaultMainLoop = true;
    this.pauseOnDocumentHidden = true;
    /** @type {DefaultsParams} */
    this.defaults = _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.defaults;
    // this.paused = isBrowser && doc.hidden ? true  : false;
    this.paused = true;
    /** @type {Number|NodeJS.Immediate} */
    this.reqId = 0;
  }

  update() {
    const time = this._currentTime = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.now)();
    if (this.requestTick(time)) {
      this.computeDeltaTime(time);
      const engineSpeed = this._speed;
      const engineFps = this._fps;
      let activeTickable = /** @type {Tickable} */(this._head);
      while (activeTickable) {
        const nextTickable = activeTickable._next;
        if (!activeTickable.paused) {
          (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(
            activeTickable,
            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,
            0, // !muteCallbacks
            0, // !internalRender
            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.tickModes.AUTO
          );
        } else {
          (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.removeChild)(this, activeTickable);
          this._hasChildren = !!this._tail;
          activeTickable._running = false;
          if (activeTickable.completed && !activeTickable._cancelled) {
            activeTickable.cancel();
          }
        }
        activeTickable = nextTickable;
      }
      _animation_additive_js__WEBPACK_IMPORTED_MODULE_5__.additive.update();
    }
  }

  wake() {
    if (this.useDefaultMainLoop && !this.reqId) {
      // Imediatly request a tick to update engine._elapsedTime and get accurate offsetPosition calculation in timer.js
      this.requestTick((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.now)());
      this.reqId = engineTickMethod(tickEngine);
    }
    return this;
  }

  pause() {
    if (!this.reqId) return;
    this.paused = true;
    return killEngine();
  }

  resume() {
    if (!this.paused) return;
    this.paused = false;
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.forEachChildren)(this, (/** @type {Tickable} */child) => child.resetTime());
    return this.wake();
  }

  // Getter and setter for speed
  get speed() {
    return this._speed * (_core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.timeScale === 1 ? 1 : _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.K);
  }

  set speed(playbackRate) {
    this._speed = playbackRate * _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.timeScale;
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.forEachChildren)(this, (/** @type {Tickable} */child) => child.speed = child._speed);
  }

  // Getter and setter for timeUnit
  get timeUnit() {
    return _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.timeScale === 1 ? 'ms' : 's';
  }

  set timeUnit(unit) {
    const secondsScale = 0.001;
    const isSecond = unit === 's';
    const newScale = isSecond ? secondsScale : 1;
    if (_core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.timeScale !== newScale) {
      _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.timeScale = newScale;
      _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.tickThreshold = 200 * newScale;
      const scaleFactor = isSecond ? secondsScale : _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.K;
      /** @type {Number} */
      (this.defaults.duration) *= scaleFactor;
      this._speed *= scaleFactor;
    }
  }

  // Getter and setter for precision
  get precision() {
    return _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.precision;
  }

  set precision(precision) {
    _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globals.precision = precision;
  }

}

const engine = /*#__PURE__*/(() => {
  const engine = new Engine((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_2__.now)());
  if (_core_consts_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser) {
    _core_globals_js__WEBPACK_IMPORTED_MODULE_0__.globalVersions.engine = engine;
    _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.doc.addEventListener('visibilitychange', () => {
      if (!engine.pauseOnDocumentHidden) return;
      _core_consts_js__WEBPACK_IMPORTED_MODULE_1__.doc.hidden ? engine.pause() : engine.resume();
    });
  }
  return engine;
})();


const tickEngine = () => {
  if (engine._head) {
    engine.reqId = engineTickMethod(tickEngine);
    engine.update();
  } else {
    engine.reqId = 0;
  }
};

const killEngine = () => {
  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));
  engine.reqId = 0;
  return engine;
};




/***/ }),

/***/ "./node_modules/animejs/dist/modules/timer/timer.js":
/*!**********************************************************!*\
  !*** ./node_modules/animejs/dist/modules/timer/timer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   createTimer: () => (/* binding */ createTimer)
/* harmony export */ });
/* harmony import */ var _core_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/consts.js */ "./node_modules/animejs/dist/modules/core/consts.js");
/* harmony import */ var _core_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/helpers.js */ "./node_modules/animejs/dist/modules/core/helpers.js");
/* harmony import */ var _core_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/globals.js */ "./node_modules/animejs/dist/modules/core/globals.js");
/* harmony import */ var _core_values_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/values.js */ "./node_modules/animejs/dist/modules/core/values.js");
/* harmony import */ var _core_render_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/render.js */ "./node_modules/animejs/dist/modules/core/render.js");
/* harmony import */ var _animation_composition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../animation/composition.js */ "./node_modules/animejs/dist/modules/animation/composition.js");
/* harmony import */ var _core_clock_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/clock.js */ "./node_modules/animejs/dist/modules/core/clock.js");
/* harmony import */ var _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../engine/engine.js */ "./node_modules/animejs/dist/modules/engine/engine.js");
/**
 * Anime.js - timer - ESM
 * @version v4.2.2
 * @license MIT
 * @copyright 2025 - Julian Garnier
 */










/**
 * @import {
 *   Callback,
 *   TimerParams,
 *   Renderable,
 *   Tween,
 * } from '../types/index.js'
*/

/**
 * @import {
 *   ScrollObserver,
 * } from '../events/scroll.js'
*/

/**
 * @import {
 *   Timeline,
 * } from '../timeline/timeline.js'
*/

/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const resetTimerProperties = timer => {
  timer.paused = true;
  timer.began = false;
  timer.completed = false;
  return timer;
};

/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const reviveTimer = timer => {
  if (!timer._cancelled) return timer;
  if (timer._hasChildren) {
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(timer, reviveTimer);
  } else {
    (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(timer, (/** @type {Tween} tween */tween) => {
      if (tween._composition !== _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.compositionTypes.none) {
        (0,_animation_composition_js__WEBPACK_IMPORTED_MODULE_5__.composeTween)(tween, (0,_animation_composition_js__WEBPACK_IMPORTED_MODULE_5__.getTweenSiblings)(tween.target, tween.property));
      }
    });
  }
  timer._cancelled = 0;
  return timer;
};

let timerId = 0;

/**
 * Base class used to create Timers, Animations and Timelines
 */
class Timer extends _core_clock_js__WEBPACK_IMPORTED_MODULE_6__.Clock {
  /**
   * @param {TimerParams} [parameters]
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   */
  constructor(parameters = {}, parent = null, parentPosition = 0) {

    super(0);

    const {
      id,
      delay,
      duration,
      reversed,
      alternate,
      loop,
      loopDelay,
      autoplay,
      frameRate,
      playbackRate,
      onComplete,
      onLoop,
      onPause,
      onBegin,
      onBeforeUpdate,
      onUpdate,
    } = parameters;

    if (_core_globals_js__WEBPACK_IMPORTED_MODULE_2__.scope.current) _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.scope.current.register(this);

    const timerInitTime = parent ? 0 : _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine._elapsedTime;
    const timerDefaults = parent ? parent.defaults : _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.defaults;
    const timerDelay = /** @type {Number} */((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isFnc)(delay) || (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(delay) ? timerDefaults.delay : +delay);
    const timerDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isFnc)(duration) || (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(duration) ? Infinity : +duration;
    const timerLoop = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(loop, timerDefaults.loop);
    const timerLoopDelay = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(loopDelay, timerDefaults.loopDelay);
    const timerIterationCount = timerLoop === true ||
                                timerLoop === Infinity ||
                                /** @type {Number} */(timerLoop) < 0 ? Infinity :
                                /** @type {Number} */(timerLoop) + 1;

    let offsetPosition = 0;

    if (parent) {
      offsetPosition = parentPosition;
    } else {
      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime
      // to avoid big gaps with the following offsetPosition calculation
      if (!_engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine.reqId) _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine.requestTick((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.now)());
      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit
      offsetPosition = (_engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine._elapsedTime - _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine._startTime) * _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.timeScale;
    }

    // Timer's parameters
    this.id = !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(id) ? id : ++timerId;
    /** @type {Timeline} */
    this.parent = parent;
    // Total duration of the timer
    this.duration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clampInfinity)(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
    /** @type {Boolean} */
    this.backwards = false;
    /** @type {Boolean} */
    this.paused = true;
    /** @type {Boolean} */
    this.began = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Callback<this>} */
    this.onBegin = onBegin || timerDefaults.onBegin;
    /** @type {Callback<this>} */
    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
    /** @type {Callback<this>} */
    this.onUpdate = onUpdate || timerDefaults.onUpdate;
    /** @type {Callback<this>} */
    this.onLoop = onLoop || timerDefaults.onLoop;
    /** @type {Callback<this>} */
    this.onPause = onPause || timerDefaults.onPause;
    /** @type {Callback<this>} */
    this.onComplete = onComplete || timerDefaults.onComplete;
    /** @type {Number} */
    this.iterationDuration = timerDuration; // Duration of one loop
    /** @type {Number} */
    this.iterationCount = timerIterationCount; // Number of loops
    /** @type {Boolean|ScrollObserver} */
    this._autoplay = parent ? false : (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(autoplay, timerDefaults.autoplay);
    /** @type {Number} */
    this._offset = offsetPosition;
    /** @type {Number} */
    this._delay = timerDelay;
    /** @type {Number} */
    this._loopDelay = timerLoopDelay;
    /** @type {Number} */
    this._iterationTime = 0;
    /** @type {Number} */
    this._currentIteration = 0; // Current loop index
    /** @type {Function} */
    this._resolve = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.noop; // Used by .then()
    /** @type {Boolean} */
    this._running = false;
    /** @type {Number} */
    this._reversed = +(0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(reversed, timerDefaults.reversed);
    /** @type {Number} */
    this._reverse = this._reversed;
    /** @type {Number} */
    this._cancelled = 0;
    /** @type {Boolean} */
    this._alternate = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(alternate, timerDefaults.alternate);
    /** @type {Renderable} */
    this._prev = null;
    /** @type {Renderable} */
    this._next = null;

    // Clock's parameters
    /** @type {Number} */
    this._elapsedTime = timerInitTime;
    /** @type {Number} */
    this._startTime = timerInitTime;
    /** @type {Number} */
    this._lastTime = timerInitTime;
    /** @type {Number} */
    this._fps = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(frameRate, timerDefaults.frameRate);
    /** @type {Number} */
    this._speed = (0,_core_values_js__WEBPACK_IMPORTED_MODULE_3__.setValue)(playbackRate, timerDefaults.playbackRate);
  }

  get cancelled() {
    return !!this._cancelled;
  }

  set cancelled(cancelled) {
    cancelled ? this.cancel() : this.reset(true).play();
  }

  get currentTime() {
    return (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(this._currentTime, _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.precision), -this._delay, this.duration);
  }

  set currentTime(time) {
    const paused = this.paused;
    // Pausing the timer is necessary to avoid time jumps on a running instance
    this.pause().seek(+time);
    if (!paused) this.resume();
  }

  get iterationCurrentTime() {
    return (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(this._iterationTime, _core_globals_js__WEBPACK_IMPORTED_MODULE_2__.globals.precision);
  }

  set iterationCurrentTime(time) {
    this.currentTime = (this.iterationDuration * this._currentIteration) + time;
  }

  get progress() {
    return (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(this._currentTime / this.duration, 10), 0, 1);
  }

  set progress(progress) {
    this.currentTime = this.duration * progress;
  }

  get iterationProgress() {
    return (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)((0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.round)(this._iterationTime / this.iterationDuration, 10), 0, 1);
  }

  set iterationProgress(progress) {
    const iterationDuration = this.iterationDuration;
    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);
  }

  get currentIteration() {
    return this._currentIteration;
  }

  set currentIteration(iterationCount) {
    this.currentTime = (this.iterationDuration * (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(+iterationCount, 0, this.iterationCount - 1));
  }

  get reversed() {
    return !!this._reversed;
  }

  set reversed(reverse) {
    reverse ? this.reverse() : this.play();
  }

  get speed() {
    return super.speed;
  }

  set speed(playbackRate) {
    super.speed = playbackRate;
    this.resetTime();
  }

  /**
   * @param  {Boolean} [softReset]
   * @return {this}
   */
  reset(softReset = false) {
    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings
    reviveTimer(this);
    if (this._reversed && !this._reverse) this.reversed = false;
    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden
    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order
    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?
    this._iterationTime = this.iterationDuration;
    // Set tickMode to tickModes.FORCE to force rendering
    (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(this, 0, 1, ~~softReset, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.FORCE);
    // Reset timer properties after revive / render to make sure the props are not updated again
    resetTimerProperties(this);
    // Also reset children properties
    if (this._hasChildren) {
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, resetTimerProperties);
    }
    return this;
  }

  /**
   * @param  {Boolean} internalRender
   * @return {this}
   */
  init(internalRender = false) {
    this.fps = this._fps;
    this.speed = this._speed;
    // Manually calling .init() on timelines should render all children intial state
    // Forces all children to render once then render to 0 when reseted
    if (!internalRender && this._hasChildren) {
      (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(this, this.duration, 1, ~~internalRender, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.FORCE);
    }
    this.reset(internalRender);
    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link
    const autoplay = this._autoplay;
    if (autoplay === true) {
      this.resume();
    } else if (autoplay && !(0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.isUnd)(/** @type {ScrollObserver} */(autoplay).linked)) {
      /** @type {ScrollObserver} */(autoplay).link(this);
    }
    return this;
  }

  /** @return {this} */
  resetTime() {
    const timeScale = 1 / (this._speed * _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine._speed);
    // TODO: See if we can safely use engine._elapsedTime here
    // if (!engine.reqId) engine.requestTick(now())
    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;
    this._startTime = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.now)() - (this._currentTime + this._delay) * timeScale;
    return this;
  }

  /** @return {this} */
  pause() {
    if (this.paused) return this;
    this.paused = true;
    this.onPause(this);
    return this;
  }

  /** @return {this} */
  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // We can safely imediatly render a timer that has no duration and no children
    if (this.duration <= _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue && !this._hasChildren) {
      (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(this, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue, 0, 0, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.FORCE);
    } else {
      if (!this._running) {
        (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addChild)(_engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine, this);
        _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine._hasChildren = true;
        this._running = true;
      }
      this.resetTime();
      // Forces the timer to advance by at least one frame when the next tick occurs
      this._startTime -= 12;
      _engine_engine_js__WEBPACK_IMPORTED_MODULE_7__.engine.wake();
    }
    return this;
  }

  /** @return {this} */
  restart() {
    return this.reset().resume();
  }

  /**
   * @param  {Number} time
   * @param  {Boolean|Number} [muteCallbacks]
   * @param  {Boolean|Number} [internalRender]
   * @return {this}
   */
  seek(time, muteCallbacks = 0, internalRender = 0) {
    // Recompose the tween siblings in case the timer has been cancelled
    reviveTimer(this);
    // If you seek a completed animation, otherwise the next play will starts at 0
    this.completed = false;
    const isPaused = this.paused;
    this.paused = true;
    // timer, time, muteCallbacks, internalRender, tickMode
    (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(this, time + this._delay, ~~muteCallbacks, ~~internalRender, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.AUTO);
    return isPaused ? this : this.resume();
  }

  /** @return {this} */
  alternate() {
    const reversed = this._reversed;
    const count = this.iterationCount;
    const duration = this.iterationDuration;
    // Calculate the maximum iterations possible given the iteration duration
    const iterations = count === Infinity ? (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.floor)(_core_consts_js__WEBPACK_IMPORTED_MODULE_0__.maxValue / duration) : count;
    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
    if (count === Infinity) {
      // Handle infinite loops to loop on themself
      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
    } else {
      this.seek((duration * iterations) - this._currentTime);
    }
    this.resetTime();
    return this;
  }

  /** @return {this} */
  play() {
    if (this._reversed) this.alternate();
    return this.resume();
  }

  /** @return {this} */
  reverse() {
    if (!this._reversed) this.alternate();
    return this.resume();
  }

  // TODO: Move all the animation / tweens / children related code to Animation / Timeline

  /** @return {this} */
  cancel() {
    if (this._hasChildren) {
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, (/** @type {Renderable} */child) => child.cancel(), true);
    } else {
      (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.forEachChildren)(this, _animation_composition_js__WEBPACK_IMPORTED_MODULE_5__.removeTweenSliblings);
    }
    this._cancelled = 1;
    // Pausing the timer removes it from the engine
    return this.pause();
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    const normlizedDuration = (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.normalizeTime)(newDuration);
    if (currentDuration === normlizedDuration) return this;
    const timeScale = newDuration / currentDuration;
    const isSetter = newDuration <= _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue;
    this.duration = isSetter ? _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : normlizedDuration;
    this.iterationDuration = isSetter ? _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.minValue : (0,_core_helpers_js__WEBPACK_IMPORTED_MODULE_1__.normalizeTime)(this.iterationDuration * timeScale);
    this._offset *= timeScale;
    this._delay *= timeScale;
    this._loopDelay *= timeScale;
    return this;
  }

 /**
   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
   * @return {this}
   */
  revert() {
    (0,_core_render_js__WEBPACK_IMPORTED_MODULE_4__.tick)(this, 0, 1, 0, _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.tickModes.AUTO);
    const ap = /** @type {ScrollObserver} */(this._autoplay);
    if (ap && ap.linked && ap.linked === this) ap.revert();
    return this.cancel();
  }

 /**
   * Imediatly completes the timer, cancels it and triggers the onComplete callback
   * @return {this}
   */
  complete() {
    return this.seek(this.duration).cancel();
  }

  /**
   * @typedef {this & {then: null}} ResolvedTimer
   */

  /**
   * @param  {Callback<ResolvedTimer>} [callback]
   * @return Promise<this>
   */
  then(callback = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.noop) {
    const then = this.then;
    const onResolve = () => {
      // this.then = null prevents infinite recursion if returned by an async function
      // https://github.com/juliangarnierorg/anime-beta/issues/26
      this.then = null;
      callback(/** @type {ResolvedTimer} */(this));
      this.then = then;
      this._resolve = _core_consts_js__WEBPACK_IMPORTED_MODULE_0__.noop;
    };
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      // Make sure to resolve imediatly if the timer has already completed
      if (this.completed) this._resolve();
      return this;
    });
  }

}

/**
 * @param {TimerParams} [parameters]
 * @return {Timer}
 */
const createTimer = parameters => new Timer(parameters, null, 0).init();




/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiDrag: () => (/* binding */ MultiDragPlugin),
/* harmony export */   Sortable: () => (/* binding */ Sortable),
/* harmony export */   Swap: () => (/* binding */ SwapPlugin),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**!
 * Sortable 1.15.6
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.6";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, 'pointerup', _this._onDrop);
        // Native D&D triggers pointercancel
        !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);
      } else {
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop);
      }

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        if (options.supportPointer) {
          on(ownerDocument, 'pointerup', _this._disableDelayedDrag);
          on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);
        } else {
          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        }
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'pointerup', this._disableDelayedDrag);
    off(ownerDocument, 'pointercancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'pointercancel', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild,
  expando: expando
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable,
        cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              (function () {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;
                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }
                var filter = options.filter;
                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  // Check if element is draggable
                  if (!closest(children[i], options.draggable, parentEl, false)) continue;
                  // Check if element is filtered
                  var filtered = filter && (typeof filter === 'function' ? filter.call(sortable, evt, children[i], sortable) : filter.split(',').some(function (criteria) {
                    return closest(children[i], criteria.trim(), parentEl, false);
                  }));
                  if (filtered) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: 'select',
                    targetEl: children[i],
                    originalEvent: evt
                  });
                }
              })();
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!****************************************!*\
  !*** ./js/src/editor/backend/index.js ***!
  \****************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _templates_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./templates.js */ "./js/src/editor/backend/templates.js");
/* harmony import */ var _uigeneral_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uigeneral.js */ "./js/src/editor/backend/uigeneral.js");
/* harmony import */ var _sectionscontainer_class_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sectionscontainer.class.js */ "./js/src/editor/backend/sectionscontainer.class.js");
/* harmony import */ var _settings_panel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.panel.js */ "./js/src/editor/backend/settings.panel.js");
/* harmony import */ var _sections_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sections.js */ "./js/src/editor/backend/sections.js");
/* harmony import */ var _dragndrop_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dragndrop.js */ "./js/src/editor/backend/dragndrop.js");
/* harmony import */ var _codegeneration_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./codegeneration.js */ "./js/src/editor/backend/codegeneration.js");
/* harmony import */ var _scroller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scroller.js */ "./js/src/editor/backend/scroller.js");
/* harmony import */ var _utils_class_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils.class.js */ "./js/src/editor/backend/utils.class.js");
/* harmony import */ var _modalwindow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modalwindow.js */ "./js/src/editor/backend/modalwindow.js");
/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./module.js */ "./js/src/editor/backend/module.js");
/* harmony import */ var _presets_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./presets.js */ "./js/src/editor/backend/presets.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./events.js */ "./js/src/editor/backend/events.js");
/**
 * Main builder file
 */
















var dslcDebug = false;
window.dslcDebug = true;

// Global Plugin Object
window.LiveComposer = {

    Builder: {

        Elements: {},
        UI: {},
        Actions: {},
        Flags: {},
        PreviewFrame: {},
        Helpers: {},

        // ----------------------------------------------------
        // ** NEW: HISTORY MANAGEMENT OBJECT **
        // ----------------------------------------------------
        History: {
            undoStack: [],
            redoStack: [],
            maxHistory: 5 // Limit the history stack size
        }
    },
    Production: {

    },
    Utils: {}
};

(function(){

    LiveComposer.Builder.Flags = {

        windowScroller: false,
        panelOpened: false, // Settings panel opened
        uiHidden: false, // ex composer-hidden
        modalOpen: false,

        // Used to prevent multiple code generation when
        // cancelling row edits or applying historical states
        generate_code_after_row_changed: true
    };

    LiveComposer.Builder.Actions = {

        postponed_actions_queue: {},
        add_postponed_action: function( action_name ) {

            if (action_name === undefined) {
                return;
            }

            if ( isNaN ( this.postponed_actions_queue[ action_name ] ) ) {
                this.postponed_actions_queue[ action_name ] = 0;
            }

            this.postponed_actions_queue[ action_name ] += 1;
        },

        release_postponed_actions: function() {

            var self = this;

            jQuery.each( this.postponed_actions_queue, function(index, value) {

                if ( 1 < value ) {
                    self.postponed_actions_queue[index] -= 1;
                } else if ( 1 == value ) {
                    window[index](); // Run function with action name
                    self.postponed_actions_queue[index] -= 1;
                }
            });
        },

        // LiveComposer.Builder.Actions.optionsChanged() - if calling from parent.
        // parent.LiveComposer.Builder.Actions.optionsChanged() - if calling from iframe.
        optionsChanged: function () {
            window.dslc_show_publish_button();
        },

        // ----------------------------------------------------
        // ** NEW: UNDO/REDO FUNCTIONS **
        // ----------------------------------------------------

        /**
         * 💾 Captures the current state of the page content and saves it to the undoStack.
         */
        saveState: function() {
			console.log('Saving the state');
            var history = LiveComposer.Builder.History;

            // Capture the current HTML of the main content area
            var currentState = LiveComposer.Builder.PreviewAreaDocument.find("#dslc-main").html();

            // Guard: Prevent saving redundant states
            if (currentState && history.undoStack.length > 0 && history.undoStack[history.undoStack.length - 1] === currentState) {
                return;
            }

            // 1. Push current state to undo stack
            history.undoStack.push(currentState);

            // 2. Limit the stack size
            if (history.undoStack.length > history.maxHistory) {
                history.undoStack.shift(); // Remove the oldest state (first-in)
            }

            // 3. Any new action clears the redo stack
            history.redoStack = [];

            // TODO: Optional: Call a function to visually update Undo/Redo buttons
            // LiveComposer.Builder.Actions.updateUndoRedoUI();
        },

        /**
         * 🔄 Applies a historical HTML state to the editor content area.
         * @param {string} stateHTML - The saved HTML content.
         */
        applyState: function(stateHTML) {
			var mainContainer = LiveComposer.Builder.PreviewAreaDocument.find("#dslc-main").eq(0);

			// ... (Flags set to false here) ...

			// 1. Replace the HTML content in the preview area
			mainContainer.html(stateHTML);
			mainContainer.find('.dslc-module-front').css('opacity', 1);

			// 2. **CRITICAL: Re-initialize and Re-bind Functions**

			// These need to re-bind events and functionality on the new DOM
			if (typeof _sections_js__WEBPACK_IMPORTED_MODULE_4__.sectionsInit === 'function') (0,_sections_js__WEBPACK_IMPORTED_MODULE_4__.sectionsInit)(); // Re-initialize rows/sections
			if (typeof _dragndrop_js__WEBPACK_IMPORTED_MODULE_5__.dragAndDropInit === 'function') (0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_5__.dragAndDropInit)(); // Re-bind D&D handlers
			if (typeof _uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.fixContenteditable === 'function') (0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.fixContenteditable)(); // Re-initialize editors

			// *** ADD ANY MISSING RENDERING/INIT FUNCTIONS HERE ***

			// Live Composer rendering functions (must run on the new DOM structure)
			// Note: These must be available on the preview area window object
			LiveComposer.Builder.PreviewAreaWindow.dslc_masonry();
			LiveComposer.Builder.PreviewAreaWindow.dslc_carousel();
			LiveComposer.Builder.PreviewAreaWindow.dslc_tabs();
			LiveComposer.Builder.PreviewAreaWindow.dslc_init_accordion(); 

			// 3. Re-enable the code generation flag
			LiveComposer.Builder.Flags.generate_code_after_row_changed = true;

			// 4. Trigger the final code generation and UI update
			window.dslc_generate_code();
			LiveComposer.Builder.Actions.optionsChanged();
		},

        /**
         * ⏪ Reverts to the previous page state.
         */
		undo: function() {
			console.log('undo is called');
            var history = LiveComposer.Builder.History;

            // Need at least two states: the current state and the previous state to revert to.
            if (history.undoStack.length < 2) {
                return;
            }

            // 1. Pop the current state and push it to the redo stack
            var currentState = history.undoStack.pop();
            history.redoStack.push(currentState);

            // 2. Get the previous state (the new last item) and apply it
            var previousState = history.undoStack[history.undoStack.length - 1];
            LiveComposer.Builder.Actions.applyState(previousState);

            // TODO: Optional: Update UI
            // LiveComposer.Builder.Actions.updateUndoRedoUI();
        },

        /**
         * ⏩ Re-applies the next state after an undo operation.
         */
        redo: function() {
			console.log('redo is called');
            var history = LiveComposer.Builder.History;

            if (history.redoStack.length === 0) {
                return;
            }

            // 1. Pop the next state from the redo stack
            var futureState = history.redoStack.pop();

            // 2. Apply the future state
            LiveComposer.Builder.Actions.applyState(futureState);

            // 3. Push the applied state back onto the undo stack
            history.undoStack.push(futureState);

            // TODO: Optional: Update UI
            // LiveComposer.Builder.Actions.updateUndoRedoUI();
        }
    }

    /**
     * Inserts module fixing inline scripts bug
     * (Original LiveComposer.Builder.Helpers.insertModule function)
     * ...
     */
    LiveComposer.Builder.Helpers.insertModule = function( moduleHTML, afterObject ) {

        var newModule = jQuery(moduleHTML),
            afterObject = jQuery(afterObject);

        var scripts = [];

        newModule.find('script').each(function(){

            scripts.push(this.innerHTML);
            this.parentNode.removeChild(this);
        });

        // Insert 'updated' module output after module we are editing.
        // && Delete 'old' instance of the module we are editing.
        afterObject
            .after(newModule)
            .remove();

        scripts.forEach(function(item) {

            var script = LiveComposer.Builder.PreviewAreaDocument[0].createElement('script');
            script.innerHTML = item;
            script.type = 'text/javascript';

            LiveComposer.Builder.PreviewAreaDocument[0].getElementById(newModule[0].id).appendChild(script);
        });

        scripts = null;
        afterObject = null;

        return newModule;
    }
}());

/** Wait till tinyMCE loaded */
window.previewAreaTinyMCELoaded = function( windowObj ){
    LiveComposer.Builder.PreviewAreaWindow = windowObj;
    LiveComposer.Builder.PreviewAreaDocument = jQuery(windowObj.document);

    // Disable WP admin bar in editing mode
    jQuery('#wpadminbar', LiveComposer.Builder.PreviewAreaDocument).remove();

    // LiveComposer.Builder.UI.initInlineEditors();
    (0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.fixContenteditable)();

    (0,_templates_js__WEBPACK_IMPORTED_MODULE_0__.templatesPanelInit)();
    (0,_settings_panel_js__WEBPACK_IMPORTED_MODULE_3__.settingsPanelInit)();

    (0,_sections_js__WEBPACK_IMPORTED_MODULE_4__.sectionsInit)();

    var mainDraggable = LiveComposer.Builder.PreviewAreaDocument.find("#dslc-main").eq(0)[0];
    new _sectionscontainer_class_js__WEBPACK_IMPORTED_MODULE_2__.CSectionsContainer( mainDraggable );

    jQuery(document).trigger('editorFrameLoaded');
    (0,_dragndrop_js__WEBPACK_IMPORTED_MODULE_5__.dragAndDropInit)();
    (0,_codegeneration_js__WEBPACK_IMPORTED_MODULE_6__.codeGenerationInitJS)();
    window.dslc_generate_code();
    clearInterval(LiveComposer.Builder.Flags.windowScroller);
    LiveComposer.Builder.Flags.windowScroller = false;

    // ------------------------------------------------------------------
    // ** IMPORTANT: Initial state capture after editor is fully loaded **
    // ------------------------------------------------------------------
    LiveComposer.Builder.Actions.saveState();

    // Catch keypress events (from both parent and iframe) to add keyboard support
    (0,_uigeneral_js__WEBPACK_IMPORTED_MODULE_1__.keypressEvents)();
    (0,_scroller_js__WEBPACK_IMPORTED_MODULE_7__.initPreviewAreaScroller)();
    (0,_modalwindow_js__WEBPACK_IMPORTED_MODULE_9__.modalwindowInitJS)();
    (0,_module_js__WEBPACK_IMPORTED_MODULE_10__.moduleInitJS)();
    (0,_utils_class_js__WEBPACK_IMPORTED_MODULE_8__.untilsInitJs)();
    (0,_presets_js__WEBPACK_IMPORTED_MODULE_11__.presetsInit)();
    (0,_events_js__WEBPACK_IMPORTED_MODULE_12__.eventsInit)();
};

// Disable the prompt ( are you sure ) on refresh
window.onbeforeunload = function () { return; };
})();

/******/ })()
;
//# sourceMappingURL=editor_backend.min.js.map